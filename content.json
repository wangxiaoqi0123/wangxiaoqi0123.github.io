{"meta":{"title":"我寄白雪三千片","subtitle":"","description":"前端笔记","author":"王小七","url":"http://yoursite.com","root":"/"},"pages":[{"title":"标签","date":"2020-07-10T16:10:48.000Z","updated":"2023-10-20T03:18:20.787Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-07-10T16:14:16.000Z","updated":"2023-10-20T03:18:20.787Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux进程","slug":"linux/07","date":"2024-05-15T16:00:00.000Z","updated":"2024-05-16T03:56:17.498Z","comments":true,"path":"2024/05/16/linux/07/","link":"","permalink":"http://yoursite.com/2024/05/16/linux/07/","excerpt":"","text":"进程就是系统中正在运行的程序（linux 的命令也是程序）。 查看进程用ps命令可以查看进程。方法一： 1ps -ef|less2ps -ef|grep [关键字] 字段名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 说明 UID 启动进程的用户名。 PID 进程编号。 PPID 父进程编号。 C 进程当前占用 CPU 的百分比，如果该值过高，需要重点关注。 STIME 进程启动的时间。 TTY 运行进程的终端：tty1 是图形化终端；tty2-tty6 是本地字符界面终端；pts/0-255 是虚拟终端；?是与终端无关的后台进程。 TIME 进程使用的 CPU 时间（合计）。 CMD 产生此进程的程序或命令。 方法二： 1ps aux|less2ps aux|grep [关键字] 字段名 说明 USER 启动进程的用户名。 PID 进程编号。 %CPU 进程占用的CPU百分比。 %MEM 占用内存的百分比。 VSZ 该进程使用的虚拟內存量（KB）。 RSS 该进程使用的物理內存量（KB）。 TTY 运行进程的终端：tty1是图形化终端；tty2-tty6是本地字符界面终端；pts/0-255是虚拟终端；?是与终端无关的后台进程。 STAT 进程的状态。 START 进程启动的时间。 TIME 进程使用的CPU时间（合计）。 COMMAND 产生此进程的程序或命令。 其中STAT常见的状态有： 字段名 说明 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R 运行状态 S 休眠状态 T 暂停状态 Z 僵尸状态 &lt; 优先级高的进程 N 优先级低的进程 s 进程的领导者（在它之下有子进程） l 多线程 + 前台显示的进程 终止进程1kill 进程编号2killall 程序名 加-9的选项表示强行终止进程。","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Linux环境变量","slug":"linux/06","date":"2024-05-14T16:00:00.000Z","updated":"2024-05-15T09:27:42.878Z","comments":true,"path":"2024/05/15/linux/06/","link":"","permalink":"http://yoursite.com/2024/05/15/linux/06/","excerpt":"","text":"查看环境变量1.env命令在shell下，用env命令查看当前用户全部的环境变量。 1env2env|less3env|grep LANG 2.echo命令 1echo $环境变量名 常用环境变量1.LANGLinux系统的语言和字符集，默认的中文字符zh_CN.UTF-8。2.SHELL用户当前使用的shell 的路径，如 bash 或 zsh。3.HOSTNAME服务器的主机名。4.HISTSIZE保存历史命令的数目。5.USER当前登录用户的用户名。6.HOME当前登录用户的主目录。7.PWD当前工作目录。8.PATH可执行程序的搜索目录，决定了 shell 将到哪些目录中寻找命令或程序。 设置环境变量1.基本语法 1export 变量名&#x3D;&#39;值&#39; =前后不能有空格。如果环境变量的值没有空格等特殊符号，值可以不用单引号包含。这种方法定义的变量只存储在当前会话,环境变量会在退出shell后就会失效，下次登录时需要重新设置。如果希望环境变量永久生效，需要在脚本文件中配置。 2.设置PATH环境变量注意export PATH=$PATH:新增的目录1:新增的目录2:新增的目录n:.1）$PATH表示包含原有PATH的值；2）目录之间用:分隔；3）.表示当前目录。 设置系统环境变量系统环境变量对全部的用户生效，设置系统环境变量有三种方法。 1.在/etc/profile.d目录中增加设置环境变量脚本文件（Linux推荐）。进入/etc/profile.d目录 1cd &#x2F;etc&#x2F;profile.d 自定义创建脚本文件 1vi test.sh 设置环境变量 1TEST_ENV&#x3D;&#39;hello world!&#39;2export TEST_ENV 刷新环境变量 1source &#x2F;etc&#x2F;profile 查看环境变量 1echo $TEST_ENV 1env | grep TEST_ENV 2.在/etc/profile文件中设置环境变量（Linux不建议）。用户登录时执行/etc/profile文件中设置系统的环境变量。但是，Linux不建议在/etc/profile文件中设置系统环境变量。/etc/profile在每次启动时会执行 /etc/profile.d下全部的脚本文件。/etc/profile.d比/etc/profile好维护，不想要什么变量直接删除 /etc/profile.d下对应的 shell 脚本即可。 3.在/etc/bashrc文件中设置环境变量（Linux不建议）。 设置用户环境变量用户环境变量只对当前用户生效 1.~/.bash_profile（推荐首选）当用户登录时执行，每个用户都可以使用该文件来配置专属于自己的环境变量。打开文件 1vi ~&#x2F;.bash_profile 添加环境变量 1export TEST_USER_ENV&#x3D;&#39;a boy!&#39; 刷新环境变量 1source ~&#x2F;.bash_profile 2.~/.bashrc当用户登录时以及每次打开新的shell时该文件都将被读取，不推荐在里面配置用户专用的环境变量，因为每开一个shell，该文件都会被读取一次，效率肯定受影响。打开文件 1vi ~&#x2F;.bashrc 添加环境变量 1export TEST_USER_ENV&#x3D;&#39;a girl!&#39; 刷新环境变量 1source ~&#x2F;.bashrc","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Linux系统服务管理","slug":"linux/05","date":"2024-05-12T16:00:00.000Z","updated":"2024-05-13T10:09:34.099Z","comments":true,"path":"2024/05/13/linux/05/","link":"","permalink":"http://yoursite.com/2024/05/13/linux/05/","excerpt":"","text":"服务的配置文件存放在/usr/lib/systemd/system目录中。重点关注的服务有防火墙（firewalld.service）、远程登录（sshd.service，SSH协议）、文件传输（vsftpd.service，FTP协议）。 systemctl常用命令systemctl命令的形式是：systemctl [操作] [服务名] 或者 systemctl [操作] [服务名.service] 1.启动服务 1systemctl start [服务名] 2.停止服务 1systemctl stop [服务名] 3.重启服务 1systemctl restart [服务名] 4.查看服务是否已启动 1systemctl is-active [服务名] 5.查看服务的状态 1systemctl status [服务名] 6.启用开机自启动服务 1systemctl enable [服务名] 7.禁用开机自启动服务 1systemctl disable [服务名] 8.查看服务是否为开机自启动 1systemctl is-enabled [服务名] 9.查看所有服务的状态 1systemctl list-unit-files --type service 10.查看启动成功的服务列表 1systemctl list-unit-files|grep enabled 11.查看启动失败的服务列表 1systemctl --failed 12.列出在指定服务之前启动的服务（依赖） 1systemctl list-dependencies --after [服务名] 13.列出在指定服务之后启动的服务（被依赖） 1systemctl list-dependencies --before [服务名]","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Linux主机防火墙","slug":"linux/03","date":"2024-05-11T16:00:00.000Z","updated":"2024-05-13T07:30:51.679Z","comments":true,"path":"2024/05/12/linux/03/","link":"","permalink":"http://yoursite.com/2024/05/12/linux/03/","excerpt":"","text":"防火墙的基本概念防火墙技术是用于安全管理的软件和硬件设备，在计算机内/外网之间构建一道相对隔绝的保护屏障，以保护数据和信息安全性的一种技术。防火墙分网络防火墙和主机防火墙。网络防火墙由硬件加软件组成，可以保护整个网络，价格也很贵，从几万到几十万的都有，功能非常强大，主要包括入侵检测、网络地址转换、网络操作的审计监控、强化网络安全服务等功能。主机防火墙只有软件部分（操作系统和杀毒软件自带），用于保护本操作系统，功能比较简单，只能防范简单的攻击。 查看防火墙的命令1.查看防火墙服务状态（普通用户可执行），CentOS默认启用防火墙。 1systemctl status firewalld 2.查看防火墙已开通的端口，CentOS默认不开通任何端口。 1firewall-cmd --list-port 3.查看防火墙已开通的服务（CentOS默认开通ssh和dhcpv6-client服务）。 1firewall-cmd --list-service 4.查看防火墙全部的信息。 1firewall-cmd --list-all 5.查看防火墙支持的服务的列表（普通用户可执行）。 1firewall-cmd --get-services 6.查看防火墙服务是否开机启动。 1systemctl is-enabled firewalld 7.查看防火墙的状态。 1firewall-cmd --state 8.查看防火墙的版本。 1firewall-cmd --version 配置防火墙的命令1.启动、重启、关闭防火墙服务。 1# 启动2systemctl start firewalld3# 重启4systemctl restart firewalld5# 关闭6systemctl stop firewalld 2.开通、移去端口。 1# 开通80端口2firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent3# 移去80端口4firewall-cmd --zone&#x3D;public --remove-port&#x3D;80&#x2F;tcp --permanent 3.开通、移除服务。 1# 开通ftp服务2firewall-cmd --zone&#x3D;public --add-service&#x3D;ftp --permanent3# 移去http服务4firewall-cmd --zone&#x3D;public --remove-service&#x3D;http --permanent5# 常用服务的端口：ssh(22）、HTTP(80、8080)、MySQL(3306)、Oracle(1521) 、ftp(21）、6telnet(23）。 4.开通、移去范围端口。 1# 开通5000-5500之间的端口2firewall-cmd --zone&#x3D;public --add-port&#x3D;5000-5500&#x2F;tcp --permanent3# 移去5000-5500之间的端口4firewall-cmd --zone&#x3D;public --remove-port&#x3D;5000-5500&#x2F;tcp --permanent 5.重新加载防火墙配置参数（修改配置后要重新加载防火墙配置或重启防火墙服务.。 1firewall-cmd --reload 6.设置开机时启用、禁用防火墙服务。 1# 启用服务2systemctl enable firewalld3# 禁用服务4systemctl disable firewalld","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Linux用户及权限管理","slug":"linux/02","date":"2024-05-10T16:00:00.000Z","updated":"2024-05-11T06:57:31.998Z","comments":true,"path":"2024/05/11/linux/02/","link":"","permalink":"http://yoursite.com/2024/05/11/linux/02/","excerpt":"","text":"用户管理1、组管理Linux的用户属于组（角色），系统可以对一个组中的全部用户进行集中管理（权限）。创建组：groupadd 组名删除组：groupdel 组名组的信息保存在文件/etc/group中。 2、用户管理创建用户：useradd -n 用户名 -g 组名 -d 用户的主目录删除用户：userdel 用户名用户的信息保存在文件/etc/passwd中。 3、修改用户的密码创建用户后，必须设置它的密码，否则无法登录。root用户可以修改任何用户的密码：passwd 用户名普通用户只能修改自己的密码：passwd用户的密码保存在 文件/etc/shadow中。 4、切换用户root用户可以免密码切换到任何用户：su - 用户名普通用户切换到其它用户：su - 或su - 用户名，然后输入目标用户的密码。 5、修改目录和文件的拥有者用root用户执行：chown -R 用户:组 目录和文件列表-R选项表示连同各子目录一起修改。 目录文件权限1.目录和文件的详细信息ls -l 命令可以列出目录和文件权限、大小、用户和组等信息。 第1列权限的标志位。第1个字符为文件类型：d是目录；-是普通文件；l是链接；p是管道文件；b是块设备文件（硬盘）；c是字符设备文件（终端、打印机）；s是套接字文件；第2-10个字符为文件权限（r-读权限；w-写权限；x-可执行权限，-表示无权限） 第2列是文件硬链接数或目录的子目录数 第3列是文件拥有者用户 第4列是文件拥有者用户所在组 第5列是目录或文件的大小 第6、7、8列是目录或文件最后一次被修改的时间 第9列是目录或文件名 2.文件的权限r：表示具有读取文件内容的权限。w：表示具有修改文件内容的权限，同时需要有r权限。注意，如果要删除文件，需要有目录的w权限。x：表示具有执行文件的权限，同时需要有r权限。注意，文件是否能真的执行，还要由文件本身决定。 3.目录的权限x：表示可以进入目录。r：表示可以浏览目录中有哪些子目录和文件，同时需要有x权限。w：表示可以在目录中新增、删除、移动子目录和文件，同时需要有x权限。 4.设置权限（八进制语法）权限也可以用八进制的数字表示：r的值为4，w的值为2，x的值为1。7 rwx &nbsp;&nbsp; 6 rw- &nbsp;&nbsp; 5 r-x &nbsp;&nbsp; 4 r-- &nbsp;&nbsp; 3 -wx &nbsp;&nbsp; 2 -w- &nbsp;&nbsp; 1 --x &nbsp;&nbsp; 0 --- 1chmod [三位的八进制权限] [目录和文件列表]2chmod -R [三位的八进制权限] [目录和文件列表] 所有目录各子目录一起设置权限 5.设置权限（符号模式） 1chmod [who][operator][permission] [目录和文件列表]2chmod -R [who][operator][permission] [目录和文件列表] 所有目录各子目录一起设置权限 who 用户类型 描述 u user 文件的所有者 g group 文件所有者的组 o others 其它用户 a all 全部用户，相当于ugo operator 说明 + 增加权限 - 取消权限 = 重新设置权限","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Linux相关操作","slug":"linux/04","date":"2024-04-28T16:00:00.000Z","updated":"2024-05-13T07:03:09.948Z","comments":true,"path":"2024/04/29/linux/04/","link":"","permalink":"http://yoursite.com/2024/04/29/linux/04/","excerpt":"","text":"软件包安装1、安装软件包 1yum -y install [软件包名] 2、删除软件包 1yum -y remove [软件包名] 3、升级软件包 1yum update [软件包名] 4、如何知道需要安装的软件包名百度5、yum仓库互联网上有很多yum仓库，不需要任何配置就可以使用不允许访问互联网的企业用户可能自建yum仓库6、查找软件包。 1yum search [软件包名] 7、列出所有可更新的软件包清单 1yum check-update 8、更新所有软件包 1yum update 9、列出所有可安装软件包的清单 1yum list 附件上传下载建立SFTP链接1.显示本地当前目录 1lpwd 2.显示服务器当前目录 1pwd 3.列出本地目录中的内容 1lls -l [目录名] 4.列出服务器目录中的内容 1ls -l [目录名] 5.切换本地当前目录 1lcd [目录名] 6.切换服务器当前目录 1cd [目录名] 7.上传文件 1put [文件名] &#x2F;&#x2F; 可以用\\*匹配文件名。 8.下载文件 1get [文件名] &#x2F;&#x2F; 可以用\\*匹配文件名。 9.退出SFTP 1exit 压缩与解压1.查看压缩文件目录 1zip -sf [压缩包名]2unzip -l [压缩包名] 2.压缩文件 1zip -r [设置压缩包名] [目录和文件名列表可多选可正则] 3.压缩包追加文件 1zip -u [压缩包名] [目录和文件名列表可多选可正则] 4.压缩包中删除指定的文件 1zip -d [压缩包名] [目录和文件名列表可多选可正则] 5.解压（压缩包所用文件到当前目录下） 1upzip [压缩包名] 6.解压指定目录 1upzip -d [目录名] [压缩包名]","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Linux文件及目录","slug":"linux/01","date":"2024-04-25T16:00:00.000Z","updated":"2024-05-13T07:03:14.786Z","comments":true,"path":"2024/04/26/linux/01/","link":"","permalink":"http://yoursite.com/2024/04/26/linux/01/","excerpt":"","text":"目录文件操作1.查看当前路径 1pwd 2.查看当前目录下所有文件 1ls2ls -a 列出目录所有文件，包含以.开始的隐藏文件3ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来4ls -t 以文件修改时间排序5ls -h 以易读大小显示 3.查找目录和文件 1find [查找目录] -name&quot;[文件名]&quot; -print 4.正则匹配 1* 模糊匹配一个或多个字符2? 匹配一个字符3&#x2F;&#x2F; 示例：4find . -name &quot;*.h&quot; -print5grep &#39;99$&#39; file2.txt 5.切换目录 1cd [相对路径|绝对路径] 6.创建目录 1mkdir [相对路径|绝对路径] 7.创建文件 1touch [文件名]2[任意可以屏幕输出内容的命令] &gt; [文件名] 文件不存在时创建，文件存在时内容覆盖3[任意可以屏幕输出内容的命令] &gt;&gt; [文件名] 文件不存在时创建，文件存在时内容追加 8.删除目录和文件 1rm 删除文件2rm -r 删除目录文件3rm -f 强制删除，不需要确认 9.复制目录和文件 1cp [旧文件路径] [新文件路径]2cp -r [旧目录或文件路径] [新目录或文件路径] 10.移动目录或文件/重命名目录或文件 1mv [旧目录或文件路径] [新目录或文件路径] 第二个参数不存在移动该位置，存在移动到该目录下 文件内容查看1.vim 1vi [文件名] 打开一个文件，如果文件不存在，就创建它。 vi 有两种模式，命令模式和编辑模式，在命令模式下，键盘输入是命令，在编辑模式下，键盘输入的才是字符。vi的常用命令 命令 描述 k 类似方向键上。 j 类似方向键下。 h 类似方向键左。 l 类是方向键右。 i 在光标所在位置前面开始插入。 a 在光标所在的位置后面开始插入。 o 在光标所在位置的下面插入空白行。 O 在光标所在位置的上面插入空白行。 I 在光标所在位置的行首开始插入。 A 在光标所在位置的行末开始插入。 Ctrl+u 上翻半页。 Ctrl+d 下翻半页。 Esc 从编辑模式切换到命令模式。 :w回车 存盘。 :w!回车 强制存盘。 :wq回车 存盘退出。 :w 文件名 把当前文件另存为…… :x回车 存盘退出。 :q回车 不存盘退出。 :q!回车 不存盘强制退出。 2.查看文件内容cat 1cat [文件名] 一次显示文件全部的内容，适用于内容很少的文本文件。 3.查看文件的内容less 1less [文件名] 按space（空格键）继续显示；Ctrl+u上翻页；Ctrl+d下翻页；j下一行；k上一行；q退出。 4.查看文件的内容more 1more [文件名] 按space（空格键）显示下一页；按b显示上一页；q退出。 5.统计文件的行数wc 1wc [文件名可多个] 6.查找文件中的内容grep 1grep &quot;[搜索内容]&quot; [文件名可多个] 7.显示文件头部的内容head 1head -[行数] [文件名] 8.显示文件尾部的内容tail 1tail -[行数] [文件名] 9.跟踪文件尾部的内容tail -f 1tail -f [文件名] 文件变化打印变化内容 10.管道 管道就是将一个命令输出的内容重定向为另一个命令的输入。 管道操作符是|，用它将命令连起来就行了。 1&#x2F;&#x2F; 示例2ls -l|more3grep &quot;90&quot; file.txt|wc 目录文件相关1.相对路径和绝对路径绝对路径是从根（/）算起。相对路径是从当前目录算起，如果当前目录是/usr/include，stdio.h等同于/usr/include/stdio.h。 2.链接Linux链接分硬链接和软链接（符号链接）。硬链接可以简单的理解为文件的别名，只能为文件创建硬链接，不能为目录创建硬链接。 1ln [文件名] [链接名] 硬链接不能跨文件系统。硬链接允许一个文件拥有多个有效文件名，如果为重要文件建立硬链接，可以防止“误删除”，只有当删除最后一个链接的时候，文件才会被真正的删除。软链接类似Windows的快捷方式，可以为目录和文件创建软链接。 1ln -s [目录或文件名] [链接名]","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"pdfjs","slug":"technical/technical08","date":"2024-03-05T16:00:00.000Z","updated":"2024-03-06T09:44:34.209Z","comments":true,"path":"2024/03/06/technical/technical08/","link":"","permalink":"http://yoursite.com/2024/03/06/technical/technical08/","excerpt":"","text":"web viewer1.通过官网 https://mozilla.github.io/pdf.js/getting_started/#download 下载预览工具包。 2.将下载的文件夹解压到项目中。 3.项目中可通过 viewer.html 页面后面拼接参数预览，也可与 iframe 嵌套页面上使用。 1&lt;iframe2 :src&#x3D;&quot;&#96;&#x2F;pdfjs-4.0.379-dist&#x2F;web&#x2F;viewer.html?file&#x3D;$&#123;encodeURIComponent(&#39;https:&#x2F;&#x2F;mozilla.github.io&#x2F;pdf.js&#x2F;web&#x2F;compressed.tracemonkey-pldi-09.pdf&#39;)&#125;&#96;&quot;3&gt;&lt;&#x2F;iframe&gt; 4.地址栏上参数配置 地址栏?后面参数 字段 描述 值类型 file 需要预览的文件地址 String（注意附件地址中有特殊符号需要使用encodeURIComponent编码处理） 地址栏#后面参数 字段 描述 值类型 zoom 页面缩放方式 auto: 自动调整以适合视图。 page-actual: 显示实际大小的页面。 page-fit: 调整页面以适合视图。 page-width: 调整页面宽度以适合视图。 一个具体的百分比值，例如 150 或 200，表示页面应该放大到指定的百分比大小 page 初始默认页面 Number pagemode 侧边栏状态 none：不显示 thumbs：缩率图 bookmarks： attachments https://github.com/mozilla/pdf.js/wiki/Viewer-options 5.注意事项在线pdf地址处理，注释viewer.mjs内代码 1&#123;2 const HOSTED_VIEWER_ORIGINS &#x3D; [&quot;null&quot;, &quot;http:&#x2F;&#x2F;mozilla.github.io&quot;, &quot;https:&#x2F;&#x2F;mozilla.github.io&quot;];3 var validateFileURL &#x3D; function (file) &#123;4 if (!file) &#123;5 return;6 &#125;7 try &#123;8 const viewerOrigin &#x3D; new URL(window.location.href).origin || &quot;null&quot;;9 if (HOSTED_VIEWER_ORIGINS.includes(viewerOrigin)) &#123;10 return;11 &#125;12 const fileOrigin &#x3D; new URL(file, window.location.href).origin;13 &#x2F;&#x2F; 需要注释代码14 &#x2F;&#x2F; if (fileOrigin !&#x3D;&#x3D; viewerOrigin) &#123;15 &#x2F;&#x2F; throw new Error(&quot;file origin does not match viewer&#39;s&quot;);16 &#x2F;&#x2F; &#125;17 &#125; catch (ex) &#123;18 PDFViewerApplication.l10n.get(&quot;pdfjs-loading-error&quot;).then(msg &#x3D;&gt; &#123;19 PDFViewerApplication._documentError(msg, &#123;20 message: ex?.message21 &#125;);22 &#125;);23 throw ex;24 &#125;25 &#125;;26&#125; pdfjs-dist1.安装 1npm i pdfjs-dist 2.设置pdfjsLib.GlobalWorkerOptions.workerSrc的地址涉及到工程打包构建，文件逻辑路径及名称可能会被转换，这里需要使用动态地址。webpack 1pdfjsLib.GlobalWorkerOptions.workerSrc &#x3D; require(&quot;pdfjs-dist&#x2F;build&#x2F;pdf.worker.min.js&quot;); vite 1pdfjsLib.GlobalWorkerOptions.workerSrc &#x3D; new URL(&#39;pdfjs-dist&#x2F;build&#x2F;pdf.worker.min.js&#39;, import.meta.url).href; 3.通过pdfjsLib.getDocument处理pdf数据，返回一个对象pdfDoc 1const pdfLoadingTask &#x3D; pdfjsLib.getDocument(&#123;2 url: url,3 cMapUrl: &#39;&#x2F;cmaps&#x2F;&#39;,4 cMapPacked: true,5 rangeChunkSize: 655366&#125;)7 pdfLoadingTask.promise.then(pdfDoc &#x3D;&gt; &#123;8 renderPdfCanvas(container, pdfDoc, container)9&#125;) 4.通过pdfDoc.getPage单独获取第1页的数据 1const renderPdfCanvas &#x3D; async (pdfViewerDom, pdfDoc, container) &#x3D;&gt; &#123;2 &#x2F;&#x2F; 清除原来的pdf画布3 pdfViewerDom.innerHTML &#x3D; &#39;&#39;4 &#x2F;&#x2F; 获取总页数5 const totalPage &#x3D; pdfDoc.numPages6 for (let i &#x3D; 1; i &lt;&#x3D; totalPage; i++) &#123;7 &#x2F;&#x2F; 循环处理pdf的每页8 await renderPdfOnePage(pdfViewerDom, pdfDoc, i, container)9 &#125;10&#125;111213const renderPdfOnePage &#x3D; async (pdfViewerDom, pdfDoc, pageNum, container) &#x3D;&gt; &#123;14 &#x2F;&#x2F; 创建画布15 const canvas &#x3D; document.createElement(&#39;canvas&#39;)16 pdfViewerDom.appendChild(canvas)17 const dpr &#x3D; window.devicePixelRatio || 11819 const currentWidth &#x3D; container.clientWidth2021 await pdfDoc.getPage(pageNum).then(page &#x3D;&gt; &#123;22 const ratio &#x3D; dpr &lt; 2 ? 2 : dpr2324 const pdfWidth &#x3D; page.getViewport(&#123; scale: 1 &#125;).width25 const scale &#x3D; currentWidth &#x2F; pdfWidth2627 &#x2F;&#x2F; 获取当前pdf页内容, 并设置缩放28 const viewport &#x3D; page.getViewport(&#123; scale: scale &#125;)2930 canvas.width &#x3D; viewport.width * ratio &#x2F;&#x2F; 实际渲染像素31 canvas.height &#x3D; viewport.height * ratio &#x2F;&#x2F; 实际渲染像素3233 canvas.style.width &#x3D; &#96;$&#123;viewport.width&#125;px&#96; &#x2F;&#x2F; 控制显示大小34 canvas.style.height &#x3D; &#96;$&#123;viewport.height&#125;px&#96; &#x2F;&#x2F; 控制显示大小3536 canvas.getContext(&#39;2d&#39;).setTransform(ratio, 0, 0, ratio, 0, 0)3738 const context &#x3D; canvas.getContext(&#39;2d&#39;)3940 &#x2F;&#x2F; 将pdf当前页内容画到2d画板中41 page.render(&#123; canvasContext: context, viewport &#125;)42 &#125;)43&#125; https://mozilla.github.io/pdf.js/api/draft/module-pdfjsLib.html 大文件切片预览服务端关键逻辑 1const http &#x3D; require(&quot;http&quot;);2const fs &#x3D; require(&quot;fs&quot;);34const server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;5 const filePath &#x3D; req.url.split(&quot;&#x2F;&quot;)[1] || &quot;1.pdf&quot;;6 fs.stat(filePath, (err, stat) &#x3D;&gt; &#123;7 if (err) &#123;8 res.writeHead(500, &#123; &quot;Content-Type&quot;: &quot;text&#x2F;plain&quot; &#125;);9 res.end(&quot;Internal Server Error&quot;);10 return;11 &#125;1213 &#x2F;&#x2F; 设置 CORS 头，允许所有域的请求14 res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);15 res.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, POST, PUT, DELETE&quot;);16 res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;);17 res.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);1819 const range &#x3D; req.headers.range;20 const fileSize &#x3D; stat.size;2122 if (fileSize &lt; 1 * 1024 * 1024) &#123;23 const file &#x3D; fs.createReadStream(filePath, &#123; start: 0, end: fileSize &#125;);24 file.pipe(res);25 return26 &#125;2728 if (range) &#123;29 const parts &#x3D; range.replace(&#x2F;bytes&#x3D;&#x2F;, &quot;&quot;).split(&quot;-&quot;);30 const start &#x3D; parseInt(parts[0], 10);31 const end &#x3D; parts[1] ? parseInt(parts[1], 10) : fileSize - 1;3233 const chunkSize &#x3D; end - start + 1;34 const file &#x3D; fs.createReadStream(filePath, &#123; start, end &#125;);3536 res.writeHead(206, &#123;37 &quot;Content-Range&quot;: &#96;bytes $&#123;start&#125;-$&#123;end&#125;&#x2F;$&#123;fileSize&#125;&#96;,38 &quot;Access-Control-Expose-Headers&quot;: &quot;Accept-Ranges,Content-Range&quot;,39 &quot;Content-Disposition&quot;: &#96;attachment;filename&#x3D;&quot;yldd.pdf&quot;&#96;,40 &quot;Accept-Ranges&quot;: &quot;bytes&quot;,41 &quot;Content-Length&quot;: chunkSize,42 &quot;Content-Type&quot;: &quot;application&#x2F;pdf&quot;,43 &#125;);4445 file.pipe(res);46 &#125; else &#123;47 res.writeHead(200, &#123;48 &quot;Accept-Ranges&quot;: &quot;bytes&quot;,49 &quot;Access-Control-Expose-Headers&quot;: &quot;Accept-Ranges,Content-Range&quot;,50 &quot;Content-Disposition&quot;: &#96;inline;filename&#x3D;&quot;yldd.pdf&quot;&#96;,51 &quot;Content-Length&quot;: fileSize,52 &quot;Content-Type&quot;: &quot;application&#x2F;pdf&quot;,53 &#125;);54 const file &#x3D; fs.createReadStream(filePath, &#123; start: 0, end: 0 &#125;);55 file.pipe(res);56 &#125;57 &#125;);58&#125;);5960const port &#x3D; 30001;61server.listen(port, () &#x3D;&gt; &#123;62 console.log(&#96;Server running at http:&#x2F;&#x2F;localhos:$&#123;port&#125;&#x2F;&#96;);63&#125;); 关键请求头参数Range 关键响应头参数Accept-RangesContent-RangeAccess-Control-Expose-HeadersContent-DispositionContent-LengthContent-Type","categories":[{"name":"技术点","slug":"技术点","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%82%B9/"}],"tags":[{"name":"技术点","slug":"技术点","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%82%B9/"}]},{"title":"Micro App微前端方案","slug":"configuration/configuration13","date":"2023-10-25T16:00:00.000Z","updated":"2023-10-26T10:34:34.977Z","comments":true,"path":"2023/10/26/configuration/configuration13/","link":"","permalink":"http://yoursite.com/2023/10/26/configuration/configuration13/","excerpt":"","text":"前言介绍从我的使用角度而言，微前端本质上做的事情，其实是对大型单体的前端应用将其拆分为多个小的、相对独立的子应用。借用一下Micro App官网图既然拆分成多个相对独立的应用，且这些应用都要集中运行在一起，那么自然而然就会出现一下的一些问题。样式如何隔离？元素如何隔离？js如何沙箱？应用直接如何通讯？…当然作为应用层的开发者来说，如何实现这些问题确不是我们的重点工作，框架一般会帮我们解决。我们的核心工作是在确保这些功能都正常运行的情况下，规划出整体的对接方案。 方案设计单页应用的接入方案单页应用是一个独立的闭环应用，从用户打开页面到进入页面有这以下几个关键逻辑。具体单页应用接入的实现方案可以参考这篇文章。从上述图中，可以看出一个独立应用的闭环系统，在进入页面时，基本都满足了，用户已登录、用户信息已获取到，以及用户拥有该页面的权限这些条件之后，页面才能展示出来。&nbsp; 微前端的接入方案所以微前端也需要实现该闭环逻辑，以达到业务逻辑的完整。&nbsp;基于京东Micro App接入方式可以将该闭环逻辑分别拆分到主应用、子应用中。主应用承担用户登录、以及用户信息获取的功能，此外主应用还必须确保这些信息都获取到之后才能开始加载子应用。子应用承担对应子应用下的页面权限的管控。当然还要包括应用之间数据通信，对应micro app而言提供了应用之间通讯，全局通讯.当然不仅仅是主应用主动向子应用通讯，子应用也可以主动向主应用数据通信。实际使用一般主应用会以方法的形式提供功能Api接口，供子应用使用。基于此完成数据通讯 具体实现登录鉴权与数据鉴权这块功能与单页应用中的登录鉴权与数据鉴权可以说是完全一样。具体流程就是：用户进入页面，先检查token是否存在，token不存在证明用户没有登录让用户去登录。token存在就检查用户基本信息是否存在，如果不存在就重新调取接口获取用户信息，存值pinia中，如果用户信息已存在就可以开始挂载子应用了。可参照单页应用接入方案。 需要注意的是，需要选好触发该操作的场景。这里是以vue作为主应用，vue路由匹配成功到就会加载对应的组件（页面），每个组件（页面）里面挂载不同的子应用。所以在主应用的全局路由守卫来触发改场景太合适了。 文件结构如下：router ├── auths │ ├── index.ts │ ├── initDataMiddleware.ts │ └── loginAuthMiddleware.ts └── index.ts 1// router/index.ts2import &#123; createRouter, createWebHistory &#125; from 'vue-router'3import beforeAuth from './auths'4const routes = [5 &#123;6 path: '/',7 redirect: '/vite4/'8 &#125;,9 &#123;10 path: '/vite4/:page*',11 component: () =&gt; import('../views/vite4.vue')12 &#125;,13 &#123;14 path: '/react/:page*',15 component: () =&gt; import('../views/react.vue')16 &#125;17] as any[]18const router = createRouter(&#123;19 history: createWebHistory(import.meta.env.BASE_URL),20 routes: routes21&#125;)22router.beforeEach(beforeAuth)23export default router beforeAuth与单页应用的逻辑基本一致，只是中间件数量上的区别，可参照单页应用接入方案。&nbsp;路由鉴权也是与单页应用的逻辑一致，唯一区别就是需要处理一下主应用那边下发的数据。文件结构如下：router├── auths│ ├── index.ts│ ├── initDataMiddleware.ts│ └── routeAuthMiddleware.ts└── index.ts 1import &#123; RouteLocationNormalized &#125; from &quot;vue-router&quot;;2import &#123; useUserStoreWithOut &#125; from &quot;&#x2F;@&#x2F;store&#x2F;modules&#x2F;user&quot;;34export default async (to: RouteLocationNormalized, _from: any, next: any) &#x3D;&gt; &#123;5 const userStore &#x3D; useUserStoreWithOut();67 &#x2F;&#x2F; 校验store里的userInfo 是否存在8 const userInfoToken &#x3D; userStore.token;9 if (!userInfoToken) &#123;10 const microStore &#x3D; window.microApp.getGlobalData()11 const data &#x3D; microStore.getUserInfo(); &#x2F;&#x2F; 返回主应用下发的data数据12 userStore.setUserInfo(data);13 &#125;1415 next();16&#125;; &nbsp;Micro App主应用接入整体来说micro的接入非常的简单，下载安装@micro-zoe/micro-app之后，在main.ts中start一下，然后组件中就可以使用webComponentmicro-app注册子应用了。文件结构如下：micro├── micro.config.ts├── micro.store.ts└── index.ts 1import microApp from '@micro-zoe/micro-app'2import microConfig from './micro.config'3import microStore from './micro.store'45microApp.start(microConfig)6microApp.setGlobalData(microStore) 1const microConfig = &#123;2 'disable-memory-router': true, // 关闭虚拟路由3 lifeCycles: &#123;4 created() &#123;5 // console.log('created 全局监听')6 &#125;,7 beforemount() &#123;8 // console.log('beforemount 全局监听')9 &#125;,10 mounted() &#123;11 // console.log('mounted 全局监听')12 &#125;,13 unmount() &#123;14 // console.log('unmount 全局监听')15 &#125;,16 error() &#123;17 // console.log('error 全局监听')18 &#125;19 &#125;,20 plugins: &#123;21 modules: &#123;&#125;22 &#125;23&#125;24export default microConfig 1import &#123; useUserStoreWithOut &#125; from '../store/modules/user'2const userStore = useUserStoreWithOut()34/** 获取用户基本信息 */5const getUserInfo = () =&gt; &#123;6 return userStore.userInfo7&#125;89/** 登录 */10const login = () =&gt; &#123;11 return userStore.login()12&#125;1314const microStore = &#123;15 getUserInfo,16 login17&#125;1819export default microStore 官方文档地址示例代码地址 问题记录micro app 目前还存在些许问题，记录一下方便后面问题处理。 1.&nbsp;路由回退路径会缺失使用router.push()切换到不同子应用时，路由回退路径会缺失。目前想到的解决办法是: 1history.pushState(&#123;&#125;, &#39;&#39;, path)2router.replace(&#123; path &#125;) 去替代router.push()&nbsp;2.&nbsp;vite中使用new URL()生成的动态路径错误vite中使用动态路径，一般按照一下方式；这样处理之后项目构建之后vite会自动帮我们替换成带有hash的文件地址。 1&lt;template&gt;2 &lt;button v-for&#x3D;&quot;item in list&quot; :key&#x3D;&quot;item&quot; @click&#x3D;&quot;fileType &#x3D; item&quot;&gt;3 &#123;&#123; item &#125;&#125;4 &lt;&#x2F;button&gt;5 &lt;img :src&#x3D;&quot;fileImage&quot; &#x2F;&gt;6&lt;&#x2F;template&gt;7&lt;script setup lang&#x3D;&quot;ts&quot;&gt;8const list &#x3D; [&quot;pdf&quot;, &quot;png&quot;, &quot;ppt&quot;];9const fileType &#x3D; ref(&quot;pdf&quot;);10const fileImage &#x3D; computed(() &#x3D;&gt; new URL(&#96;&#x2F;src&#x2F;assets&#x2F;$&#123;fileType.value&#125;.png&#96;, import.meta.url).href)11&lt;&#x2F;script&gt; 单在微前端环境中，这种方式得到的url地址的origin是微前端服务地址，而不是子应用的服务地址。这就导致图片加载失败。基于这个问题可以用 1const combineURLs &#x3D; (baseURL, relativeURL) &#x3D;&gt; &#123;2 return relativeURL3 ? &#96;$&#123;baseURL.replace(&#x2F;\\&#x2F;+$&#x2F;, &#39;&#39;)&#125;&#x2F;$&#123;relativeURL.replace(&#x2F;^\\&#x2F;+&#x2F;, &#39;&#39;)&#125;&#96;4 : baseURL5&#125;67const getMicroAssetsPath &#x3D; (url: URL) &#x3D;&gt; &#123;8 if (window.__MICRO_APP_ENVIRONMENT__) &#123;9 return combineURLs(window.__MICRO_APP_URL__, url.pathname)10 &#125; else &#123;11 return url.href12 &#125;13&#125;14const fileImage &#x3D; computed(() &#x3D;&gt; getMicroAssetsPath(new URL(&#96;&#x2F;src&#x2F;assets&#x2F;$&#123;fileType.value&#125;.png&#96;, import.meta.url)))","categories":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}]},{"title":"单页应用接入业务方案","slug":"configuration/configuration12","date":"2023-10-23T16:00:00.000Z","updated":"2023-10-25T09:04:43.317Z","comments":true,"path":"2023/10/24/configuration/configuration12/","link":"","permalink":"http://yoursite.com/2023/10/24/configuration/configuration12/","excerpt":"","text":"前端单页应用的框架基本搭建完成，要对接业务时，需要对登录鉴权、数据请求这个两个模块进行配置，已确保业务系统的正常接入。 登录鉴权登录鉴权一般按照以下流程对 用户是否登录、用户的基本信息是否存在、用户是否拥有当前页面权限 当都满足条件时，才允许访问当前页面。以vue3项目举例:应为必须满足某些条件（页面拥有用户信息、当前用户有该页面的权限），用户才能进入页面，所以处理的登录鉴权的场景在全局路由守卫的beforeEach中处理最为合适。 1import &#123; createRouter, createWebHistory &#125; from 'vue-router'2import beforeAuth from './auths'3import routes from './routes'45const router = createRouter(&#123;6 history: createWebHistory(import.meta.env.BASE_URL),7 routes: routes8&#125;)9router.beforeEach(beforeAuth)1011export default router &nbsp;为了处理这一系列任务，一般会用中间件的方式对每个场景单独处理，以降低代码的耦合度。 1import &#123; RouteLocationNormalized &#125; from 'vue-router'2import loginAuthMiddleware from './loginAuthMiddleware'3import initDataMiddleware from './initDataMiddleware'4import routeAuthMiddleware from './routeAuthMiddleware'56export type MiddlewareFn = (to: RouteLocationNormalized, from: RouteLocationNormalized, next: (...args: any[]) =&gt; void) =&gt; void78const middlewares = [loginAuthMiddleware, initDataMiddleware, routeAuthMiddleware]9const callMiddleware: MiddlewareFn = (to, from, next) =&gt; &#123;10 const stack = [...middlewares]11 const _next = (...args: any[]) =&gt; &#123;12 if (args.length &gt; 0 || stack.length === 0) return next(...args)13 const middleware = stack.shift() as MiddlewareFn14 middleware(to, from, _next)15 &#125;16 _next()17&#125;1819const beforeAuth: MiddlewareFn = (to, from, next) =&gt; &#123;20 callMiddleware(to, from, (...args: any[]) =&gt; &#123; next(...args) &#125;)21&#125;2223export default beforeAuth &nbsp;登录鉴权中间件 1import &#123; RouteLocationNormalized &#125; from 'vue-router'2import &#123; useUserStoreWithOut &#125; from '/@/store/modules/user'3import &#123; getToken &#125; from '/@/utils/token'45export default async (to: RouteLocationNormalized, _from: any, next: any) =&gt; &#123;6 const &#123; ticket &#125; = to.query7 const userStore = useUserStoreWithOut()8 const token = getToken()9 if (ticket &amp;&amp; !token) &#123;10 await userStore.getUserByTicket(ticket.toString())11 &#125;1213 if (!token &amp;&amp; !ticket) &#123;14 userStore.login()15 &#125;16 next()17&#125; &nbsp;数据鉴权中间件 1import &#123; RouteLocationNormalized &#125; from 'vue-router'2import &#123; useUserStoreWithOut &#125; from '/@/store/modules/user'34export default async (to: RouteLocationNormalized, _from: any, next: any) =&gt; &#123;5 const userStore = useUserStoreWithOut()67 const reqList = []8 // 校验store里的userInfo 是否存在9 const userInfoToken = userStore.token10 if (!userInfoToken) &#123;11 reqList.push(userStore.getUserByToken)12 &#125;1314 // 校验store里的meuns 是否存在15 const menus = userStore.menus16 if (!menus) &#123;17 reqList.push(userStore.getMenus)18 &#125;1920 if (reqList?.length) &#123;21 await Promise.all(reqList.map(fn =&gt; fn()))22 &#125;2324 next()25&#125; &nbsp;路由鉴权中间件 1import &#123; RouteLocationNormalized &#125; from 'vue-router'2import &#123; useUserStoreWithOut &#125; from '/@/store/modules/user'34export default (to: RouteLocationNormalized, _from: any, next: any) =&gt; &#123;5 const permissions = (to.meta?.permissions as string[]) || []67 // 配置权限校验8 if (permissions.length) &#123;9 const userStore = useUserStoreWithOut()10 const codes = userStore.pagePermissionCodes || []11 const hasPermission = codes.some(role =&gt; permissions.includes(role))1213 if (hasPermission) &#123;14 next()15 &#125; else &#123;16 next(&#123; path: '/404' &#125;)17 &#125;18 &#125; else &#123;19 // 无配置，直接放行20 next()21 &#125;22&#125; 经过中间件处理，如果用户能正常进入页面，那么进入页面时，cookie中必定存在token，paina中必定存在用户的基本信息。 数据请求数据请求即对axios封装，对axios赋能，其中不仅仅包含请求异常处理，还包含是否重复请求，配置获取数据等等。请求封装 1import Axios, &#123; AxiosInstance, AxiosRequestConfig &#125; from 'axios'2import &#123; HttpError, HttpResponse, HttpRequestConfig &#125; from './types.d'3import qs from 'qs'4import &#123; AxiosCanceler &#125; from './axiosCancel'5import &#123; checkStatus &#125; from './checkStatus'6import &#123; httpErrorStatusHandle &#125; from './httpError'7import &#123; getToken &#125; from '../token'89const env = import.meta.env10const axiosCanceler = new AxiosCanceler()1112const defaultConfig: AxiosRequestConfig = &#123;13 baseURL: env.VITE_GLOB_API_URL,14 timeout: 100000,15 headers: &#123;16 Accept: 'application/json, text/plain, */*',17 'Content-Type': 'application/json',18 'X-Requested-With': 'XMLHttpRequest'19 &#125;,20 // 数组格式参数序列化21 paramsSerializer: params =&gt; qs.stringify(params, &#123; indices: false &#125;)22&#125;2324class Http &#123;25 constructor() &#123;26 this.httpInterceptorsRequest()27 this.httpInterceptorsResponse()28 &#125;29 // 初始化配置对象30 private static initConfig: HttpRequestConfig = &#123;31 ignoreCancelToken: true, // 是否取消重复请求32 reductDataFormat: true, // 是否获取简洁响应数据33 errorMessageShow: true // 是否开启全局默认的异常提示34 &#125;3536 // 保存当前Axios实例对象37 private static axiosInstance: AxiosInstance = Axios.create(defaultConfig)3839 // 请求拦截40 private httpInterceptorsRequest(): void &#123;41 Http.axiosInstance.interceptors.request.use(42 (config: HttpRequestConfig) =&gt; &#123;43 const $config = config4445 // 添加token46 const token = getToken()47 token &amp;&amp; ($config.headers.token = token)4849 // 处理重复请求50 !$config.ignoreCancelToken &amp;&amp; axiosCanceler.addPending(config)5152 return $config53 &#125;,54 error =&gt; &#123;55 return Promise.reject(error)56 &#125;57 )58 &#125;5960 // 响应拦截61 private httpInterceptorsResponse(): void &#123;62 const instance = Http.axiosInstance63 instance.interceptors.response.use(64 (response: HttpResponse) =&gt; &#123;65 const $config = response.config6667 // 处理重复请求68 !$config.ignoreCancelToken &amp;&amp; axiosCanceler.removePending($config)6970 // 接口请求提示71 httpErrorStatusHandle($config.errorMessageShow, &#123; response &#125;)7273 // 校验登录过期74 checkStatus(response.data.code)7576 // 处理是否取简洁数据77 return $config.reductDataFormat ? response.data : response78 &#125;,79 (error: HttpError) =&gt; &#123;80 const $config = error.config8182 // 接口请求提示83 $config &amp;&amp; httpErrorStatusHandle($config.errorMessageShow, error)84 return Promise.reject(error)85 &#125;86 )87 &#125;8889 // 通用请求工具函数90 public request&lt;T = HttpResponse&gt;(91 config: AxiosRequestConfig,92 options?: HttpRequestConfig93 ): Promise&lt;T&gt; &#123;94 const conf = &#123; ...config, ...Http.initConfig, ...options &#125;95 // 单独处理自定义请求/响应回掉96 return Http.axiosInstance.request(conf)97 &#125;98&#125;99100export const http = new Http() &nbsp;处理重复请求 1import type &#123; AxiosRequestConfig, Canceler &#125; from 'axios'2import axios from 'axios'3import &#123; isFunction &#125; from '/@/utils/is'45let pendingMap = new Map&lt;string, Canceler&gt;()67export const getPendingUrl = (config: AxiosRequestConfig) =&gt; [config.method, config.url].join('&amp;')89export class AxiosCanceler &#123;10 addPending(config: AxiosRequestConfig) &#123;11 this.removePending(config)12 const url = getPendingUrl(config)13 config.cancelToken =14 config.cancelToken ||15 new axios.CancelToken(cancel =&gt; &#123;16 if (!pendingMap.has(url)) &#123;17 pendingMap.set(url, cancel)18 &#125;19 &#125;)20 &#125;2122 removeAllPending() &#123;23 pendingMap.forEach(cancel =&gt; &#123;24 cancel &amp;&amp; isFunction(cancel) &amp;&amp; cancel()25 &#125;)26 pendingMap.clear()27 &#125;2829 removePending(config: AxiosRequestConfig) &#123;30 const url = getPendingUrl(config)3132 if (pendingMap.has(url)) &#123;33 const cancel = pendingMap.get(url)34 cancel &amp;&amp; cancel(url)35 pendingMap.delete(url)36 &#125;37 &#125;3839 reset(): void &#123;40 pendingMap = new Map&lt;string, Canceler&gt;()41 &#125;42&#125; &nbsp;处理异常提示 1import &#123; messageInstance &#125; from '@fs/smart-design'2import axios from 'axios'3/**4 * 处理异常5 * @param &#123;*&#125; result6 */7export function httpErrorStatusHandle(isConfigShow, result) &#123;8 if (!isConfigShow) return910 // 服务端20011 if (result.response?.data?.code === 200) return1213 // 处理被取消的请求14 if (axios.isCancel(result))15 return console.log('请求的重复请求：' + result.message)1617 let message = ''18 if (result &amp;&amp; result.response) &#123;19 switch (result.response.status) &#123;20 case 200:21 message = result.response.data?.msg22 break23 case 302:24 message = '接口重定向了！'25 break26 case 400:27 message = '参数不正确！'28 break29 case 401:30 // 您未登录，或者登录已经超时，请先登录！31 message = ''32 break33 case 403:34 message = '您没有权限操作！'35 break36 case 404:37 message = `请求地址出错: $&#123;result.response.config.url&#125;`38 break // 在正确域名下39 case 408:40 message = '请求超时！'41 break42 case 409:43 message = '系统已存在相同数据！'44 break45 case 500:46 message = '服务器内部错误！'47 break48 case 501:49 message = '服务未实现！'50 break51 case 502:52 message = '网关错误！'53 break54 case 503:55 message = '服务不可用！'56 break57 case 504:58 message = '服务暂时无法访问，请稍后再试！'59 break60 case 505:61 message = 'HTTP版本不受支持！'62 break63 default:64 message = '异常问题，请联系管理员！'65 break66 &#125;67 &#125;68 if (result.message?.includes('timeout')) message = '网络请求超时！'69 if (result.message?.includes('Network')) message = window.navigator.onLine ? '服务端异常！' : '您断网了！'70 if (message) messageInstance.error(message)71&#125; &nbsp;处理异常登录 1import &#123; useUserStoreWithOut &#125; from '/@/store/modules/user'23export function checkStatus(code: number): void &#123;4 const userStore = useUserStoreWithOut()56 switch (code) &#123;7 case 401: // 未授权8 case 403: // 权限不足9 userStore.login()10 break11 default:12 &#125;13&#125;","categories":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}]},{"title":"husky+lint-staged+commitlint git提交配置","slug":"configuration/configuration11","date":"2023-03-22T16:00:00.000Z","updated":"2023-10-21T02:29:52.766Z","comments":true,"path":"2023/03/23/configuration/configuration11/","link":"","permalink":"http://yoursite.com/2023/03/23/configuration/configuration11/","excerpt":"","text":"使用 husky、lint-staged 对 git commit时进行代码修复检查使用 commitlint 对 git commit message 进行规范 husky husky 使用git提交代码的过程中会触发的钩子 安装 1pnpm add husky -D 在package.json中的script中添加一条脚本命令 1&quot;scripts&quot;: &#123;2 &quot;prepare&quot;: &quot;husky install&quot;3&#125; 执行 pnpm prepare 命令，根目录下生成 .husky目录 husky命令添加pre-commit 1pnpm husky add .husky&#x2F;pre-commit &quot;pnpm lint&quot; 执行命令后会在.husky目录下生成一个pre-commit文件 1#!&#x2F;usr&#x2F;bin&#x2F;env sh2. &quot;$(dirname -- &quot;$0&quot;)&#x2F;_&#x2F;husky.sh&quot;34pnpm lint git commit执行git commit时，就会 执行 pnpm lint。通过配置pnpm lint 命令对代码修复 和错误检查。 lint-staged 当我们执行 pnpm lint:eslint、pnpm lint:prettier、pnpm lint:style 这些命令时，会把项目中的文件都检查一遍。lint-staged 用于校验我们修改过的文件，而不是全部文件。 安装 1pnpm i lint-staged -D 在packages.json的scripts中添加命令 1&quot;scripts&quot;: &#123;2 &quot;lint-staged&quot;: &quot;lint-staged&quot;3&#125; 修改.husky/pre-commit下的npm命令 1npm run lint-staged 项目根目录下创建.lintstagedrc配置文件 1&#123;2 &quot;*.&#123;js,jsx,ts,tsx&#125;&quot;: [&quot;prettier --write&quot;, &quot;eslint --fix&quot;],3 &quot;&#123;!(package)*.json,.!(browserslist)*rc&#125;&quot;: [&quot;prettier --write--parser json&quot;],4 &quot;package.json&quot;: [&quot;prettier --write&quot;],5 &quot;*.vue&quot;: [&quot;prettier --write&quot;, &quot;stylelint --fix --aei&quot;, &quot;eslint --fix&quot;],6 &quot;*.&#123;vue,css,scss,postcss,less&#125;&quot;: [&quot;prettier --write&quot;, &quot;stylelint --fix --aei&quot;],7 &quot;*.md&quot;: [&quot;prettier --write&quot;]8&#125; 提交commit时，pre-commit钩子执行npm run lint-staged命令，lint-staged找到.lintstagedrc配置文件，对git暂存区的文件，根据文件类型，执行相应的命令。 commitlint 使用 commitlint 对 git commit message 进行规范 安装 1pnpm i @commitlint&#x2F;cli @commitlint&#x2F;config-conventional -D husky命令添加commit-msg 1npx husky add .husky&#x2F;commit-msg &quot;npx commitlint -e&quot; 根目录下创建 commitlint.config.js 文件 1module.exports &#x3D; &#123;2 ignores: [(commit) &#x3D;&gt; commit.includes(&#39;init&#39;)],3 extends: [&#39;@commitlint&#x2F;config-conventional&#39;],4 rules: &#123;5 &#39;body-leading-blank&#39;: [2, &#39;always&#39;],6 &#39;footer-leading-blank&#39;: [1, &#39;always&#39;],7 &#39;header-max-length&#39;: [2, &#39;always&#39;, 108],8 &#39;subject-empty&#39;: [2, &#39;never&#39;],9 &#39;type-empty&#39;: [2, &#39;never&#39;],10 &#39;type-enum&#39;: [11 2,12 &#39;always&#39;,13 [14 &#39;feat&#39;,15 &#39;fix&#39;,16 &#39;perf&#39;,17 &#39;style&#39;,18 &#39;docs&#39;,19 &#39;test&#39;,20 &#39;refactor&#39;,21 &#39;build&#39;,22 &#39;ci&#39;,23 &#39;chore&#39;,24 &#39;revert&#39;,25 &#39;wip&#39;,26 &#39;workflow&#39;,27 &#39;types&#39;,28 &#39;release&#39;29 ]30 ]31 &#125;32&#125;","categories":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}]},{"title":"eslint+prettier+stylelint项目风格配置","slug":"configuration/configuration10","date":"2023-03-22T16:00:00.000Z","updated":"2023-10-21T02:29:31.200Z","comments":true,"path":"2023/03/23/configuration/configuration10/","link":"","permalink":"http://yoursite.com/2023/03/23/configuration/configuration10/","excerpt":"","text":"eslint eslint是什么ESLint 是一个可配置的 JavaScript 检查器。它可以帮助你发现并修复 JavaScript 代码中的问题。问题可以指潜在的运行时漏洞、未使用最佳实践、风格问题等。通过定义一组规则来工作，这些规则描述了代码中的期望行为和约定。开发人员可以根据自己的需求配置这些规则，以便在编码过程中得到及时的反馈和建议。ESLint支持大量的规则，并且可以根据项目的特定需求进行定制。文档地址 eslint工作机制 代码解析：ESLint首先会将JavaScript代码解析成抽象语法树（Abstract Syntax Tree，AST）。AST是一种将代码转换为树状结构的表示形式，可以更方便地进行代码分析和操作。 规则匹配：一旦代码被解析成AST，ESLint会根据配置的规则集进行规则匹配。每个规则都描述了代码中的某种问题或期望行为。 规则执行：当规则与代码匹配时，ESLint会执行规则所定义的逻辑。这可能包括发出警告、错误或建议，或者对代码进行自动修复。 eslint使用及相关工具介绍 初始化 1pnpm i eslint -D 1npx eslint --init 通过可以看到eslint帮我们安装了一些包 eslint-plugin-vue：eslint-plugin-vue 是 eslint 的插件，用于提供针对 Vue.js 代码的特定规则和检查。它能够检查和规范 Vue 单文件组件中的 HTML 模板、JavaScript 和样式部分的代码。 @typescript-eslint/parser：@typescript-eslint/parser 是一个用于解析 TypeScript 代码的 ESLint 解析器。它可以将 TypeScript 代码转换为抽象语法树（AST），以便进行后续的静态代码分析和检查。 @typescript-eslint/eslint-plugin：@typescript-eslint/eslint-plugin 是一个为 TypeScript 代码提供规则和检查的 ESLint 插件。它扩展了 ESLint 的功能，使其能够处理 TypeScript 特有的语法和类型系统，并提供相关的规则来确保代码的正确性和一致性。 配置格式化规则 1&#x2F;&#x2F; .eslintrc.js2module.exports &#x3D; &#123;3 &quot;env&quot;: &#123;4 &quot;browser&quot;: true,5 &quot;es2021&quot;: true,6 &quot;node&quot;: true7 &#125;,8 &quot;extends&quot;: [9 &quot;eslint:recommended&quot;,10 &quot;plugin:@typescript-eslint&#x2F;recommended&quot;,11 &quot;plugin:vue&#x2F;vue3-essential&quot;12 ],13 &quot;parserOptions&quot;: &#123;14 &quot;ecmaVersion&quot;: &quot;latest&quot;,15 &quot;parser&quot;: &quot;@typescript-eslint&#x2F;parser&quot;,16 &quot;sourceType&quot;: &quot;module&quot;,17 &quot;ecmaFeatures&quot;: &#123;18 jsx: true, &#x2F;&#x2F; 启用 JSX 语法支持19 &#125;20 &#125;,21 &quot;plugins&quot;: [22 &quot;@typescript-eslint&quot;,23 &quot;vue&quot;24 ],25 &quot;rules&quot;: &#123;26 &#x2F;&#x2F; &quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;]27 &#125;28&#125; env 指定当前代码语法的环境。extends 集成其他eslint的配置。parserOptions 解析器的配置项。global 配置全局变量。plugins 扩展插件。rules 校验规则配置。 插件包名简写：配置extends时可以省略包名的 eslint-config-前缀。如 airbnb 会被解析为 eslint-config-airbnb。配置plugins时可以省略包名中的 eslint-plugin- 前缀。extends 属性值由以下内容组成：plugin:包名（可以省略其前缀，如 react 是 eslint-plugin-react 的缩写）/配置名称（如 recommended）…示例：plugin:@typescript-eslint/recommended rules配置：“off” 或 0：表示禁用规则。“warn” 或 1：表示将规则视为警告。“error” 或 2：表示将规则视为错误。另外，规则的值还可以是一个数组，其中第一个元素是错误级别，后面的元素是配置规则的选项。比如：semi: [‘error’, ‘always’] .eslintignore 1node_modules&#x2F;2dist&#x2F;3index.html 配置eslint脚本 1&quot;scripts&quot;: &#123;2 &quot;lint:eslint&quot;: &quot;eslint --fix --ext .js,.ts,.tsx,.vue .&#x2F;src&quot;3&#125; 命令行配置 prettier prettier是什么Prettier 是一个代码格式化工具，用于自动格式化代码，使代码保持一致的风格和布局。它支持多种编程语言，并且具有可配置的规则和选项，可以自动调整代码的缩进、空格、换行等。文档地址 prettier使用及相关工具介绍 1pnpm i prettier -D2pnpm i eslint-config-prettier -D3pnpm i eslint-plugin-prettier -D eslint-config-prettier：eslint-config-prettier 是一个 ESLint 配置规则，用于解决 ESLint 和 Prettier 之间的规则冲突。由于 ESLint 和 Prettier 可能存在一些相互冲突的规则，使用 eslint-config-prettier 可以禁用 ESLint 中与 Prettier 冲突的规则，以确保代码格式化的一致性。 eslint-plugin-prettier：eslint-plugin-prettier 是一个 ESLint 插件，用于将 Prettier 的格式化功能集成到 ESLint 中。它会在 ESLint 的规则检查过程中，对不符合 Prettier 格式化规则的代码进行标记和报告，并可以通过 –fix 选项自动修复一些格式化问题。eslint-plugin-prettier 可以与 eslint-config-prettier 一起使用，以确保代码格式化的一致性和准确性。&nbsp;.eslintrc.js扩展 1extends: [2 ...,3 &#39;prettier&#39;,4 &#39;plugin:prettier&#x2F;recommended&#39;5 ] prettier与eslint如何工作 配置文件格式化规则 1&#x2F;&#x2F; .prettierrc.js2module.exports &#x3D; &#123;3 &#x2F;&#x2F; 一行最多 100 字符4 printWidth: 100,5 &#x2F;&#x2F; 使用 2 个空格缩进6 tabWidth: 2,7 &#x2F;&#x2F; 不使用 tab 缩进，而使用空格8 useTabs: false,9 &#x2F;&#x2F; 行尾需要有分号10 semi: false,11 &#x2F;&#x2F; 使用单引号代替双引号12 singleQuote: true,13 &#x2F;&#x2F; 对象的 key 仅在必要时用引号14 quoteProps: &#39;as-needed&#39;,15 &#x2F;&#x2F; jsx 不使用单引号，而使用双引号16 jsxSingleQuote: false,17 &#x2F;&#x2F; 末尾不使用逗号18 trailingComma: &#39;none&#39;,19 &#x2F;&#x2F; 大括号内的首尾需要空格 &#123; foo: bar &#125;20 bracketSpacing: true,21 &#x2F;&#x2F; jsx 标签的反尖括号需要换行22 jsxBracketSameLine: false,23 &#x2F;&#x2F; 箭头函数，只有一个参数的时候，也需要括号24 arrowParens: &#39;always&#39;,25 &#x2F;&#x2F; 每个文件格式化的范围是文件的全部内容26 rangeStart: 0,27 rangeEnd: Infinity,28 &#x2F;&#x2F; 不需要写文件开头的 @prettier29 requirePragma: false,30 &#x2F;&#x2F; 不需要自动在文件开头插入 @prettier31 insertPragma: false,32 &#x2F;&#x2F; 使用默认的折行标准33 proseWrap: &#39;preserve&#39;,34 &#x2F;&#x2F; 根据显示样式决定 html 要不要折行35 htmlWhitespaceSensitivity: &#39;css&#39;,36 &#x2F;&#x2F; 换行符使用 lf37 endOfLine: &#39;auto&#39;,38&#125; 在线规则配置 .prettierignore 1&#x2F;dist&#x2F;*2.local3.output.js4&#x2F;node_modules&#x2F;** 配置prettier脚本 1&quot;scripts&quot;: &#123;2 &quot;lint:prettier&quot;: &quot;prettier --write \\&quot;src&#x2F;**&#x2F;*.&#123;js,json,ts,tsx,css,less,vue,html,md&#125;\\&quot;&quot;3&#125; 命令行文档 stylelint stylelint是什么Stylelint 是一个用于检查和规范 CSS（默认） 和预处理器（如 LESS 和 SCSS）代码的工具。它可以帮助开发者遵循一致的编码规范，并发现潜在的问题和错误。文档地址 stylelint使用及相关工具介绍 stylelint配置基础（对css文件中的样式进行校验） 1pnpm i stylelint -D2pnpm i stylelint-config-standard -D3pnpm i stylelint-config-prettier -D stylelint-config-standard：stylelint-config-standard 是一个 Stylelint 的标准配置规则集，适用于标准的 CSS 代码。它包含了一组常见的规范和推荐规则，帮助开发者维护一致的 CSS 代码风格和质量。 stylelint-config-prettier：stylelint-config-prettier 是一个 Stylelint 配置规则，用于禁用 Stylelint 中与 Prettier 冲突的规则。它可以确保 Stylelint 和 Prettier 之间的规则一致性，避免冲突和重复的检查。&nbsp;扩展less，对less文件校验 1pnpm i stylelint-less -D2pnpm i postcss-less -D3pnpm i stylelint-config-recommended-less -D stylelint-less：stylelint-less 是一个 Stylelint 的插件，用于提供针对 LESS 代码的特定规则和检查。它可以检查和规范 LESS 文件中的样式代码，帮助开发者维护一致的 LESS 代码风格和质量。 postcss-less：postcss-less用途是将PostCSS转换直接应用于LESS源。 stylelint-config-recommended-less：stylelint-config-recommended-less 是一个 Stylelint 的推荐配置规则集，适用于 LESS 预处理器。它包含了一组针对 LESS 代码的推荐规则，帮助开发者规范化 LESS 代码的书写风格。&nbsp;扩展html|vue文件校验 1pnpm i postcss-html -D2pnpm i stylelint-config-standard-vue -D postcss-html：postcss-html 是一个 PostCSS 插件，用于解析 HTML 中的样式块（内联样式）。它可以解析 HTML 文件中 &lt;style&gt; 标签内的样式，并将其转换为 CSS 代码，以便进行后续的样式处理和分析。 stylelint-config-standard-vue：stylelint-config-standard-vue 是一个 Stylelint 的标准配置规则集，专门针对 Vue 单文件组件中的样式部分。它在 stylelint-config-standard 的基础上增加了一些针对 Vue 组件样式的规则，以确保 Vue 组件的样式一致性和质量。&nbsp;顺序插件 1pnpm i stylelint-order -D stylelint-order：stylelint-order 是一个 Stylelint 的插件，用于定义和检查 CSS 属性的顺序。它可以帮助开发者规范 CSS 属性的排列顺序，以提高代码的可读性和维护性 .stylelintrc.js 1module.exports &#x3D; &#123;2 &#x2F;&#x2F; 可以扩展现有配置（无论是自己的配置还是第三方配置3 extends: [4 &#39;stylelint-config-standard&#39;,5 &#39;stylelint-config-prettier&#39;,6 &#39;stylelint-config-recommended-less&#39;,7 &#39;stylelint-config-standard-vue&#39;8 ],9 &#x2F;&#x2F; 插件是社区构建的规则或规则集，支持方法，工具集，非标准 CSS功能或非常特定的用例10 plugins: [&#39;stylelint-order&#39;],11 overrides: [12 &#123;13 files: [&#39;**&#x2F;*.less&#39;],14 customSyntax: &#39;postcss-less&#39;15 &#125;,16 &#123;17 files: [&#39;**&#x2F;*.(html|vue)&#39;],18 customSyntax: &#39;postcss-html&#39;19 &#125;20 ],21 &#x2F;&#x2F; 忽略特定文件，node_modules 是默认情况下忽略的目录22 ignoreFiles: [&#39;**&#x2F;*.js&#39;, &#39;**&#x2F;*.jsx&#39;, &#39;**&#x2F;*.tsx&#39;, &#39;**&#x2F;*.ts&#39;, &#39;**&#x2F;*.json&#39;, &#39;**&#x2F;*.md&#39;, &#39;**&#x2F;*.yaml&#39;],23 &#x2F;&#x2F; 默认情况下未打开任何规则，也没有默认值。必须明确配置每个规则才能将其打开24 rules: &#123;25 indentation: 2,26 &#39;number-leading-zero&#39;: &#39;always&#39;,27 &#39;no-descending-specificity&#39;: null,28 &#39;function-url-quotes&#39;: &#39;always&#39;,29 &#39;string-quotes&#39;: &#39;single&#39;,30 &#39;unit-case&#39;: null,31 &#39;color-hex-case&#39;: &#39;lower&#39;,32 &#39;color-hex-length&#39;: &#39;long&#39;,33 &#39;rule-empty-line-before&#39;: &#39;never&#39;,34 &#39;font-family-no-missing-generic-family-keyword&#39;: null,35 &#39;selector-type-no-unknown&#39;: null,36 &#39;block-opening-brace-space-before&#39;: &#39;always&#39;,37 &#39;at-rule-no-unknown&#39;: null,38 &#39;no-duplicate-selectors&#39;: null,39 &#39;property-no-unknown&#39;: null,40 &#39;no-empty-source&#39;: null,41 &#39;selector-class-pattern&#39;: null,42 &#39;keyframes-name-pattern&#39;: null,43 &#39;selector-pseudo-class-no-unknown&#39;: [true, &#123; ignorePseudoClasses: [&#39;global&#39;, &#39;deep&#39;] &#125;],44 &#39;no-descending-specificity&#39;: null,45 &#39;selector-pseudo-element-no-unknown&#39;: [46 true,47 &#123;48 ignorePseudoElements: [&#39;v-deep&#39;]49 &#125;50 ],51 &#39;selector-pseudo-class-no-unknown&#39;: [52 true,53 &#123;54 ignorePseudoClasses: [&#39;deep&#39;]55 &#125;56 ],57 &#x2F;&#x2F; 指定声明块内属性的字母顺序58 &#39;order&#x2F;properties-order&#39;: [59 &#39;position&#39;,60 &#39;top&#39;,61 &#39;left&#39;,62 &#39;right&#39;,63 &#39;bottom&#39;,64 &#x2F;&#x2F; ...65 ]66 &#125;67&#125; extends 扩展stylelint的规则配置。plugins 指定要在 Stylelint 中使用的插件,支持方法，工具集，非标准 CSS功能或非常特定的用例。overrides 规则覆盖主要用户配置 Stylelint 在不同文件或文件类型上应用不同的规则集或配置。ignoreFiles 忽略特定文件，node_modules 是默认情况下忽略的目录。rules 配置stylelint的规则。 rules配置：规则配置可以是一个简单的布尔值，表示启用或禁用规则，也可以是一个数组，其中包含额外的配置选项。规则配置也可以是对象的规则项，具体配置参照官网。https://stylelint.bootcss.com/user-guide/rules.html 配置stylelint脚本 1&quot;scripts&quot;: &#123;2 &quot;lint:style&quot;: &quot;stylelint \\&quot;.&#x2F;**&#x2F;*.&#123;css,less,vue,html&#125;\\&quot; --fix --aei&quot;3&#125; 命令行文档","categories":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}]},{"title":"http缓存","slug":"server/server09","date":"2023-01-22T16:00:00.000Z","updated":"2023-10-20T06:22:26.846Z","comments":true,"path":"2023/01/23/server/server09/","link":"","permalink":"http://yoursite.com/2023/01/23/server/server09/","excerpt":"","text":"http缓存可细分为强制缓存与协商缓存，二者最大区别在于缓存命中时，浏览器是否需要向服务器发送请求，进而判断需要响应的内容是否需要从新请求。 整体概述 简略流程 http报文相关字段 Pragma 该字段只有一个no-cache可选，会通知浏览器不使用缓存，要求向服务器发送请求校验新鲜度。它的优先级较高，当存在时一定不会名字强缓存。 Cache-Control 字段 说明 private 表明响应只能被客户端缓存，不能作为共享缓存（即代理服务器不能缓存它） public 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存 no-cache 表示缓存前必需确认其有效性 no-store 表示不缓存请求或响应的任何内容 max-age=[s] 响应的最大值 强制缓存如果浏览器所请求的目标资源命中，则可直接从强制缓存中返回请求响应，无须与服务器进行任何通讯。 Expiresexpires缓存失效日期。由服务器端指定后通过响应头告知浏览器，浏览器在接收到带有该字段的响应体后进行缓存。若之后浏览器再次对该资源发起请求，就会对比expires与本地当前的时间戳。如果当前时间戳小于expires，缓存未过期，直接使用缓存。如果当前时间戳大于expires，缓存已过期，需要向服务器从新请求资源。1const server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;2 const &#123; pathname &#125; &#x3D; url.parse(req.url)3 switch (pathname) &#123;4 case &#39;&#x2F;img&#x2F;01.png&#39;:5 const img01ReadStream &#x3D; fs.createReadStream(path.resolve(__dirname, &#39;.&#x2F;assets&#x2F;img&#x2F;01.png&#39;))6 res.writeHead(200,7 &#123;8 &#39;Content-Type&#39;: &#39;image&#x2F;png&#39;,9 &#39;Expires&#39;: new Date(&#39;2023-03-05 13:33:00&#39;).toUTCString()10 &#125;11 )12 img01ReadStream.pipe(res)13 break;14 &#125;15&#125;) 可以看出`expires`对客户端时间戳过分依赖，如果客户端与服务端时间不同步，或者客户端主动修改时间，就达不到预期缓存效果。 Cache-Control: max-age=[s]max-age属性值用来设置响应资源的有效日期，以秒为单位。max-age=10就表示10秒内缓存有效，超过5秒后缓存过期。1const server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;2 const &#123; pathname &#125; &#x3D; url.parse(req.url)3 switch (pathname) &#123;4 case &#39;&#x2F;img&#x2F;02.png&#39;:5 const img02ReadStream &#x3D; fs.createReadStream(path.resolve(__dirname, &#39;.&#x2F;assets&#x2F;img&#x2F;02.png&#39;))6 res.writeHead(200,7 &#123;8 &#39;Content-Type&#39;: &#39;image&#x2F;png&#39;,9 &#39;Cache-Control&#39;: &#39;max-age&#x3D;10&#39;10 &#125;11 )12 img02ReadStream.pipe(res)13 break;14 &#125;15&#125;) 协商缓存在使用本地缓存之前，需要向服务器发起一次get请求，与之协商当前浏览器保存的本地缓存是否已过期。 Last-Modified/If-Modified-Since当第一次请求资源时，服务器会在响应头部添加Last-Modified字段，标识服务器认定的资源作出修改的日期及时间。当再次请求资源时，浏览器会在请求头自动添加If-Modified-Since字段并请求资源，当服务器检查Last-Modified的时间早于或等于If-Modified-Since则会返回一个不带主体的304响应，否则将重新返回资源。1const server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;2 const &#123; pathname &#125; &#x3D; url.parse(req.url)3 switch (pathname) &#123;4 case &#39;&#x2F;img&#x2F;03.png&#39;:5 const &#123; mtime &#125; &#x3D; fs.statSync(path.resolve(__dirname, &#39;.&#x2F;assets&#x2F;img&#x2F;03.png&#39;))6 const ifModifiedSince &#x3D; req.headers[&#39;if-modified-since&#39;]7 if(ifModifiedSince &#x3D;&#x3D;&#x3D; mtime.toUTCString())&#123;8 res.statusCode &#x3D; 3049 res.end()10 return11 &#125;12 const img03ReadStream &#x3D; fs.createReadStream(path.resolve(__dirname, &#39;.&#x2F;assets&#x2F;img&#x2F;03.png&#39;))13 res.writeHead(200,14 &#123;15 &#39;Content-Type&#39;: &#39;image&#x2F;png&#39;,16 &#39;Cache-Control&#39;: &#39;no-cache&#39;,17 &#39;Last-Modified&#39;: mtime.toUTCString()18 &#125;19 )20 img03ReadStream.pipe(res)21 break;22 &#125;23&#125;) ETag/If-None-MatchETag是为了弥补时间戳缓存的不足，其内容主要是服务器为不同资源进行哈希运算生成的一个字符串，改字符串类似文件指纹，只要文件内容编码存在差异对应ETag标签值就会不同，因此使用ETag可以对文件资源进行更精确的变化感知。当第一次请求资源时，服务器会在响应头部添加ETag字段，标识服务器认定的资源的哈希值。当再次请求资源时，浏览器会在请求头自动添加If-None-Match字段并请求资源，当服务器检查ETag不等于If-None-Match则会返回一个不带主体的304响应，否则将重新返回资源。1const server = http.createServer((req, res) =&gt; &#123;2 const &#123; pathname &#125; = url.parse(req.url)3 switch (pathname) &#123;4 case '/img/04.png':5 const img04File = fs.readFileSync(path.resolve(__dirname, './assets/img/04.png'))6 const etagContent = etag(img04File)7 const ifNoneMatch = req.headers['if-none-match']8 if(etagContent === ifNoneMatch)&#123;9 res.statusCode = 30410 res.end()11 return12 &#125;13 res.writeHead(200,14 &#123;15 'Content-Type': 'image/png',16 'Cache-Control': 'no-cache',17 'ETag':etagContent18 &#125;19 )20 res.end(img04File)21 break;22 &#125;23&#125;)","categories":[{"name":"server","slug":"server","permalink":"http://yoursite.com/categories/server/"}],"tags":[{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"Typescript常用工具","slug":"typescript/typescript09","date":"2022-11-04T16:00:00.000Z","updated":"2023-10-20T06:19:18.560Z","comments":true,"path":"2022/11/05/typescript/typescript09/","link":"","permalink":"http://yoursite.com/2022/11/05/typescript/typescript09/","excerpt":"","text":"Exclude 移除联合类型中的指定类型 1type TestType &#x3D; Exclude&lt;&#39;name&#39;|&#39;age&#39;|&#39;sex&#39;,&#39;sex&#39;&gt; Extract 挑选联合类型中的指定类型（交集） 1type TestType &#x3D; Extract&lt;&#39;name&#39;|&#39;age&#39;|&#39;sex&#39;,&#39;sex&#39;&gt; Omit 移除对象类型中的指定类型 1interface User &#123;2 name: string3 age: number,4 sex: &#39;male&#39;|&#39;female&#39;5&#125;6type TestType &#x3D; Omit&lt;User,&#39;name&#39;|&#39;sex&#39;&gt; Pick 挑选对象类型中的指定类型 1interface User &#123;2 name: string3 age: number,4 sex: &#39;male&#39;|&#39;female&#39;5&#125;6type TestType &#x3D; Pick&lt;User,&#39;name&#39;|&#39;sex&#39;&gt; Record 定义一个对象类型第一个参数为联合类型，循环联合类型作为对象的键。第二个参数为每个键的数据类型。 1type TestType &#x3D; Record&lt;&#39;a&#39;|&#39;b&#39;|&#39;c&#39;,string&gt; Partial 将对象中的键变为可选对象只会将对象的第一层有效果 1interface User &#123;2 name: string3 hobby: &#123;4 run: boolean5 &#125;6&#125;7type TestType &#x3D; Partial&lt;User&gt; Required 将对象中的可选项，变为必填项只会将对象的第一层有效果 1interface User &#123;2 name?: string3 hobby: &#123;4 run?: boolean5 &#125;6&#125;7type TestType &#x3D; Required&lt;User&gt;","categories":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"Vite Vue3 TS Pinia 项目搭建","slug":"configuration/configuration09","date":"2022-10-29T16:00:00.000Z","updated":"2023-10-21T02:29:06.037Z","comments":true,"path":"2022/10/30/configuration/configuration09/","link":"","permalink":"http://yoursite.com/2022/10/30/configuration/configuration09/","excerpt":"","text":"基本工程创建 使用vite-cli生成一个模板工程1&#x2F;&#x2F; 手动配置生成模板2pnpm create vite34&#x2F;&#x2F; 快速生成模板5pnpm create vite project-name --template vue-ts 生成模板工程 项目环境配置 配置env文件修改package.json运行配置 1 &quot;scripts&quot;: &#123;2 &quot;dev&quot;: &quot;vite --mode dev&quot;,3 &quot;dev:test&quot;: &quot;vite --mode test&quot;,4 &quot;build&quot;: &quot;vue-tsc &amp;&amp; vite build --mode prod&quot;5&#125;, –mode指定对应配置文件例如：–mode dev 对应 .env.dev 配置文件 获取环境配置Vite中通过 import.meta.env 获取环境变量Vite 环境变量和模式 如果业务环境配置比较复杂，可以通过js手段进行扩展 配置环境扩展src下创建 config文件 根据环境引入不同配置 1import &#123; IConfig &#125; from &#39;.&#x2F;types&#39;;2&#x2F;&#x2F; 根据环境引入不同配置3import commonConfig from &#39;.&#x2F;env&#39;;4import devConfig from &#39;.&#x2F;env.dev&#39;;5import prodConfig from &#39;.&#x2F;env.prod&#39;;6import testConfig from &#39;.&#x2F;env.test&#39;;789const ENV &#x3D; import.meta.env.VITE_APP_ENV1011let config: IConfig &#x3D; &#123;&#125; as any12switch(ENV) &#123;13 case &#39;dev&#39;:14 config &#x3D; Object.assign(commonConfig, devConfig)15 break;16 case &#39;prod&#39;:17 config &#x3D; Object.assign(commonConfig, prodConfig)18 break;1920 case &#39;test&#39;:21 config &#x3D; Object.assign(commonConfig, testConfig)22 break;2324 default:25 break;26&#125;27export default config 基本构建配置 构建配置文档https://cn.vitejs.dev/config/shared-options.html1import path from &#39;path&#39;2import &#123; defineConfig, loadEnv &#125; from &#39;vite&#39;3import &#123; createVitePlugins &#125; from &#39;.&#x2F;build&#x2F;vitePlugins&#x2F;index&#39;45export default defineConfig((&#123; command, mode &#125;) &#x3D;&gt; &#123;6 const dotEnv &#x3D; loadEnv(mode, process.cwd())78 return &#123;9 base: &#39;&#x2F;&#39;,10 resolve: &#123;11 alias: &#123;12 &#39;@&#39;: path.resolve(__dirname, &#39;src&#39;)13 &#125;14 &#125;,15 server: &#123;16 https: false,17 port: 5173,18 host: &#39;0.0.0.0&#39;,19 proxy: &#123;20 &#39;&#x2F;api&#39;: &#123;21 target: dotEnv.VITE_PROXY_API_URL,22 changeOrigin: true,23 rewrite: (path) &#x3D;&gt; path.replace(&#x2F;^\\&#x2F;api&#x2F;, &#39;&#39;),24 &#125;,25 &#125;,26 &#125;,27 build: &#123;28 rollupOptions: &#123;29 output: &#123;30 chunkFileNames: &#39;assets&#x2F;js&#x2F;[name]-[hash].js&#39;,31 entryFileNames: &#39;assets&#x2F;js&#x2F;[name]-[hash].js&#39;,32 assetFileNames: &#39;assets&#x2F;[ext]&#x2F;[name]-[hash].[ext]&#39;33 &#125;34 &#125;35 &#125;,3637 plugins: createVitePlugins(command),38 &#125;39&#125;) 集成插件Unocss https://uno.antfu.me/ 通过css属性值查看其属性https://github.com/unocss/unocss#configurations 安装1pnpm i unocss -D 根目录下创建unocss.config.ts1&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;unocss&#x2F;unocss#readme2import &#123; defineConfig, presetUno, presetAttributify, transformerVariantGroup &#125; from &#39;unocss&#39;3export default defineConfig(&#123;4 presets: [presetUno(), presetAttributify()],5 transformers: [transformerVariantGroup()],6 exclude: [&#96;$&#123;__dirname&#125;&#x2F;node_modules&#x2F;**&#x2F;*&#96;],7 shortcuts: &#123;8 &#39;wh-full&#39;: &#39;w-full h-full&#39;,9 &#39;cp-on&#39;: &#39;cursor-pointer outline-none&#39;,10 &#39;flex-c&#39;: &#39;flex justify-center items-center&#39;,11 &#39;flex-ac&#39;: &#39;flex justify-around items-center&#39;,12 &#39;flex-bc&#39;: &#39;flex justify-between items-center&#39;13 &#125;14&#125;) main.ts 中引入uno.css1import &#39;uno.css&#39; vite.config.ts 中配置 plugins1import Unocss from &#39;unocss&#x2F;vite&#39;2...3plugins: [4 Unocss()5]6... I18n 安装1pnpm i vue-i18n -S 1&#x2F;&#x2F; 实现语言包懒加载2pnpm i @intlify&#x2F;unplugin-vue-i18n -D vite.config.ts plugins 中配置1import &#123; resolve &#125; from &#39;path&#39;2import VueI18nPlugin from &#39;@intlify&#x2F;unplugin-vue-i18n&#x2F;vite&#39;34export const configI18n &#x3D; () &#x3D;&gt; &#123;5 return VueI18nPlugin(&#123;6 runtimeOnly: true,7 compositionOnly: true,8 include: [resolve(&#39;src&#x2F;i18n&#x2F;**&#39;)]9 &#125;)10&#125; main.ts 中引入i18n1import type &#123; App &#125; from &#39;vue&#39;2import &#123; createI18n &#125; from &#39;vue-i18n&#39;3import messages from &#39;@intlify&#x2F;unplugin-vue-i18n&#x2F;messages&#39;45type LangType &#x3D; &#39;zh&#39; | &#39;en&#39;67const locale: LangType &#x3D; (localStorage.getItem(&#39;lang&#39;) as LangType) ?? &#39;zh&#39;8export const i18n &#x3D; createI18n(&#123;9 locale: locale,10 legacy: false,11 messages: messages12&#125;)1314&#x2F;*15* 文件在js或者ts中使用16* 存在两个问题17* 1. 语言包不会跟随 i18n.global.locale.value 的值变化，使页面中展示语言立即响应切换18* 2. 当语言包文件名重复时，重复的文件获取不到19*&#x2F;20export const useI18nWithOut &#x3D; (fileName) &#x3D;&gt; &#123;21 const local &#x3D; i18n.global.locale22 const localeMessage &#x3D; i18n.global.getLocaleMessage(fileName)23 return (key) &#x3D;&gt; &#123;24 return localeMessage?.[local.value]?.[key]?.source || key25 &#125;26&#125;2728export const setLocaleLang &#x3D; (lang: LangType) &#x3D;&gt; &#123;29 i18n.global.locale.value &#x3D; lang30 localStorage.setItem(&#39;lang&#39;, lang)31 setHtmlLangAttr(lang)32&#125;3334export const setHtmlLangAttr &#x3D; (lang: LangType) &#x3D;&gt; &#123;35 let value: string &#x3D; lang36 if (lang &#x3D;&#x3D; &#39;zh&#39;) value &#x3D; &#39;zh-CN&#39;37 document.documentElement.setAttribute(&#39;lang&#39;, value)38&#125;3940export function setupI18n(app: App) &#123;41 app.use(i18n)42 setHtmlLangAttr(locale)43&#125; 1...2&#x2F;&#x2F; main.ts3setupI18n(app) vue、pinia、vue-router…依赖自动引入 安装 1pnpm i unplugin-auto-import -D vite.config.ts 中添加插件配置 1import AutoImport from &#39;unplugin-auto-import&#x2F;vite&#39;2export const configAutoImportDeps &#x3D; () &#x3D;&gt; &#123;3 return AutoImport(&#123;4 dts: &#39;types&#x2F;auto-imports.d.ts&#39;,5 imports: [&#39;vue&#39;, &#39;pinia&#39;, &#39;vue-router&#39;]6 &#125;)7&#125; tsconfig.json 1&quot;include&quot;: [&quot;types&#x2F;*.d.ts&quot;], antd组件按需引入 安装 1pnpm i unplugin-vue-components -D 1pnpm i ant-design-vue -S vite.config.ts 中添加插件配置 1import Components from &#39;unplugin-vue-components&#x2F;vite&#39;2import &#123; AntDesignVueResolver &#125; from &#39;unplugin-vue-components&#x2F;resolvers&#39;34export const configAutoRegistryComponents &#x3D; () &#x3D;&gt; &#123;5 return Components(&#123;6 dirs: [],7 dts: &#39;types&#x2F;components.d.ts&#39;,8 resolvers: [9 AntDesignVueResolver(&#123;10 importStyle: &#39;less&#39; &#x2F;&#x2F; 如果要修改ant-design主题，一定要开启这个配置项11 &#125;)12 ]13 &#125;)14&#125; vite.config.ts 中修改css配置 1css: &#123;2 preprocessorOptions: &#123;3 less: &#123;4 &#x2F;&#x2F; 注意，这一句是在less对象中，写在外边不起作用5 javascriptEnabled: true,6 &#x2F;&#x2F; 在这里进行ant-design主题的修改，参考官方配置属性7 modifyVars: &#123;8 &#39;primary-color&#39;: &#39;#1890FF&#39;9 &#125;10 &#125;11 &#125;12&#125; main.ts 1&#x2F;&#x2F; 无需注册，只引入实例类型触发的组件对应样式即可2import &#39;ant-design-vue&#x2F;es&#x2F;message&#x2F;style&#x2F;index&#39; pnpm补充当使用pnpm安装时会发现组件使用的地方的类型是any。这是因为在自动生成的 components.d.ts 文件中的 declare module ‘@vue/runtime-core’ 声明，在 pnpm 中只能访问项目的顶级依赖，而 @vue/runtime-core 是 vue 模块下的依赖，不是顶级依赖，导致声明语句失效。（yarn 和 npm 的 node_modules 平铺目录结构允许访问所有依赖） 1&#x2F;&#x2F; generated by unplugin-vue-components2&#x2F;&#x2F; We suggest you to commit this file into source control3&#x2F;&#x2F; Read more: https:&#x2F;&#x2F;github.com&#x2F;vuejs&#x2F;core&#x2F;pull&#x2F;33994import &#39;@vue&#x2F;runtime-core&#39;56export &#123;&#125;78declare module &#39;@vue&#x2F;runtime-core&#39; &#123;9 export interface GlobalComponents &#123;10 AButton: typeof import(&#39;ant-design-vue&#x2F;es&#39;)[&#39;Button&#39;]11 AConfigProvider: typeof import(&#39;ant-design-vue&#x2F;es&#39;)[&#39;ConfigProvider&#39;]12 AModal: typeof import(&#39;ant-design-vue&#x2F;es&#39;)[&#39;Modal&#39;]13 RouterLink: typeof import(&#39;vue-router&#39;)[&#39;RouterLink&#39;]14 RouterView: typeof import(&#39;vue-router&#39;)[&#39;RouterView&#39;]15 &#125;16&#125; 在这时可以通过目录的根目录中创建或编辑.npmrc文件，并在其中添加以下行：public-hoist-pattern[]=@vue/runtime-core，然后执行pnpm i 对@vue/runtime-core依赖提升，最后重启vscode配置生效。 vue-router 安装 1pnpm i vue-router -S main.ts注册创建router实例 1import &#123; createRouter, createWebHistory &#125; from &#39;vue-router&#39;2const router &#x3D; createRouter(&#123;3 history: createWebHistory(),4 routes,5 scrollBehavior: () &#x3D;&gt; (&#123; left: 0, top: 0 &#125;)6&#125;)7export default router main.ts主注册 1import router from &#39;.&#x2F;router&#x2F;index&#39;2...3app.use(router) 动态引入当项目非常庞大的时候routes会这个文件会非常庞大，多人协作时，也会引起冲突。为了解决这个问题，可以使用vite中import.meta.glob这个api，将路由文件模块化。同时又满足多个layout的功能。 1import &#123; RouteRecordRaw &#125; from &#39;vue-router&#39;23const baseRouter: RouteRecordRaw[] &#x3D; [4 &#123;5 path: &#39;&#x2F;&#39;,6 component: () &#x3D;&gt; import(&#39;..&#x2F;layout&#x2F;HomeLayout.vue&#39;),7 redirect: &#39;&#x2F;home&#39;,8 meta: &#123;9 layout: &#39;HomeLayout&#39;10 &#125;,11 children: []12 &#125;,13 &#123;14 path: &#39;&#x2F;&#39;,15 component: () &#x3D;&gt; import(&#39;..&#x2F;layout&#x2F;TestLayout.vue&#39;),16 meta: &#123;17 layout: &#39;TestLayout&#39;18 &#125;,19 children: []20 &#125;,21 &#123;22 path: &#39;&#x2F;login&#39;,23 name: &#39;login&#39;,24 component: () &#x3D;&gt; import(&#39;&#x2F;@&#x2F;views&#x2F;login&#x2F;index.vue&#39;),25 meta: &#123;26 title: &#39;登录&#39;27 &#125;28 &#125;,29 &#123;30 path: &#39;&#x2F;:w+&#39;,31 name: &#39;404&#39;,32 component: () &#x3D;&gt; import(&#39;&#x2F;@&#x2F;views&#x2F;error&#x2F;404.vue&#39;)33 &#125;34]35export const LayoutTypes &#x3D; baseRouter.map((route) &#x3D;&gt; route?.meta?.layout).filter((item) &#x3D;&gt; item)36export default baseRouter 1import baseRouter, &#123; LayoutTypes &#125; from &#39;.&#x2F;base&#39;23const modules &#x3D; import.meta.glob(&#39;.&#x2F;views&#x2F;**&#x2F;*.ts&#39;, &#123;4 eager: true,5 import: &#39;default&#39;6&#125;)78const getRoutes &#x3D; (modules, baseRouter) &#x3D;&gt; &#123;9 const modulesRoutes: ModulesRoutesType &#x3D; &#123;10 otherRouter: []11 &#125;12 &#x2F;&#x2F; 加入到路由集合中13 Object.keys(modules).forEach((key) &#x3D;&gt; &#123;14 const mod &#x3D; modules[key] || &#123;&#125;15 const modList &#x3D; Array.isArray(mod) ? [...mod] : [mod]16 for (let i &#x3D; 0; i &lt; modList.length; i++) &#123;17 const route &#x3D; modList[i]18 const layout &#x3D; route?.meta?.layout19 if (LayoutTypes.includes(layout)) &#123;20 if (!modulesRoutes[layout]) &#123;21 modulesRoutes[layout] &#x3D; []22 &#125;23 modulesRoutes[layout].push(route)24 &#125; else if (!layout) &#123;25 modulesRoutes[&#39;otherRouter&#39;].push(route)26 &#125;27 &#125;28 &#125;)2930 &#x2F;&#x2F; 对应layout添加路由31 for (let i &#x3D; 0; i &lt; baseRouter.length; i++) &#123;32 const baseRoute &#x3D; baseRouter[i]33 const layout &#x3D; baseRoute?.meta?.layout as string34 if (layout &amp;&amp; modulesRoutes[layout] &amp;&amp; LayoutTypes.includes(layout)) &#123;35 baseRoute.children.push(...modulesRoutes[layout])36 &#125;37 &#125;3839 return [...modulesRoutes[&#39;otherRouter&#39;], ...baseRouter]40&#125;4142const routes &#x3D; getRoutes(modules, baseRouter) 路由鉴权对路由权限进行管理，一般我们进入页面时要对用户是否登录、是否存在路由权限等 进行校验。由于这些操作存在先后时机问题，比如登录完成之后才能获取到用户信息，用户信息拿到后才能权限校验，如果将这些逻辑都写入beforeEach中代码将会不好管理。这里引入中间件概念进行管理。1import callMiddleware from &#39;.&#x2F;auths&#39;2...3const beforeEach: MiddlewareFn &#x3D; (to, from, next) &#x3D;&gt; &#123;4 callMiddleware(to, from, (...args: any[]) &#x3D;&gt; &#123;5 next(...args)6 &#125;)7&#125;8router.beforeEach(beforeEach) 1&#x2F;&#x2F; auths.ts2import routeAuthMiddleware from &#39;.&#x2F;routeAuthMiddleware&#39;3import &#123; MiddlewareFn &#125; from &#39;..&#x2F;types&#39;45const middlewares &#x3D; [routeAuthMiddleware]6const callMiddleware: MiddlewareFn &#x3D; (to, from, next) &#x3D;&gt; &#123;7 const stack &#x3D; [...middlewares]8 const _next &#x3D; (...args: any[]) &#x3D;&gt; &#123;9 if (args.length &gt; 0 || stack.length &#x3D;&#x3D;&#x3D; 0) &#123;10 return next(...args)11 &#125;12 const middleware &#x3D; stack.shift() as MiddlewareFn13 middleware(to, from, _next)14 &#125;15 _next()16&#125;1718export default callMiddleware 1import &#123; RouteLocationNormalized &#125; from &#39;vue-router&#39;2export default async (to: RouteLocationNormalized, _from, next: any) &#x3D;&gt; &#123;3 if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;home&#39;) &#123;4 return next(&#123; path: &#39;&#x2F;404&#39; &#125;)5 &#125;6 next()7&#125; Pinia 安装 1pnpm i pinia -S main.ts 文件中注册 1import type &#123; App &#125; from &#39;vue&#39;2import &#123; createPinia &#125; from &#39;pinia&#39;3const store &#x3D; createPinia()45export function setupStore(app: App&lt;Element&gt;) &#123;6 app.use(store)7&#125;89export &#123; store &#125; main.ts 1setupStore(app) 创建store 1import &#123; defineStore &#125; from &#39;pinia&#39;2import &#123; store &#125; from &#39;&#x2F;@&#x2F;store&#39;34export const useUserStore &#x3D; defineStore(&#123;5 id: &#39;app-user&#39;,6 state: () &#x3D;&gt; (&#123;7 userInfo: &#123;&#125;,8 menus: []9 &#125;),1011 getters: &#123;12 getUserInfo() &#123;13 return this.userInfo14 &#125;,15 getToken(): string &#123;16 return this.userInfo?.token17 &#125;18 &#125;,1920 actions: &#123;21 setUserInfo(data) &#123;22 this.userInfo &#x3D; data23 &#125;,24 async getUserInfoAction() &#123;25 setTimeout(() &#x3D;&gt; &#123;26 this.setUserInfo(&#123; token: &#39;hello world&#39; &#125;)27 &#125;, 2000)28 &#125;29 &#125;30&#125;)3132export const useUserStoreWithOut &#x3D; () &#x3D;&gt; useUserStore(store) setup 中使用useUserStore，ts 中使用useUserStoreWithOut","categories":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}]},{"title":"Typescript 操作符","slug":"typescript/typescript08","date":"2022-10-29T16:00:00.000Z","updated":"2023-10-20T04:27:52.852Z","comments":true,"path":"2022/10/30/typescript/typescript08/","link":"","permalink":"http://yoursite.com/2022/10/30/typescript/typescript08/","excerpt":"","text":"extends extends接口继承 1interface A &#123;2 name: string3&#125;4interface B extends A &#123;5 age: number6&#125; 相当于 1interface B &#123;2 name: string3 age: number4&#125; extends类型约束 1type A&lt;T extends string | number&gt; &#x3D; T2const a:A&lt;boolean&gt; &#x3D; true extends条件判断 1type A&lt;T&gt; &#x3D; T extends string ? true : false2const a: A&lt;string&gt; &#x3D; true typeof typeof对静态的js变量推到为ts类型1const test &#x3D; &#123;2 name: &#39;xiou&#39;,3 hobby: &#123;4 run: () &#x3D;&gt; &#123;&#125;5 &#125;,6 info: &#123;7 age: 18,8 male: true9 &#125;10&#125;11type TestType &#x3D; typeof test keyof 将对象类型的接口中所有的键取出，并返回一个联合声明类型。 提取对象接口的键 1const test &#x3D; &#123;2 name: &#39;xiou&#39;,3 hobby: &#123;4 run: () &#x3D;&gt; &#123;&#125;5 &#125;6&#125;7type TestType &#x3D; typeof test8type TestTypeKey &#x3D; keyof TestType 提取数组接口的键 1type ArrType &#x3D; [number, string, boolean]2type ArrTypeKey &#x3D; keyof ArrType 由于ts不能直接提示数组，这里借助一个工具类型展开显示 1type Extend&lt;T&gt; &#x3D; T extends infer O ? O : never2type ArrTypeKeyExtend &#x3D; Extend&lt;ArrTypeKey&gt;3&#x2F;&#x2F; ArrTypeKey &#x3D;&#x3D;&#x3D; ArrTypeKeyExtend 可以看出是将数组对象上的属性展示。 如果是想单独取出数组的项呢? 可以通过number可以取出。 提取枚举类型的键 1enum TestEnum &#123;2 A &#x3D; 1,3 B &#x3D; 24&#125;5type TestEnumKey &#x3D; keyof TestEnum 可以看出同样是枚举对象上的属性展示。 如果是想单独取出枚举的键呢? 可以看出通过keyof可以取出。 in 对联合声明类型进行循环 对象接口循环 1interface A &#123;2 name: string3 age: number4&#125;5type AType &#x3D; &#123;6 [Key in keyof A]: boolean7&#125; 通过keyof将对象类型的键转换为联合类型，然后通过in进行循环 对数组接口循环 1type ArrType &#x3D; [&#39;1&#39;, 2, &#39;hello&#39;]2type A &#x3D; &#123;3 [Key in ArrType[number]]: boolean4&#125; 对枚举类型循环 1enum TestEnum &#123;2 A &#x3D; 1,3 B &#x3D; 24&#125;5type A &#x3D; &#123;6 [Key in keyof typeof TestEnum]: boolean7&#125; infer infer用于extends后面，可以理解为一个变量 对类型进行推导1type ArrType &#x3D; [number, string, boolean]2type First&lt;T&gt; &#x3D; T extends [infer F, ...infer _Rest] ? F : never34type A &#x3D; First&lt;ArrType&gt;","categories":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"splitChunks","slug":"webpack/webpack06","date":"2022-08-15T16:00:00.000Z","updated":"2023-10-20T04:19:13.452Z","comments":true,"path":"2022/08/16/webpack/webpack06/","link":"","permalink":"http://yoursite.com/2022/08/16/webpack/webpack06/","excerpt":"","text":"Webpack提供代码提取或分离的插件，基础配置请参照splitChunks 官方文档。这里主要深入了解关键配置核心属性。 chunks chunks代码被提取的方式，async initial all。 chunks可选项async：只提取异步加载的模块出来打包到一个文件中。initial：提取同步加载和异步加载模块，多入口相同文件分别同步异步加载时会分别打包到不同的文件中。all：不管异步加载还是同步加载的模块都提取出来，打包到一个文件中。 概念静态加载、动态加载、同步加载、异步加载动态加载和静态加载指的是什么时候加载。动态加载是运行时加载，静态加载是编译(预编译)时加载。动态加载：require() 、import()静态加载：import 同步加载和异步加载指的是加载的方式。同步加载会阻塞接下来的流程，异步加载不会。同步加载：import、require()异步加载：import()、 require([‘xxx’],() =&gt;{}) 单入口构建 构建文件 1import moment from 'moment'2const date = moment().format('YYYY-MM-DD')3console.log('date', date)4import('lodash').then((lodash) =&gt; &#123;5 const res = lodash.default.add(3, 4)6 console.log(res)7&#125;) async输出 (index+moment).js (lodash).js initial输出 (moment).js (lodash).js (index).js all输出 (moment).js (lodash).js (index).js 单入口情况下 initial 与 all 几乎没有区别。 多入口构建 构建文件 1// index.js2import moment from 'moment'3const date = moment().format('YYYY-MM-DD')4console.log('date', date)5import('lodash').then((lodash) =&gt; &#123;6 const res = lodash.default.add(3, 4)7 console.log(res)8&#125;) 1// other.js2import moment from 'moment'3import lodash from 'lodash'4const date = moment().format('YYYY-MM-DD')5console.log('date', date)6const res = lodash.add(3, 4)7console.log(res) async输出 (other+moment+lodash).js (index+moment).js (lodash).js initial输出 (moment).js (lodash).js (lodash).js (index).js (other).js all输出 (moment).js (lodash).js (index).js (other).js 分包规则属性 minSize生成 chunk 的最小体积（以 bytes 为单位）。默认20000，超过才会被提取。 maxSize生成 chunk 的体积大小不能超过maxSize值，如果超过了，要对其进行分割并打包生成新的文件。单位为字节，默认为0，表示不限制大小。 minChunks提取的模块最小被引用次数，引用次数超过或等于minChunks值，才能被提取。 maxInitialRequests打包后的入口文件加载时，还能同时加载js文件的数量（包括入口文件）。 maxAsyncRequests按需加载时的最大并行请求数。 enforceSizeThreshold强制执行拆分的体积阈值和其他限制（minRemainingSize，maxAsyncRequests，maxInitialRequests）将被忽略。 提示优先级 maxInitialRequest/maxAsyncRequests &lt; maxSize &lt; minSize cacheGroups 继承cacheGroups可以继承和/或覆盖来自 splitChunks.* 的任何选项。但是 test、priority 和 reuseExistingChunk 只能在缓存组级别上进行配置。 test用来匹配要提取的模块的资源路径或名称。值是正则或函数。 priority优先级，值越大表示提取模块时优先采用此方案。默认值为0。 reuseExistingChunk为true时，如果当前要提取的模块，在已经在打包生成的js文件中存在，则将复用该模块，而不是把当前要提取的模块打包生成新的js文件。 enforce为true时，忽略minSize，minChunks，maxAsyncRequests和maxInitialRequests外面配置选项。","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"Eslint","slug":"webpack/webpack05","date":"2022-08-03T16:00:00.000Z","updated":"2023-10-20T04:19:01.332Z","comments":true,"path":"2022/08/04/webpack/webpack05/","link":"","permalink":"http://yoursite.com/2022/08/04/webpack/webpack05/","excerpt":"","text":"Eslint为代码检查的工具官方文档：https://eslint.bootcss.com/docs/user-guide/getting-started webpack中使用1. 创建项目结构 新建1mkdir eslint-test 2cd eslint-test3npm init -y4npm install webpack webpack-cli --save-dev 新建src/index.js1console.log(&#39;Eslint!&#39;) 新建webpack.config.js1const path &#x3D; require(&#39;path&#39;)2module.exports &#x3D; &#123;3 entry: &#123;4 index: &#39;.&#x2F;src&#x2F;index.js&#39;,5 &#125;,6 output: &#123;7 path: path.resolve(__dirname, &#39;dist&#39;),8 clean: true9 &#125;,10 plugins: [],11 mode: &#39;production&#39;12&#125; package.json 配置命令1&quot;scripts&quot;: &#123;2 &quot;build&quot;: &quot;webpack --config webpack.config.js&quot;3&#125; npm run build输出1console.log(&quot;Eslint!&quot;); 2. 添加eslint插件 安装1npm install eslint-webpack-plugin --save-dev 编辑webpack.config.js1const ESlintWebpackPlugin &#x3D; require(&#39;eslint-webpack-plugin&#39;)2...3plugins: [4 new ESlintWebpackPlugin(&#123;5 context: &#39;src&#39;, &#x2F;&#x2F; 指定eslint检查目录，默认根目录6 exclude: [&#39;node_modules&#39;], &#x2F;&#x2F; 排除context指定目录下哪些文件夹不eslint检查7 &#125;)8] 创建.eslintrc.js文件1module.exports &#x3D; &#123;2 rules: &#123;3 &#x2F;&#x2F; 1 2 0 &#x3D;&#x3D;&gt; warn error off &#x3D;&#x3D;&gt; 警告 错误 关闭4 &#39;no-console&#39;: &#39;error&#39;5 &#125;6&#125; 创建.eslintignore文件1&#x2F;dist2&#x2F;node_modules3&#x2F;package.json4&#x2F;package-lock.json5webpack.config.js tips：当vscode项目列表过多，层级较深时，会出现失效情况。解决方式参照文档 ➱ 校验vscode如果装了eslint插件此时，已经可以看到报错信息了。 npm run build 构建失败 .eslintrc.js核心配置项 rules具体规则 rules1rules: &#123;2 &#x2F;&#x2F; 1 2 0 &#x3D;&#x3D;&gt; warn error off &#x3D;&#x3D;&gt; 警告 错误 关闭3 &#39;no-console&#39;: &#39;error&#39;,4 &#125;,5&#125; key为规则名，value为具体的配置内容，一般可设置为 1 2 0 或者 warn error off 分别对应 警告 错误 关闭。具体参考：https://cn.eslint.org/docs/rules/ extends继承配置继承另一份ESLint配置，有三种继承方式 从eslint本身继承1module.exports &#x3D; &#123;2 extends: [3 &#39;eslint:recommended&#39;4 ]5&#125; 从eslint-config-xxx的npm包继承 1module.exports &#x3D; &#123;2 extends: [3 &#x2F;&#x2F; eslint-config-standard 配置的时候可以省略 &#96;eslint-config&#96;4 &#39;standard&#39;5 ],6&#125; 从eslint插件继承1module.exports &#x3D; &#123;2 extends: [3 &#x2F;&#x2F; 可以省略包名中的 &#96;eslint-plugin&#96;4 &#x2F;&#x2F; 格式一般为: &#96;plugin:$&#123;pluginName&#125;&#x2F;$&#123;configName&#125;&#96;5 &#39;plugin:vue&#x2F;essential&#39;,6 &#39;plugin:@typescript-eslint&#x2F;recommended&#39;,7 ],8&#125; 1&#x2F;&#x2F; eslint-plugin-vue 包2module.exports &#x3D; &#123;3 &#x2F;&#x2F; ...4 configs: &#123;5 &#39;base&#39;: require(&#39;.&#x2F;configs&#x2F;base&#39;),6 &#39;essential&#39;: require(&#39;.&#x2F;configs&#x2F;essential&#39;),7 &#39;no-layout-rules&#39;: require(&#39;.&#x2F;configs&#x2F;no-layout-rules&#39;),8 &#39;recommended&#39;: require(&#39;.&#x2F;configs&#x2F;recommended&#39;),9 &#39;strongly-recommended&#39;: require(&#39;.&#x2F;configs&#x2F;strongly-recommended&#39;)10 &#125;11&#125; parser解析器parser是将我们写的代码进行ESTree（本质AST）解析，然后进行校验。默认的 parser，只转换 js，默认支持 ES5 的语法。 parserOptions 1&quot;parserOptions&quot;: &#123;2 &quot;ecmaVersion&quot;: 6, &#x2F;&#x2F; 配置的 ES 语法3 &quot;sourceType&quot;: &quot;module&quot;, &#x2F;&#x2F; 默认为script，如果使用 ES Module 则应设置为module4 &quot;ecmaFeatures&quot;: &#123;5 &quot;jsx&quot;: true6 &#125;7&#125; @babel/eslint-parser当使用 babel 时，babel 的解析器会把你的 code 转换为 AST，该解析器会将其转换为 ESLint 能懂的 ESTree。 @typescript-eslint@typescript-eslint/parser将 typescript 的 sourcecode 转换为 TypeScript AST，然后将 TypeScript AST 转换为 ESTree。 eslint-plugin-vuevue官方提供vue-eslint-parser plugins插件 pluginseslint通过plugins支持自定义规则，比如eslint-plugin-import、eslint-plugin-promise、eslint-plugin-react。 env是可以配置根据环境不同来判断是否开启 env1env: &#123;2 browser: &#39;true&#39;,3 node: &#39;true&#39;4&#125;","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"Babel","slug":"webpack/webpack04","date":"2022-08-02T16:00:00.000Z","updated":"2023-10-20T04:18:52.406Z","comments":true,"path":"2022/08/03/webpack/webpack04/","link":"","permalink":"http://yoursite.com/2022/08/03/webpack/webpack04/","excerpt":"","text":"介绍 Babel 是一个工具链，主要用于将采用 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。官方文档：https://www.babeljs.cn/ 1. babel 可以完成的事情 语法转换 通过 Polyfill 方式在目标环境中添加缺失的特性 （通过引入第三方 polyfill 模块，例如 core-js） 2. babel 的编译流程&emsp;&ensp;babel 是 source to source 的转换，整体编译流程分为三步： parse：通过 parser 把源码转成抽象语法树（AST） transform：遍历 AST，调用各种 transform 插件对 AST 进行增删改 generate：把转换后的 AST 打印成目标代码，并生成 sourcemap 3. babel 库 @babel/core babel核心库，包括了整个babel工作流。 @babel/parser 将源代码解析成 AST ，方便各个插件分析语法进行相应的处理。 @babel/generator 将修正后的AST解码生成js代码。 @babel/preset-env 是一个智能预设，可让你使用最新的JavaScript，转化最新语法如箭头函数, class, 扩展运算符，想要转换最新的api还需引入@babel/polyfill @babel/polyfill 模拟ES2015+ 环境。在低版本浏览器上实现一些对象、方法，比如 Promise、WeakMap、Array.from、Object.assign、Array.prototype.includes 等。 babel代码编译使用插件将对应语法转换1. 创建项目结构 新建1mkdir babel-test 2cd babel-test3npm init -y4npm install webpack webpack-cli --save-dev 新建src/index.js1const add &#x3D; (x, y) &#x3D;&gt; &#123;2 return x + y3&#125;4console.log(add, add(1, 2)) 新建webpack.config.js1const path &#x3D; require(&#39;path&#39;)2module.exports &#x3D; &#123;3 entry: &#123;4 index: &#39;.&#x2F;src&#x2F;index.js&#39;5 &#125;,6 output: &#123;7 path: path.resolve(__dirname, &#39;dist&#39;),8 clean: true9 &#125;,10 module: &#123;&#125;11&#125; package.json 配置命令1&quot;scripts&quot;: &#123;2 &quot;build&quot;: &quot;webpack --config webpack.config.js&quot;3&#125; npm run build输出1(()&#x3D;&gt;&#123;const o&#x3D;(o,c)&#x3D;&gt;o+c;console.log(o,o(1,2))&#125;)(); 2. 将箭头函数语法转译 安装babel1npm install @babel&#x2F;core @babel&#x2F;plugin-transform-arrow-functions babel-loader --save-dev webpack.config.js配置babel-loader1module: &#123;2 rules: [3 &#123;4 test: &#x2F;\\.jsx?$&#x2F;,5 use: [&#39;babel-loader&#39;]6 &#125;7 ]8&#125; 创建babel.config.json 并配置插件1&#123;2 &quot;plugins&quot;: [&quot;@babel&#x2F;plugin-transform-arrow-functions&quot;]3&#125; npm run build输出1(()&#x3D;&gt;&#123;const n&#x3D;function(n,o)&#123;return n+o&#125;;console.log(n,n(1,2))&#125;)(); 完成对箭头函数语法转译 使用预设对语法进行转译 通过上述方式，引入对应的插件可以对对应的语法进行转译。但是在开发中完全使用这种方式语法转译，就意味着每使用一种新的语法就需要添加一款对应的插件来转译。官方提供@babel/preset-env来将插件自动引入。@babel/preset-env会匹配当前环境，自动添加当前环境中不能识别的语法对应的插件进行转译。 安装 1npm install @babel&#x2F;preset-env --save-dev babel.config.json 配置预设 1&#123;2 &quot;presets&quot;: [&quot;@babel&#x2F;preset-env&quot;]3&#125; 配置需要转译的环境可以直接在babel.config.json中配置 1&#123;2 &quot;presets&quot;: [3 [4 &quot;@babel&#x2F;preset-env&quot;,5 &#123;6 &quot;targets&quot;: &#123; &quot;chrome&quot;: &quot;30&quot; &#125;7 &#125;8 ]9 ]10&#125; npm run build输出 1(()&#x3D;&gt;&#123;var n&#x3D;function(n,o)&#123;return n+o&#125;;console.log(n,n())&#125;)(); 也可以使用.browserslistrc文件配置，官方推荐项目根目录创建.browserslistrc文件 1chrome 30 .browserslistrc默认值是 &gt; 0.5%, last 2 versions, Firefox ESR, not deadnpm run build输出 1!function()&#123;var n&#x3D;function(n,o)&#123;return n+o&#125;;console.log(n,n())&#125;(); 使用polyfill对低版本浏览器进行ES2015+环境语法兼容 当我们开发时，要求兼容的浏览器不满足ES2015+环境中的功能，此时就需要通过引入polyfill来模拟ES2015+环境已经存在的功能。 1. 全部引入 安装1npm install @babel&#x2F;polyfill --save-dev index.js中引入1import &quot;@babel&#x2F;polyfill&quot;;2const add &#x3D; (x, y) &#x3D;&gt; &#123;3 return new Promise((resolve) &#x3D;&gt; &#123;4 resolve(x + y)5 &#125;)6&#125;7console.log(add, add()) npm run build输出整个polyfill全部打包，文件90k左右。 2. 手动按需引入 安装1npm install babel-runtime --save-dev index.js中引入1import Promise from &#39;babel-runtime&#x2F;core-js&#x2F;promise&#39;2const add &#x3D; (x, y) &#x3D;&gt; &#123;3 return new Promise((resolve) &#x3D;&gt; &#123;4 resolve(x + y)5 &#125;)6&#125;7console.log(add, add()) npm run build输出只打包Promise方法，文件18k左右。 3. 使用预设按需引入 安装1npm install @babel&#x2F;plugin-transform-runtime core-js@3 --save-dev babel.config.json配置1&#123;2 &quot;presets&quot;: [3 [4 &quot;@babel&#x2F;preset-env&quot;,5 &#123;6 &quot;useBuiltIns&quot;: &quot;usage&quot;, &#x2F;&#x2F; 默认false时只进行语法转译，不对api等处理7 &quot;corejs&quot;: &quot;3&quot;8 &#125;9 ]10 ],11 &quot;plugins&quot;: [&quot;@babel&#x2F;plugin-transform-runtime&quot;]12&#125; .browserslistrc 指定环境1chrome 30 index.js1const add &#x3D; (x, y) &#x3D;&gt; &#123;2 return new Promise((resolve) &#x3D;&gt; &#123;3 resolve(x + y)4 &#125;)5&#125;6console.log(add, add()) npm run build输出 总结语法自动转译与polyfill的自动引入 方式一 1npm i @babel&#x2F;core @babel&#x2F;preset-env @babel&#x2F;plugin-transform-runtime core-js@3 babel-loader babel.config.json配置 1&#123;2 &quot;presets&quot;: [3 [4 &quot;@babel&#x2F;preset-env&quot;,5 &#123;6 &quot;useBuiltIns&quot;: &quot;usage&quot;, &#x2F;&#x2F; 默认false时只进行语法转译，不对api等处理7 &quot;corejs&quot;: &quot;3&quot;8 &#125;9 ]10 ],11 &quot;plugins&quot;: [&quot;@babel&#x2F;plugin-transform-runtime&quot;]12&#125; .browserslistrc 1last 1 version2&gt; 1%3maintained node versions4not dead 方式二 1npm i @babel&#x2F;core @babel&#x2F;preset-env @babel&#x2F;plugin-transform-runtime @babel&#x2F;runtime-corejs3 babel-loader babel.config.json配置 1&#123;2 &quot;presets&quot;: [&quot;@babel&#x2F;preset-env&quot;],3 &quot;plugins&quot;: [[&quot;@babel&#x2F;plugin-transform-runtime&quot;, &#123; &quot;corejs&quot;: &quot;3&quot; &#125;]]4&#125; .browserslistrc 1last 1 version2&gt; 1%3maintained node versions4not dead","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"Monorepo","slug":"technical/technical07","date":"2022-07-12T16:00:00.000Z","updated":"2024-03-06T06:45:01.838Z","comments":true,"path":"2022/07/13/technical/technical07/","link":"","permalink":"http://yoursite.com/2022/07/13/technical/technical07/","excerpt":"","text":"Monorepo是一个仓库，分为多个包管理的一直管理模式。https://juejin.cn/post/6944877410827370504 pnpm构建 pnpm安装1npm install -g pnpm 创建workspace1pnpm init 根目录创建pnpm-workspace.yaml1packages:2- &quot;packages&#x2F;**&quot; 构建目录1├─ packages2│ ├─ project013│ │ ├─ package.json4│ │ └─src5│ │ └─ index.js6│ └─ utils7│ ├─ index.js8│ └─ package.json9├─ package.json10├─ pnpm-lock.yaml11└─ pnpm-workspace.yaml pnpm常用命令 -F –filter &lt;package_name&gt; 1&#x2F;&#x2F; utils模块单独安装dayjs2pnpm -F @packages&#x2F;utils add dayjs 1&#x2F;&#x2F; utils模块单独移除dayjs2pnpm -F @packages&#x2F;utils remove dayjs 1&#x2F;&#x2F; 根据utils下package.json安装所有包2pnpm -F @packages&#x2F;utils install -w, –workspace-root1&#x2F;&#x2F; 根目录单独安装webpack2pnpm -w add webpack -D lib之间相互引用 uitls子包模块安装 dayjs1pnpm -F @package&#x2F;utils add dayjs index.js function 导出1import dayjs from &#39;dayjs&#39;2export function format(time, f &#x3D; &#39;YYYY-MM-DD&#39;) &#123;3 return &#39;日期：&#39; + dayjs(time).format(f)4&#125; package.json1&#123;2 &quot;main&quot;: &quot;index.js&quot;,3&#125; project01子包模块安装utils子包模块1pnpm -F project01 add @package&#x2F;utils package.json1&quot;dependencies&quot;: &#123;2 &quot;@packages&#x2F;utils&quot;: &quot;workspace:*&quot;, &#x2F;&#x2F; 默认为&quot;workspace:1.0.0&quot;3&#125; 命名空间参照: workspace文件中使用1import &#123; format &#125; from &#39;@packages&#x2F;utils&#39;2console.log(&#39;format(new Date())&#39;, format(new Date())) changesets配置 @changesets/cli1pnpm -w add @changesets&#x2F;cli -D 初始化1pnpm changeset init 执行完命令后根目录下生成.changeset目录1├─ .changeset2│ ├─ config.json3│ └─ README.md 1&#123;2 &quot;$schema&quot;: &quot;https:&#x2F;&#x2F;unpkg.com&#x2F;@changesets&#x2F;config@2.0.1&#x2F;schema.json&quot;,3 &quot;changelog&quot;: &quot;@changesets&#x2F;cli&#x2F;changelog&quot;,4 &#x2F;&#x2F; 不要让 changeset 在 publish 的时候帮我们做 git add5 &quot;commit&quot;: false,6 &quot;fixed&quot;: [],7 &#x2F;&#x2F; 配置哪些包要共享版本8 &quot;linked&quot;: [],9 &#x2F;&#x2F; access: 公私有安全设定，内网建议 restricted ，开源使用 public10 &quot;access&quot;: &quot;restricted&quot;,11 &#x2F;&#x2F; 项目git主分支12 &quot;baseBranch&quot;: &quot;main&quot;,13 &#x2F;&#x2F; 确保某包依赖的包发生 upgrade，该包也要发生 version upgrade 的衡量单位（量级）14 &quot;updateInternalDependencies&quot;: &quot;patch&quot;,15 &#x2F;&#x2F; 不需要变动 version 的包16 &quot;ignore&quot;: []17&#125; 根目录package.json script 配置构建1&quot;scripts&quot;: &#123;2 &quot;build&quot;: &quot;pnpm --filter&#x3D;@packages&#x2F;* run build&quot;,3 &quot;clear&quot;: &quot;rimraf &#39;packages&#x2F;*&#x2F;&#123;lib,node_modules&#125;&#39; &amp;&amp; rimraf node_modules&quot;,4 &quot;changeset&quot;: &quot;changeset&quot;,5 &quot;version-packages&quot;: &quot;changeset version&quot;6&#125;, build: 打包所有子包模块。运行子包模块package.json中build命令。 clear: 删除所有 node_modules及lib。需安装rimraf。 changesets发包 changeset1pnpm changeset 选择需要发布的包 选择版本一共有三种类型，分别是 major、minor、patch。（主版本、次版本、修订版本） .changeset 下生成文件 stale-swans-xxxx.md version-packages1pnpm version-packages 修改子包模块package.json 的version。 生成 CHANGELOG.md 文件 npm login1npm login &#x2F;&#x2F; 登录命令2Username: &#x2F;&#x2F; 输入注册时候的用户名3Password: &#x2F;&#x2F; 密码4Email: (this IS public) &#x2F;&#x2F; 注册时的邮箱 npm publish1pnpm changeset publish","categories":[{"name":"技术点","slug":"技术点","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%82%B9/"}],"tags":[{"name":"技术点","slug":"技术点","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%82%B9/"}]},{"title":"Node脚本","slug":"node/node06","date":"2022-07-04T16:00:00.000Z","updated":"2023-10-20T06:08:38.570Z","comments":true,"path":"2022/07/05/node/node06/","link":"","permalink":"http://yoursite.com/2022/07/05/node/node06/","excerpt":"","text":"创建 npm init -y 初始化一个包 package.json 中配置 bin1&quot;bin&quot;: &#123;2 &quot;test-cli&quot;: &quot;test-cli.js&quot;3&#125; 创建脚本文件，指定执行脚本的解释器1#!&#x2F;usr&#x2F;bin&#x2F;env node2&#x2F;&#x2F; 或者3#!&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node type node npm link 把当前包软链接到全局的node_modules下 脚本也会同样软连接到全局bin下 npm unlink 移除软链接 全局执行脚本test-cli 常用工具commander 命令行界面工具 安装1npm i commander option1const &#123; program &#125; &#x3D; require(&#39;commander&#39;)2program3 .option(&#39;-s, --separator &lt;char&gt;&#39;, &#39;这是一个描述信息&#39;)4 .action((options) &#x3D;&gt; &#123;5 console.log(&#39;options&#39;, options) &#x2F;&#x2F; options &#x3D;&#x3D;&#x3D; program.opts()6 &#125;)7program.parse() &#x2F;&#x2F; 在控制台打印信息8const options &#x3D; program.opts()9console.log(&#39;options&#39;, options) command1program2.command(&#39;clone &lt;source&gt; [destination]&#39;)3.description(&#39;这是一个描述信息&#39;)4.action((source, destination) &#x3D;&gt; &#123;5 console.log(&#39;source, destination&#39;, source, destination)6&#125;)7program.parse()8const options &#x3D; program.opts()9console.log(&#39;options&#39;, options) async1program2 .command(&#39;create &lt;project-name&gt;&#39;)3 .description(&#39;这是一个描述信息&#39;)4 .action((source) &#x3D;&gt; &#123;5 setTimeout(() &#x3D;&gt; &#123;6 console.log(&#39;source&#39;, source)7 &#125;, 2000)8 &#125;)9program.parseAsync() 文档地址https://www.npmjs.com/package/commanderhttps://github.com/tj/commander.js/blob/HEAD/Readme_zh-CN.md inquirer 交互式命令行工具 安装 1npm i inquirer 1const inquirer &#x3D; require(&#39;inquirer&#39;)2let prompt &#x3D; [3 &#123;4 type: &#39;input&#39;,5 name: &#39;version&#39;,6 message: &#39;version&#39;,7 default: &#39;1.0.0&#39;,8 &#125;,9 &#123;10 type: &#39;confirm&#39;,11 name: &#39;confirm&#39;,12 message: &#39;Are you handsome?&#39;,13 default: true,14 &#125;,15 &#123;16 type: &#39;checkbox&#39;,17 name: &#39;checkbox&#39;,18 choices: [&#39;选项一&#39;, &#39;选项二&#39;],19 default: [&#39;选项一&#39;],20 &#125;,21 &#x2F;&#x2F; ....22]23inquirer.prompt(prompt).then((params) &#x3D;&gt; &#123;24 console.log(&#39;params&#39;, params)25&#125;) type 提示的类型。默认值input, 可选input, number, confirm, list, rawlist, expand, checkbox, password, editor。name 键（变量名）message 提示信息default 默认值choices 展示的列表… 文档地址https://github.com/SBoudrias/Inquirer.js#readmehttps://juejin.cn/post/6844903480700698638 fs-extra 文件处理工具 安装 1npm i fs-extra 文件复制 1fse.copy(&#39;&#x2F;tmp&#x2F;myfile&#39;, &#39;&#x2F;tmp&#x2F;mynewfile&#39;)2.then(() &#x3D;&gt; console.log(&#39;success!&#39;))3.catch(err &#x3D;&gt; console.error(err)) 创建文件emptyDir 创建空文件。若文件存在，则删除创建。ensureFile 创建文件，及文件夹。若文件存在，不进行修改。ensureDir 创建文件夹。若文件夹存在，不进行创建。 移动文件move 删除文件remove 文件写入outputFile 文件读取readFile json写入outputJson json读取readJson 文档地址https://github.com/jprichardson/node-fs-extrahttps://juejin.cn/post/6844903641594216455 shelljs 命令行工具 安装1npm i shelljs 基本命令1&#x2F;&#x2F; 命令行打印信息 &#x3D;&#x3D;&#x3D; console.log2shelljs.echo(&#39;hello world！&#39;) 1&#x2F;&#x2F; 退出当前进程2shelljs.exit(1) &#x2F;&#x2F; 0正常退出，其他异常退出 1&#x2F;&#x2F; exec同步运行外部工具2if(shelljs.exec(&#39;npm -v&#39;).code !&#x3D;&#x3D; 0)&#123;3 shelljs.echo(&#39;npm -v 命令执行错误&#39;)4 shelljs.exit(1) &#x2F;&#x2F; 0正常退出，其他异常退出5&#125; 1&#x2F;&#x2F; 切换文件目录2shelljs.cd(&#39;..&#39;) 1&#x2F;&#x2F; 递归删除 -f:强制删除 -r:递归处理2shelljs.rm(&#39;-rf&#39;, &#39;test&#39;) 文档地址https://www.kancloud.cn/outsider/clitool/313191 chalk 命令行样式处理工具 安装 1&#x2F;&#x2F; 4版本为require 5版本为import2npm i chalk@4.1.1 字体颜色 1const chalk &#x3D; require(&#39;chalk&#39;);2&#x2F;&#x2F; 内置颜色3console.log(chalk.blue(&#39;---- Hello Chalk ----&#39;));4&#x2F;&#x2F; 自定义颜色5console.log(chalk.rgb(9, 218, 158).visible(&#39;---- Hello Chalk ----&#39;))6console.log(chalk.hex(&#39;#09DA9E&#39;).visible(&#39;---- Hello Chalk ----&#39;)) 字体样式 1console.log(chalk.blue.dim(&#39;---- Hello Chalk ----&#39;));2console.log(chalk.blue.italic(&#39;---- Hello Chalk ----&#39;));3console.log(chalk.blue.underline(&#39;---- Hello Chalk ----&#39;));4console.log(chalk.blue.inverse(&#39;---- Hello Chalk ----&#39;));5console.log(chalk.blue.hidden(&#39;---- Hello Chalk ----&#39;));6console.log(chalk.blue.strikethrough(&#39;---- Hello Chalk ----&#39;)); bold 加粗字体dim 让字体稍微泛光italic 斜体（powershell上不支持）underline 下划线（git bash上不支持）inverse 翻转背景色和前景色hidden 打印文本，但使其不可见strikethrough 将一条水平线穿过文本的中心（git bash和powershell都不支持）visible 仅当chalk的颜色级别为&gt; 0时打印文本。 背景颜色 1&#x2F;&#x2F; 内置背景颜色2console.log(chalk.bgGreenBright(&#39;---- Hello Chalk ----&#39;));3&#x2F;&#x2F; 自定义背景颜色4console.log(chalk.bgHex(&#39;#09DA9E&#39;).visible(&#39;---- Hello Chalk ----&#39;))5console.log(chalk.bgRgb(9, 218, 158).visible(&#39;---- Hello Chalk ----&#39;)) 模板字符串 1const miles &#x3D; 18;2const calculateFeet &#x3D; miles &#x3D;&gt; miles * 5280;3console.log(chalk&#96;4 There are &#123;bold 5280 feet&#125; in a mile.5 In &#123;bold $&#123;miles&#125; miles&#125;, there are &#123;green.bold $&#123;calculateFeet(miles)&#125; feet&#125;.6&#96;); 文档地址https://github.com/chalk/chalk","categories":[{"name":"node","slug":"node","permalink":"http://yoursite.com/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"npm包发布","slug":"webpack/webpack03","date":"2022-07-03T16:00:00.000Z","updated":"2023-10-20T04:18:38.625Z","comments":true,"path":"2022/07/04/webpack/webpack03/","link":"","permalink":"http://yoursite.com/2022/07/04/webpack/webpack03/","excerpt":"","text":"package 发包时关键配置属性 name包名称，发包之后对应包目录文件名称。import时通过该名称找到对应包。 version版本号 dependencies生产环境依赖。安装包时dependencies中的依赖也会同时被下载安装。 peerDependencies兼容依赖。使用包时，对使用环境要求对应包的兼容。 main指定加载入口文件，在browser和node环境都能使用。 files指定需要发布的文件。 bin指定脚本的加载文件。 npm包发布 注册账号 1npm adduser2npm adduser --registry&#x3D;http:&#x2F;&#x2F;example.com 登录 1npm login 登出 1npm logout 查看当前登录人 1npm who am i 发布 1npm publish 撤回发布 1npm unpublish [pkg]@[version]","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"Webpack 常用插件","slug":"webpack/webpack02","date":"2022-06-30T16:00:00.000Z","updated":"2023-10-20T04:18:25.606Z","comments":true,"path":"2022/07/01/webpack/webpack02/","link":"","permalink":"http://yoursite.com/2022/07/01/webpack/webpack02/","excerpt":"","text":"loader cssyarn add style-loader css-loader postcss-loader -Dyarn add sass sass-loader -Dyarn add less less-loader -D处理css文件 1&#123;2 test: &#x2F;\\.(css|scss)$&#x2F;,3 use: [4 &#39;style-loader&#39;,5 &#123;6 loader: &#39;css-loader&#39;,7 options: &#123;8 importLoaders: 19 &#125;,10 &#125;,11 &#123;12 loader: &#39;postcss-loader&#39;,13 options: &#123;14 postcssOptions: &#123;15 &#x2F;&#x2F; postcss-preset-env插件：帮postcss找到package.json中的browserslist配置，根据配置加载指定的兼容性样式16 plugins: [require(&#39;postcss-preset-env&#39;)()]17 &#125;18 &#125;19 &#125;,20 &#39;sass-loader&#39;21 ]22&#125; 1&#x2F;&#x2F; .browserslistrc2last 1 version3&gt; 1%4maintained node versions5not dead htmlyarn add html-loader extract-loader ejs-loader -D 1test: &#x2F;\\.html$&#x2F;,2use: [3 &#123;4 loader: &#39;ejs-loader&#39;,5 options: &#123;6 esModule: false,7 &#125;,8 &#125;,9 &#39;extract-loader&#39;,10 &#39;html-loader&#39;11] pluginhttps://webpack.docschina.org/plugins/ html-webpack-plugin处理html模板 1const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)2...3new HtmlWebpackPlugin(&#123;4 template: &#39;.&#x2F;public&#x2F;index.html&#39;,5 filename: &#39;index.html&#39;6&#125;) progress-bar-webpack-plugin构建进度条 1const ProgressBarPlugin &#x3D; require(&#39;progress-bar-webpack-plugin&#39;)2...3new ProgressBarPlugin(&#123;4 format: &#96; :msg [:bar] :percent (:elapsed s)&#96;,5&#125;) speed-measure-webpack-plugin查看各个 loader、plugin 的构建时长 1const SpeedMeasurePlugin &#x3D; require(&quot;speed-measure-webpack-plugin&quot;);2const smp &#x3D; new SpeedMeasurePlugin();3module.exports &#x3D; smp.wrap(&#123;4 &#x2F;&#x2F; ...webpack config...5&#125;) copy-webpack-plugin复制静态资源 1const CopyWebpackPlugin &#x3D; require(&#39;copy-webpack-plugin&#39;)2...3new CopyWebpackPlugin(&#123;4 patterns: [5 &#123;6 from: resolve(__dirname, &#39;..&#x2F;pubilc&#x2F;favicon.ico&#39;),7 to: &#39;&#39;,8 &#125;9 ]10&#125;) webpack.DefinePlugin定义赋值全局公共变量 1const webpack &#x3D; require(&#39;webpack&#39;)2...3new webpack.DefinePlugin(&#123;4 BASE_URL: JSON.stringify(process.env.BASE_URL || &#39;&#x2F;&#39;),5 &#39;process.env&#39;: &#123;6 BASE_URL: JSON.stringify(process.env.BASE_URL || &#39;&#x2F;&#39;),7 NODE_ENV: JSON.stringify(process.env.NODE_ENV || &#39;&#39;)8 &#125;9&#125;) compression-webpack-plugingzip 压缩 1const CompressionWebpackPlugin &#x3D; require(&#39;compression-webpack-plugin&#39;)2···3new CompressionWebpackPlugin(&#123;4 filename: &#39;[path][base].gz&#39;, &#x2F;&#x2F; 目标资源名称。[file] 会被替换成原资源。[path] 会被替换成原资源路径，[query] 替换成原查询字符串5 algorithm: &#39;gzip&#39;,6 test: &#x2F;.(js|css)$&#x2F;,7 threshold: 10240, &#x2F;&#x2F; 只处理比这个值大的资源。按字节计算, 默认为08 minRatio: 0.8, &#x2F;&#x2F; 只有压缩率比这个值小的资源才会被处理, 默认为0.89 deleteOriginalAssets: false &#x2F;&#x2F;是否删除原始文件10&#125;) vue yarn add vue-template-compiler vue-loader vue-style-loader -Dyarn add vue vue-router -S 1const &#123; VueLoaderPlugin &#125; &#x3D; require(&#39;vue-loader&#39;)2...3module: &#123;4 rules: [5 &#x2F;&#x2F; vue-loader 要放在匹配规则的第一个，否则会报错6 &#123;7 test: &#x2F;.vue$&#x2F;,8 loader: &#39;vue-loader&#39;,9 include: [resolve(__dirname, &#39;..&#x2F;src&#39;)],10 &#125;11 ]12&#125;,13plugins: [new VueLoaderPlugin()]","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"Webpack 核心配置","slug":"webpack/webpack01","date":"2022-06-29T16:00:00.000Z","updated":"2023-10-20T04:18:12.429Z","comments":true,"path":"2022/06/30/webpack/webpack01/","link":"","permalink":"http://yoursite.com/2022/06/30/webpack/webpack01/","excerpt":"","text":"起步 npm init -ynpm install webpack webpack-cli webpack-dev-server –save-devtouch webpack.config.js 1&quot;scripts&quot;: &#123;2 &quot;start&quot;: &quot;webpack-dev-server --config webpack.config.js&quot;,3 &quot;build&quot;: &quot;webpack --config webpack.config.js&quot;4&#125; entry 入口（entry）：webpack以哪个文件为入口起点开始打包，分析构建内部依赖图 1&#x2F;&#x2F; string方式：单入口2entry: &#39;.&#x2F;src&#x2F;index.js&#39;3&#x2F;&#x2F; array方式：多入口4entry: [&#39;.&#x2F;src&#x2F;index.js&#39;, &#39;.&#x2F;src&#x2F;test.js&#39;]5&#x2F;&#x2F; object方式：多入口6entry: &#123;7 index: &#39;.&#x2F;src&#x2F;index.js&#39;,8 test: &#39;.&#x2F;src&#x2F;test.js&#39;9&#125; string方式、array方式打包只会形成一个chunk，输出一个文件。object方式打包，有几个入口文件就输出几个文件，文件的名称为对象的key。 output 输出（output）：webpack打包后文件输出到哪里，以及如何命名 1&#x2F;&#x2F; 指定输出位置 目录2path: resolve(__dirname, &#39;dist&#39;),3&#x2F;&#x2F; name根据entry判断生成，默认main.js4filename: &#39;[name].js&#39;,5&#x2F;&#x2F; 所有资源引入公共路径前缀6publicPath: &#39;&#39;,7&#x2F;&#x2F; import动态导入形成的chunk8chunkFilename: &#39;[contenthash:10].chunk.js&#39;,9clean: true, &#x2F;&#x2F; 打包前清空输出目录，相当于clean-webpack-plugin插件的作用,webpack5新增。10library: &#39;library&#39;, &#x2F;&#x2F; 导出库名称11libraryTarget: &#39;umd&#39; &#x2F;&#x2F; 导出库类型 library 对指定输出的文件，打包成库的形式，根据libraryTarget的类型，支持 es6、commonjs、AMD、script… 使用方式。 loader 文件处理（loader）Loader 让 webpack 能够去处理那些非 javascript 文件(webpack 自身只理解javascript)Loader 作为翻译官 将 css img … 这些webpack 不能识别的文件,翻译成webpack 可以识别的文件 1rules: [2 &#123;3 &#x2F;&#x2F; 匹配文件正则4 test: &#x2F;\\.less$&#x2F;,5 &#x2F;&#x2F; 指定检查的文件路径6 include: [resolve(__dirname, &#39;src&#39;)],7 &#x2F;&#x2F; 排除不需要检查的文件路径8 exclude: [resolve(__dirname, &#39;node_modules&#39;)],9 &#x2F;&#x2F; 使用loader 处理文件10 &#x2F;&#x2F; use数组中loader执行顺序：从右到左，从下到上，一次执行11 use: [12 &#x2F;&#x2F; 创建style标签，将js中的样式资源插入进入，添加到head中生效13 &#39;style-loader&#39;,14 &#x2F;&#x2F; 将css文件变成 commonjs模块，加载js中，里面类容是样式字符串15 &#39;css-loader&#39;,16 &#123;17 &#x2F;&#x2F; css 兼容处理 postcss，注意需要在package.json配置browserslist18 loader: &quot;postcss-loader&quot;,19 &#x2F;&#x2F; options 属性为字符串或对象。值可以传递到 loader 中，将其理解为 loader 选项。20 options: &#123;21 postcssOptions: &#123;22 &#x2F;&#x2F; postcss-preset-env插件：帮postcss找到package.json中的browserslist配置，根据配置加载指定的兼容性样式 23 plugins: [require(&quot;postcss-preset-env&quot;)()],24 &#125;25 &#125;26 &#125;,27 &#x2F;&#x2F; 将less 编译成 css文件 (需要下载 less-loader 和 less)28 &#39;less-loader&#39;29 ]30 &#125;31] use数组中loader执行顺序：从右到左，从下到上，一次执行。options 属性为字符串或对象。值可以传递到 loader 中，将其理解为 loader 选项。 plugin 插件（plugins）：可以执行范围更广泛的任务, 插件的范围包括, 从打包优化和压缩,一直到从新定义环境中的变量等。 1const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)2const MiniCssExtractPlugin &#x3D; require(&#39;mini-css-extract-plugin&#39;)3const &#123; resolve &#125; &#x3D; require(&#39;path&#39;)4module.exports &#x3D; &#123;5 entry: &#39;.&#x2F;src&#x2F;index.js&#39;,6 output: &#123;7 path: resolve(__dirname, &#39;dist&#39;),8 filename: &#39;[name].js&#39;,9 &#125;,10 module: &#123;11 rules: [12 &#123;13 test: &#x2F;\\.less$&#x2F;,14 use: [15 MiniCssExtractPlugin.loader,16 &#39;css-loader&#39;,17 &#39;less-loader&#39;18 ],19 &#125;,20 ],21 &#125;,22 plugins: [23 new HtmlWebpackPlugin(&#123;24 templete: &#39;.&#x2F;public&#x2F;index.html&#39;25 &#125;),26 new MiniCssExtractPlugin(&#123;27 filename:&#39;css&#x2F;box.css&#39;28 &#125;)29 ]30&#125; mode 模式（mode）：webpack 使用相应模式的配置 选项 描述 development 会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 development. 为模块和 chunk 启用有效的名。 production 会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 production。为模块和 chunk 启用确定性的混淆名称，FlagDependencyUsagePlugin，FlagIncludedChunksPlugin，ModuleConcatenationPlugin，NoEmitOnErrorsPlugin 和 TerserPlugin 。 DefinePlugin：定义全局变量process.env.NODE_ENV，区分程序运行状态。 FlagDependencyUsagePlugin：标记没有用到的依赖。 FlagIncludedChunksPlugin：标记chunks，防止chunks多次加载。 ModuleConcatenationPlugin：作用域提升(scope hosting)，预编译功能，提升或者预编译所有模块到一个闭包中，提升代码在浏览器中的执行速度。 NoEmitOnErrorsPlugin：防止程序报错，就算有错误也继续编译。 TerserPlugin：压缩js代码。 其他常用配置1devServer: &#123;2 &#x2F;&#x2F; 运行服务的目录 (webpack4 使用 contentBase)3 static: resolve(__dirname, &#39;dist&#39;),4 &#x2F;&#x2F; 开启gzip压缩5 compress: true,6 host: &#39;localhost&#39;,7 port: 8080,8 &#x2F;&#x2F; 开启热更新9 hot: true,10 &#x2F;&#x2F; 启动自动打开浏览器11 open: true,12 &#x2F;&#x2F; 设置代理13 proxy: &#123;14 &#x2F;&#x2F; 匹配到&#x2F;api&#x2F;xxx的请求，就会用devServer起的服务把请求转发到另外一个服务器（3000）15 &#x2F;&#x2F; 以此来解决开发中的跨域问题16 api: &#123;17 target: &#39;https:&#x2F;&#x2F;localhost:3000&#39;,18 &#x2F;&#x2F; 发送请求时，请求路径重写：将&#x2F;api&#x2F;xxx --&gt; &#x2F;xxx （去掉&#x2F;api）19 pathRewrite: &#123;20 &#39;^api&#39;: &#39;&#39;21 &#125;22 &#125;23 &#125;24&#125; 1resolve: &#123;2 &#x2F;&#x2F; 设置别名3 alias: &#123;4 &#39;@&#39;: resolve(__dirname, &#39;src&#39;),5 &#125;,6 extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.vue&#39;], &#x2F;&#x2F; 省略文件后缀7 &#x2F;&#x2F; 指定引用包的位置 默认node_modules8 modules: [resolve(__dirname, &#39;modules&#39;), &#39;node_modules&#39;],9&#125;, 在项目中对模块 import 或者 require 时，如果引用后缀没有 './' 之类的开头，则会从当前项目package的node_modules（默认）中查找，没查找到则会想上一级的package对应项目中查找，一直到全局。 包引用访问时，modules:[]前面的位置会先访问。 查找是根据引用的”名称“找到对应”文件夹“，然后检查文件夹内是否有package.json，如果有则访问到package中main指定的文件，如果没有则默认访问改目录下index.js。 1optimization: &#123;2 &#x2F;&#x2F; 提取公共代码3 splitChunks: &#123;4 chunks: &quot;all&quot;,5 &#125;,6 minimizer: [7 &#x2F;&#x2F; 配置生产环境的压缩方案：js和css8 new TerserWebpackPlugin(&#123;9 &#x2F;&#x2F; 多进程打包10 parallel: true,11 terserOptions: &#123;12 &#x2F;&#x2F; 启动source-map13 sourceMap: true14 &#125;15 &#125;)16 ]17&#125;","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"使用koa构建基本服务","slug":"server/server08","date":"2022-03-09T16:00:00.000Z","updated":"2023-10-20T04:30:24.636Z","comments":true,"path":"2022/03/10/server/server08/","link":"","permalink":"http://yoursite.com/2022/03/10/server/server08/","excerpt":"","text":"项目构建 创建模板koa2脚手架构建项目文档 目录结构规划调整 - 新增logs 存放日志 - 新增src/conf 环境配置 - 新增src/controller 控制层 - 新增src/db 数据库配置 - 新增src/middleware 中间件 - 新增src/model 公共模块 - 新增src/routes 路由 - 新增src/utils 工具 环境配置 cross-env下载安装1npm install --save-dev cross-env package.json中调整scripts命令配置 - --inspect=9229项目在chrome://inspect中debugger - pm2配置参照文档 根目录添加pm2.conf.json的配置文件 src/conf环境配置项 - 根据cross-env配置的环境，创建对应的环境配置文件 - 根据运行的环境，读取对应的配置文件 Todo","categories":[{"name":"server","slug":"server","permalink":"http://yoursite.com/categories/server/"}],"tags":[{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"小程序自定义组件","slug":"applets/applets03","date":"2022-02-28T16:00:00.000Z","updated":"2023-10-20T04:17:10.096Z","comments":true,"path":"2022/03/01/applets/applets03/","link":"","permalink":"http://yoursite.com/2022/03/01/applets/applets03/","excerpt":"","text":"组件介绍 组件的创建在小程序的编辑器中可以通过文件右击选择新建Component来构建小程序的自定义组件。 组件的结构与页面类似，小程序的自定义也是由四部分组成：.json 配置文件、.wxml 模板文件、.wxss 样式文件、.js 脚本逻辑文件。 组件使用在页面或者组件的.json 配置文件通过 usingComponents 使用 1\"usingComponents\": &#123;2 \"l-rate\":\"/miniprogram_npm/lin-ui/rate\"3&#125; 1&lt;l-rate score=\"3\" disabled=\"&#123;&#123;false&#125;&#125;\" size=\"22\" /&gt; 组件模板 插槽slot 默认情况下，一个组件的 wxml 中只能有一个 slot 1&lt;view&gt;2 &lt;text&gt;这是text-list组件&lt;/text&gt;3 &lt;slot&gt;&lt;/slot&gt;4&lt;/view&gt; 1&lt;test-list&gt;2 &lt;text&gt;这是test page 中的text&lt;/text&gt;3&lt;/test-list&gt; 使用多 slot 时，需要在组件 js 中声明启用 1Component(&#123;2 options: &#123;3 multipleSlots: true // 在组件定义时的选项中启用多slot支持4 &#125;5&#125;) 1&lt;view&gt;2 &lt;text&gt;这是text-list组件&lt;/text&gt;3 &lt;slot name=\"a\"&gt;&lt;/slot&gt;4 &lt;slot name=\"b\"&gt;&lt;/slot&gt;5&lt;/view&gt; 1&lt;test-list&gt;2 &lt;text slot=\"a\"&gt;这是test page 中的text a&lt;/text&gt;3 &lt;text slot=\"b\"&gt;这是test page 中的text b&lt;/text&gt;4&lt;/test-list&gt; 组件样式 页面样式与组件样式关系 组件对应 wxss 文件的样式，只对组件wxml内的节点生效。组件所在页面的样式以及app.wxss 对自定义组件无效。（在不更改组件样式隔离选项的情况下）组件所在页面的样式以及app.wxss 标签名选择器 会影响组件中标签的样式。例如 1text &#123;2 color: #ff0000;3 font-size: 50rpx;4&#125; 组件样式隔离 通过在js中配置styleIsolation可指定特殊的样式隔离选项 1Component(&#123;2 options: &#123;3 styleIsolation: 'isolated'4 &#125;5&#125;) isolated &nbsp; 默认值，在自定义组件内外，使用 class 指定的样式将不会相互影响。apply-shared &nbsp; 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面。shared &nbsp; 在自定义组件内外，使用 class 指定的样式将会相互影响。此外，还有一种写法是 addGlobalClass: true 这种写法和设置styleIsolation：‘apply-shared’ 一样。 外部样式类 通过在js中externalClasses 配置样式类，然后在组件内元素的class上添加该样式类，外部组件就可以通过该样式类影响该元素的样式。 1Component(&#123;2 externalClasses: ['my-class']3&#125;) 1&lt;view&gt;2 &lt;text class=\"a\"&gt;这是text-list组件 的 a&lt;/text&gt;3 &lt;text class=\"b my-class\"&gt;这是text-list组件 的 a&lt;/text&gt;4&lt;/view&gt; 1&lt;test-list my-class=\"bg-red\"&gt;&lt;/test-list&gt; .bg-red 的样式就可以影响到 class=”b my-class” 的这个text元素了。组件模板和样式 Component构造器 Component 构造器可用于定义组件，调用 Component 构造器时可以指定组件的属性、数据、方法等。 模板结构1Component(&#123;2 options:&#123;&#125;, // 一些选项的配置34 behaviors: [], // 类似mixins的代码混合机制56 properties: &#123;7 myProperty: &#123; // 属性名8 type: String,9 value: ''10 &#125;,11 myProperty2: String // 简化的定义方式12 &#125;,13 14 data: &#123;&#125;, // 私有数据，可用于模板渲染1516 lifetimes: &#123;17 // 生命周期函数，可以为函数，或一个在methods段中定义的方法名18 attached: function () &#123; &#125;,19 moved: function () &#123; &#125;,20 detached: function () &#123; &#125;,21 &#125;,2223 // 生命周期函数，可以为函数，或一个在methods段中定义的方法名24 attached: function () &#123; &#125;, // 此处attached的声明会被lifetimes字段中的声明覆盖25 ready: function() &#123; &#125;,2627 pageLifetimes: &#123;28 // 组件所在页面的生命周期函数29 show: function () &#123; &#125;,30 hide: function () &#123; &#125;,31 resize: function () &#123; &#125;,32 &#125;,3334 methods: &#123;35 onMyButtonTap: function()&#123;36 this.setData(&#123;37 // 更新属性和数据的方法与更新页面数据的方法类似38 &#125;)39 &#125;,40 // 内部方法建议以下划线开头41 _myPrivateMethod: function()&#123;42 // 这里将 data.A[0].B 设为 'myPrivateData'43 this.setData(&#123;44 'A[0].B': 'myPrivateData'45 &#125;)46 &#125;,47 _propertyChange: function(newVal, oldVal) &#123;4849 &#125;50 &#125;51&#125;) options &nbsp; 一些选项的配置behaviors &nbsp; 类似mixins的代码混合机制properties &nbsp; 组件外部传递进入的数据，可用于模板渲染data &nbsp; 组件内部私有数据，可用于模板渲染methods &nbsp; 组件的方法，包括事件响应函数和任意的自定义方法…Component文档 组件通讯 自定义属性向组件内部传入数据1&lt;!-- test.wxml --&gt;2 &lt;test-list test-text=\"这是一段测试文本\"&gt;&lt;/test-list&gt; 1// test-list 组件的Component构造器中2properties: &#123;3 testText: &#123;4 type: String,5 value: ''6 &#125;7&#125; 1&lt;!-- test-list component wxml --&gt;2&lt;text&gt;&#123;&#123;testText&#125;&#125;&lt;/text&gt; 组件内部通过自定义事件triggerEvent方式，向外部暴露事件，进而传递出数据。1&lt;!-- test-list component wxml --&gt;2&lt;button bind:tap=\"handleTop\"&gt;自定义事件&lt;/button&gt; this.triggerEvent(‘自定义事件名称’, 传递出的数据, 触发事件的选项)1// test-list 组件的Component构造器2Component(&#123;3 properties: &#123;&#125;,4 methods: &#123;5 handleTap()&#123;6 var myEventDetail = &#123;&#125; // 传递出的数据 detail对象，可在事件对象event.detail中获取7 this.triggerEvent('myevent', myEventDetail) // 自定义事件名称 传递出的数据8 &#125;9 &#125;10&#125;) 1&lt;!-- test page wxml --&gt;2&lt;view class=\"container\"&gt;3 &lt;test-list test-text=\"这是一段测试文本\" bind:myevent=\"onMyEvent\"&gt;&lt;/test-list&gt;4&lt;/view&gt; 1// pages/test/test.js2Page(&#123;3 onMyEvent(event) &#123;4 console.log(event.detail)5 &#125;6&#125;) 父组件可通过this.selectComponent，获取子组件的实例，进而传递数据。1&lt;!-- 添加选择器 class=\"test-list\" --&gt;2&lt;view class=\"container\"&gt;3 &lt;test-list class=\"test-list\" bind:myevent=\"onMyEvent\"&gt;&lt;/test-list&gt;4&lt;/view&gt; 1// pages/test/test.js2Page(&#123;3 onMyEvent(event) &#123;4 // 获取test-list组件实例5 const child = this.selectComponent('.test-list')6 console.log('child', child)7 &#125;8&#125;) 组件间通讯与事件 组件生命周期 组件上生命周期lifetimes1Component(&#123;2 lifetimes: &#123;3 created: function () &#123;4 // 组件实例刚刚被创建好时5 &#125;,6 attached: function() &#123;7 // 在组件实例进入页面节点树时执行8 &#125;,9 detached: function() &#123;10 // 在组件实例被从页面节点树移除时执行11 &#125;12 // ...13 &#125;14&#125;) created &nbsp; 组件实例刚刚被创建好时， created 生命周期被触发。此时，组件数据 this.data 就是在 Component 构造器中定义的数据 data 。 此时还不能调用 setData 。 通常情况下，这个生命周期只应该用于给组件 this 添加一些自定义属性字段。attached &nbsp; 在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。detached &nbsp; 在组件离开页面节点树后， detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 detached 会被触发。 组件所在页面的生命周期1Component(&#123;2 pageLifetimes: &#123;3 show: function() &#123;4 // 页面被展示5 &#125;,6 hide: function() &#123;7 // 页面被隐藏8 &#125;,9 resize: function(size) &#123;10 // 页面尺寸变化11 &#125;12 &#125;13&#125;) 组件生命周期 数据监听 数据监听器可以用于监听和响应任何属性和数据字段的变化。 监听字段1Component(&#123;2 observers: &#123;3 \"value\": function (newValue) &#123;4 console.log('newValue', newValue)5 console.log(newValue === this.data.value) // true6 &#125;7 &#125;8&#125;) value在 setData 设置时 触发多个字段触发时用，拼接。例如 ‘numberA, numberB’: function(numberA, numberB) {} 通配符 **1Component(&#123;2 observers: &#123;3 'obj.**': function (obj) &#123;4 console.log('obj', obj)5 &#125;6 &#125;7&#125;) obj对象中的某个字段或者obj被 etData 设置时 触发数据监听observers","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"常用设计模式二","slug":"technical/technical06","date":"2022-02-14T16:00:00.000Z","updated":"2023-10-20T04:14:24.105Z","comments":true,"path":"2022/02/15/technical/technical06/","link":"","permalink":"http://yoursite.com/2022/02/15/technical/technical06/","excerpt":"","text":"代理模式 主要对单一原则事件进行代理，一般会处理事件的触发条件、触发时机，或者对计算结果的缓存。 1&#x2F;&#x2F; 图片 loading 加载2var myImage &#x3D; (function () &#123;3 var imageNode &#x3D; document.createElement(&#39;img&#39;)4 document.body.appendChild(imageNode)5 return &#123;6 setSrc: function (src) &#123;7 imageNode.src &#x3D; src8 &#125;9 &#125;10&#125;)()1112var proxyImage &#x3D; (function () &#123;13 var img &#x3D; new Image()14 img.onload &#x3D; function () &#123;15 myImage.setSrc(this.src)16 &#125;17 return &#123;18 setSrc: function (src) &#123;19 myImage.setSrc(&#39;.&#x2F;loading.png&#39;)20 img.src &#x3D; src21 &#125;22 &#125;23&#125;)()2425proxyImage.setSrc(&#39;https:&#x2F;&#x2F;cdn9-banquan.ituchong.com&#x2F;weili&#x2F;l&#x2F;882636893449224308.webp&#39;) 1&#x2F;&#x2F; 计算结果缓存2var mult &#x3D; function () &#123;3 var a &#x3D; 14 for (var i &#x3D; 0; i &lt; arguments.length; i++) &#123;5 a &#x3D; a * arguments[i]6 &#125;7 return a8&#125;910var proxyMult &#x3D; (function () &#123;11 var cache &#x3D; &#123;&#125;12 return function () &#123;13 var args &#x3D; Array.prototype.join.call(arguments, &#39;,&#39;)14 if (cache[args]) &#123;15 return cache[args]16 &#125;17 return (cache[args] &#x3D; mult.apply(this, arguments))18 &#125;19&#125;)() 迭代器模式 提供一种方法顺序访问的一个方法 1&#x2F;&#x2F; 文件切片2var getSingle &#x3D; function (fn) &#123;3 var result &#x3D; null4 return function () &#123;5 return result || (result &#x3D; fn.apply(this, arguments))6 &#125;7&#125;89var createFileInput &#x3D; function () &#123;10 var input &#x3D; document.createElement(&#39;input&#39;)11 input.setAttribute(&#39;type&#39;, &#39;file&#39;)12 document.body.appendChild(input)13 return input14&#125;1516var createSingleFileInput &#x3D; getSingle(createFileInput)17var fileInput &#x3D; createSingleFileInput()18var fileIterator &#x3D; null1920fileInput.onchange &#x3D; function () &#123;21 var file &#x3D; this.files[0]22 var chunkSize &#x3D; 1024 * 1024; &#x2F;&#x2F; 分片大小 1M23 fileIterator &#x3D; new FileSliceIterator(file, chunkSize)24&#125;2526var FileSliceIterator &#x3D; function (file, chunkSize) &#123;27 var start &#x3D; 028 var end &#x3D; chunkSize29 var next &#x3D; function () &#123;30 start +&#x3D; chunkSize31 end +&#x3D; chunkSize32 &#125;33 var isDone &#x3D; function () &#123;34 return start &gt;&#x3D; file.size35 &#125;36 var getCurrItem &#x3D; function () &#123;37 return file.slice(start, end)38 &#125;39 return &#123;40 next: next,41 isDone: isDone,42 getCurrItem: getCurrItem,43 &#125;44&#125;4546var uploadFile &#x3D; function () &#123;47 while (!fileIterator.isDone()) &#123;48 console.log(&#39;fileIterator.getCurrItem()&#39;, fileIterator.getCurrItem())49 fileIterator.next()50 &#125;51&#125;","categories":[{"name":"技术点","slug":"技术点","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%82%B9/"}],"tags":[{"name":"技术点","slug":"技术点","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%82%B9/"}]},{"title":"微前端初体验","slug":"configuration/configuration06","date":"2022-02-07T16:00:00.000Z","updated":"2023-10-20T04:10:27.041Z","comments":true,"path":"2022/02/08/configuration/configuration06/","link":"","permalink":"http://yoursite.com/2022/02/08/configuration/configuration06/","excerpt":"","text":"微前端理解 微前端就是将不同的功能按照不同的维度拆分成多个子应用。通过主应用来加载这些子应用。微前端的核心在于拆, 拆完后在合 https://github.com/Shenjieping/micro-app 组成结构 qiankun架构为例，以一个基座（MainApp）应用和若干个微（MicroApp）应用 qiankun基座构建 安装 qiankun1yarn add qiankun # 或者 npm i qiankun -S 主应用中注册微应用1import &#123; registerMicroApps, start &#125; from &#39;qiankun&#39;;23registerMicroApps([4 &#123;5 name: &#39;react app&#39;, &#x2F;&#x2F; app name registered6 entry: &#39;&#x2F;&#x2F;localhost:7100&#39;,7 container: &#39;#yourContainer&#39;,8 activeRule: &#39;&#x2F;yourActiveRule&#39;,9 &#125;,10 &#123;11 name: &#39;vue app&#39;,12 entry: &#123; scripts: [&#39;&#x2F;&#x2F;localhost:7100&#x2F;main.js&#39;] &#125;,13 container: &#39;#yourContainer2&#39;,14 activeRule: &#39;&#x2F;yourActiveRule2&#39;,15 &#125;,16]);1718start(); qiankun官网说明 子应用注册 导出相应的生命周期钩子 1function render()&#123;2 ReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#39;root&#39;));3&#125;45&#x2F;&#x2F; 独立运行微应用6if(!window.__POWERED_BY_QIANKUN__)&#123;7 render();8&#125;910&#x2F;&#x2F; bootstrap 只会在微应用初始化的时候调用一次11export async function bootstrap()&#123;1213&#125;1415&#x2F;&#x2F; 应用每次进入调用 mount16export async function mount() &#123;17 render()18&#125;1920&#x2F;&#x2F; 应用每次 切出&#x2F;卸载 会调用 unmount21export async function unmount()&#123;22 ReactDOM.unmountComponentAtNode( document.getElementById(&#39;root&#39;));23&#125; qiankun官网说明 配置微应用的打包工具 1&#x2F;&#x2F; 指定模块的暴露方式2output: &#123;3 library: &#39;vueApp&#39;,4 libraryTarget: &#39;umd&#39;5&#125; 1&#x2F;&#x2F; 解决图片等静态资源路径错误2publicPath: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &quot;production&quot; ? &#39;http:&#x2F;&#x2F;api.com&#39; : &#96;http:&#x2F;&#x2F;localhost:$&#123;port&#125;&#96;; 1&#x2F;&#x2F; 解决访问路径跨域2headers:&#123;3 &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39; &#x2F;&#x2F; 允许跨域4&#125; ……qiankun官网说明","categories":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}]},{"title":"常用git操作","slug":"technical/technical05","date":"2022-01-27T16:00:00.000Z","updated":"2023-10-20T04:14:07.897Z","comments":true,"path":"2022/01/28/technical/technical05/","link":"","permalink":"http://yoursite.com/2022/01/28/technical/technical05/","excerpt":"","text":"查看分支1git branch (查看本地分支)2git branch -r (查看远程分支) 查看日志1git reflog (查看操作日志) 1git log2git log --oneline -10 (查看10行单行简洁日志)3git log --oneline --graph -10 (查看10行单行简洁拓扑图日志) 1git status 创建分支1git checkout (切换分支)2git checkout -b new_branch (基于当前命令所在分支创建分支)3git checkout -b new_branch origin&#x2F;master (基于远程master创建新分支)4git push origin branch_name (本地分支推送到远程分支) 删除分支1git branch -d branch_name (删除本地分支)2git push origin -d branch_name (删除远程分支) 获取代码1git clone 2git fetch (将远程厂库信息更新至本地)3git pull (将远程信息更新至本地并进行代码合并操作 等同于 git fetch + git merge) 提交代码1git add .2git commit -m &#39;备注&#39;3git fetch4git rebase &#x2F; git merge5git push origin master 追加提交1git add .2git commit --amend3git push origin master --force 代码合并1git merge branch (目标分支合并至当前分支，当前分支再合并到目标分支) 1git rebase branch_name (目标分支合并至当前分支)2rebase 冲突解决3 1.解决冲突4 2.git add .5 3.git rebase --continue6rebase 取消7 git rebase --abort 1git cherry-pick log_hash (把对应提交检出合并至当前分支)2cherry-pick 冲突解决3 1.解决冲突4 2.git add .5 3.git cherry-pick --continue6cherry-pick 取消7 git cherry-pick --abort 提交合并1git rebase -i HEAD~3 (合并最近3次提交)2vm 修改操作 (pick正常选中, squash选中将当前commit与上一个commit合并)3vm 编辑commit信息 (删除修改合并信息) 重置代码1git fetch origin2git reset --hard origin&#x2F;master 代码暂存1git stash &#x2F; git stash save stash_name (将所有未提交的修改（工作区和暂存区）保存至堆栈中)2git stash list (查看当前stash中的内容)3git stash pop (将当前stash中的内容取回)","categories":[{"name":"技术点","slug":"技术点","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%82%B9/"}],"tags":[{"name":"技术点","slug":"技术点","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%82%B9/"}]},{"title":"常用设计模式一","slug":"technical/technical04","date":"2021-10-21T16:00:00.000Z","updated":"2023-10-20T04:13:53.487Z","comments":true,"path":"2021/10/22/technical/technical04/","link":"","permalink":"http://yoursite.com/2021/10/22/technical/technical04/","excerpt":"","text":"单例模式 单：单一例：实例一个构造函数一生只能有一个实例。 1var Store &#x3D; (function () &#123;2 class Store &#123;3 constructor() &#123;4 this.state &#x3D; Object.create(&#123;&#125;);5 &#125;6 setState &#x3D; (data) &#x3D;&gt; &#123;7 this.state &#x3D; &#123; ...this.state, ...data &#125;;8 &#125;;9 getState &#x3D; () &#x3D;&gt; &#123;10 return this.state;11 &#125;;12 &#125;1314 let instance &#x3D; null;15 return function (...arg) &#123;16 if (!instance) instance &#x3D; new Store(...arg);17 return instance18 &#125;;19&#125;)();20var s1 &#x3D; new Store(); 惰性单例 1var getSingle &#x3D; function( fn )&#123; 2 var result; 3 return function()&#123; 4 return result || ( result &#x3D; fn .apply(this, arguments ) ); 5 &#125; 6&#125;;78var createLoginLayer &#x3D; function()&#123; 9 var div &#x3D; document.createElement( &#39;div&#39; ); 10 div.innerHTML &#x3D; &#39;我是登录浮窗&#39;; 11 div.style.display &#x3D; &#39;none&#39;; 12 document.body.appendChild( div ); 13 return div; 14&#125;; 1516var createSingleLoginLayer &#x3D; getSingle( createLoginLayer ); 1718document.getElementById( &#39;loginBtn&#39; ).onclick &#x3D; function()&#123; 19 var loginLayer &#x3D; createSingleLoginLayer(); 20 loginLayer.style.display &#x3D; &#39;block&#39;; 21&#125;; 观察者模式 观察者：需要具备自身标识，与相应事件被观察者：需要具备状态、修改状态方法、观察事件队列、添加观察者、移除观察者观察者监控被观察者的状态，状态发生变化，触发相应事件。 1&#x2F;&#x2F; 观察者构造函数2class Observer &#123;3 constructor(name, fn &#x3D; function () &#123;&#125;) &#123;4 this.name &#x3D; name;5 this.fn &#x3D; fn;6 &#125;7&#125;89&#x2F;&#x2F; 创建两个观察者10const eat &#x3D; new Observer(&quot;eat&quot;, (state) &#x3D;&gt; &#123; console.log(&#96;$&#123;state&#125;: 吃饭&#96;) &#125;);11const drink &#x3D; new Observer(&quot;drink&quot;, (state) &#x3D;&gt; &#123; console.log(&#96;$&#123;state&#125;: 喝水&#96;) &#125;);1213&#x2F;&#x2F; 被观察者构造函数14class Subject&#123;15 constructor(state)&#123;16 &#x2F;&#x2F; 记录状态17 this.state &#x3D; state18 &#x2F;&#x2F; 保存观察者19 this.observers &#x3D; []20 &#125;2122 &#x2F;&#x2F; 修改状态23 setState(val)&#123;24 this.state &#x3D; val2526 &#x2F;&#x2F; 触发观察者事件27 this.observers.forEach((item) &#x3D;&gt; &#123;28 item.fn(this.state)29 &#125;)30 &#125;3132 &#x2F;&#x2F; 添加观察者33 addObserver(obs)&#123;34 this.observers &#x3D; this.observers.filter((item) &#x3D;&gt; item !&#x3D;&#x3D; obs)35 this.observers.push(obs)36 &#125;3738 &#x2F;&#x2F; 删除观察者39 delObserver(obs)&#123;40 this.observers &#x3D; this.observers.filter((item) &#x3D;&gt; item !&#x3D;&#x3D; obs)41 &#125;42&#125;4344const p &#x3D; new Subject(&#39;中午&#39;)45p.addObserver(eat)46p.addObserver(drink) 发布订阅模式 订阅：对事件进行订阅，事件发生时执行订阅发布：触发对应类型事件 1class Observer &#123;2 constructor() &#123;3 &#x2F;&#x2F; 消息队列4 this.message &#x3D; &#123;&#125;;5 &#125;67 &#x2F;&#x2F; 添加消息队列8 on(type, fn) &#123;9 if (!this.message[type]) this.message[type] &#x3D; [];10 this.message[type].push(fn);11 &#125;1213 &#x2F;&#x2F; 移除消息队列14 off(type, fn) &#123;15 if (!fn) return delete this.message[type];1617 if (!this.message[type]) return;18 this.message[type] &#x3D; this.message[type].filter((item) &#x3D;&gt; item !&#x3D;&#x3D; fn);19 &#125;2021 &#x2F;&#x2F; 触发消息队列22 emit(type, val) &#123;23 if (!this.message[type]) return;24 this.message[type].forEach((item) &#x3D;&gt; &#123;25 item(val);26 &#125;);27 &#125;28&#125; 策略模式 一个问题有多中方案解决，未来可能还会有新的方案 1var calcPrice &#x3D; (function () &#123;2 &#x2F;&#x2F; 优惠卷3 const coupons &#x3D; &#123;4 &quot;100_10&quot;:function(price)&#123; return price - 10 &#125;,5 &quot;200_25&quot;:function(price)&#123; return price - 20 &#125;6 &#125;78 const calcPrice &#x3D; function (price,type) &#123;9 &#x2F;&#x2F; 优惠卷不存在10 if (!coupons[type]) return false1112 return coupons[type](price)13 &#125;1415 &#x2F;&#x2F; 添加策略16 calcPrice.add &#x3D; (type,fn&#x3D;function()&#123; &#125;) &#x3D;&gt; &#123;17 &#x2F;&#x2F; 策略已存在18 if (coupons[type]) return 1920 coupons[type] &#x3D; fn21 &#125;22 23 return calcPrice24&#125;)()2526&#x2F;&#x2F; 添加优惠卷27calcPrice.add(&#39;200_15&#39;,(price) &#x3D;&gt; &#123; return price - 15 &#125;)28console.log(&#39;calcPrice :&gt;&gt; &#39;, calcPrice(320,&#39;200_15&#39;));","categories":[{"name":"技术点","slug":"技术点","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%82%B9/"}],"tags":[{"name":"技术点","slug":"技术点","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%82%B9/"}]},{"title":"request封装","slug":"react/react11","date":"2021-09-25T16:00:00.000Z","updated":"2023-10-20T06:07:03.036Z","comments":true,"path":"2021/09/26/react/react11/","link":"","permalink":"http://yoursite.com/2021/09/26/react/react11/","excerpt":"","text":"整体结构 axios 安装1yarn add axios 流程结构 功能实现1.接口重复请求配置2.请求loading配置3.数据返回配置4.异常处理 axios实例配置 基本配置1function request(axiosConfig, customOptions) &#123;2 &#x2F;&#x2F; axios参数配置3 const service &#x3D; axios.create(&#123;4 baseURL: config.baseApi, &#x2F;&#x2F; 设置统一的请求前缀5 timeout: 6000, &#x2F;&#x2F; 设置统一的超时时长6 headers: &#123;7 &quot;Content-Type&quot;: &quot;application&#x2F;json&quot;,8 &#125;,9 &#125;);1011 &#x2F;&#x2F; 自定义配置12 let custom_options &#x3D; Object.assign(13 &#123;14 repeat_request_cancel: true, &#x2F;&#x2F; 是否开启取消重复请求, 默认为 true15 loading: false, &#x2F;&#x2F; 是否开启loading层效果, 默认为false16 reduct_data_format: true, &#x2F;&#x2F; 是否开启简洁的数据结构响应, 默认为true17 error_message_show: true, &#x2F;&#x2F; 是否开启接口错误信息展示,默认为true18 &#125;,19 customOptions20 );2122 &#x2F;&#x2F; 请求拦截器23 service.interceptors.request.use(24 (config) &#x3D;&gt; &#123;25 &#x2F;&#x2F; 请求前若当前请求存在先移除26 return config;27 &#125;,28 (error) &#x3D;&gt; &#123;29 return Promise.reject(error);30 &#125;31 );3233 &#x2F;&#x2F; 响应拦截器34 service.interceptors.response.use(35 (response) &#x3D;&gt; &#123;36 return custom_options.reduct_data_format ? response.data : response; &#x2F;&#x2F; 根据条件获取参数信息37 &#125;,38 (error) &#x3D;&gt; &#123;39 return Promise.reject(error);40 &#125;41 );4243 return service(axiosConfig);44&#125;45export default request; 封装请求方法request，一共分为4个模块axios参数配置、自定义功能配置、请求拦截器、响应拦截器。 防止重复请求 基本流程 pendingMap1import axios from &quot;axios&quot;;2const pendingMap &#x3D; new Map();3&#x2F;&#x2F; 生成每个请求唯一的键4function getPendingKey(config) &#123;5 let &#123; url, method, params, data &#125; &#x3D; config;6 if (typeof data &#x3D;&#x3D;&#x3D; &quot;string&quot;) data &#x3D; JSON.parse(data); &#x2F;&#x2F; response里面返回的config.data是个字符串对象7 return [url, method, JSON.stringify(params), JSON.stringify(data)].join(&quot;&amp;&quot;);8&#125;9&#x2F;&#x2F; 储存每个请求唯一值, 也就是cancel()方法, 用于取消请求10export function addPending(config) &#123;11 const pendingKey &#x3D; getPendingKey(config);12 config.cancelToken &#x3D;13 config.cancelToken ||14 new axios.CancelToken((cancel) &#x3D;&gt; &#123;15 if (!pendingMap.has(pendingKey)) &#123;16 pendingMap.set(pendingKey, cancel);17 &#125;18 &#125;);19&#125;20&#x2F;&#x2F; 删除重复的请求21export function removePending(config) &#123;22 const pendingKey &#x3D; getPendingKey(config);23 if (pendingMap.has(pendingKey)) &#123;24 const cancelToken &#x3D; pendingMap.get(pendingKey);25 cancelToken(pendingKey);26 pendingMap.delete(pendingKey);27 &#125;28&#125; pendingMap 数组结构实现","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React项目搭建","slug":"react/react08","date":"2021-09-22T16:00:00.000Z","updated":"2023-10-20T06:06:22.489Z","comments":true,"path":"2021/09/23/react/react08/","link":"","permalink":"http://yoursite.com/2021/09/23/react/react08/","excerpt":"","text":"基本模块 通过基本的脚手架及环境配置、项目构建配置、数据管理、请求拦截器、配置路由及鉴权...构建基本的项目框架 脚手架模板 构建基本ts react模板 1npx create-react-app my-app --template typescript ts 配置 1&#123;2 &quot;compilerOptions&quot;: &#123;3 &quot;target&quot;: &quot;es5&quot;, &#x2F;&#x2F;编译后目标js版本4 &quot;lib&quot;: [5 &quot;dom&quot;,6 &quot;dom.iterable&quot;,7 &quot;esnext&quot;8 ],9 &quot;noImplicitAny&quot;: true, &#x2F;&#x2F;不需要显示的声明变量any10 &quot;allowJs&quot;: true, &#x2F;&#x2F;允许混合编译js文件11 &quot;skipLibCheck&quot;: true,12 &quot;esModuleInterop&quot;: true, &#x2F;&#x2F;允许使用commonJs的方式import默认文件,import React from &#39;react13 &quot;allowSyntheticDefaultImports&quot;: true,14 &quot;strict&quot;: true,15 &quot;forceConsistentCasingInFileNames&quot;: true,16 &quot;noFallthroughCasesInSwitch&quot;: true,17 &quot;module&quot;: &quot;esnext&quot;,18 &quot;moduleResolution&quot;: &quot;node&quot;,19 &quot;resolveJsonModule&quot;: true,20 &quot;isolatedModules&quot;: true,21 &quot;noEmit&quot;: true,22 &quot;jsx&quot;: &quot;react-jsx&quot;23 &#125;,24 &quot;include&quot;: [25 &quot;src&quot;26 ]27&#125; global.d.ts定义全局变量、函数、接口 react-app-env.d.ts项目编译时将会根据tsconfig.json中include指定的目录去找代码所需要的类型声明文件，而react-app-env.d.ts会告诉编译器含有哪些类型声明，里面含有一些常用的类型声明，比如react、react-dom的一些API类型声明，图片、样式模块类型声明等等 项目模块 全局数据管理-redux react-router react-router-dom配置路由及鉴权 customize-cra项目构建配置 request封装","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React配置路由及鉴权","slug":"react/react09","date":"2021-09-22T16:00:00.000Z","updated":"2023-10-20T06:06:36.761Z","comments":true,"path":"2021/09/23/react/react09/","link":"","permalink":"http://yoursite.com/2021/09/23/react/react09/","excerpt":"","text":"路由配置 安装1yarn add react-router react-router-dom 实现 参数配置路由 约定路由数据结构1interface RouteItemMetaType &#123;2 permissions: string[]; &#x2F;&#x2F; 路由权限3 hide?: boolean; &#x2F;&#x2F; 是否隐藏菜单4 [key: string]: any;5&#125;6interface RouteItemType &#123;7 path: string; &#x2F;&#x2F; 路由路径8 component?: LazyExoticComponent&lt;any&gt;; &#x2F;&#x2F; lazy 组件9 render?: () &#x3D;&gt; any; &#x2F;&#x2F; route render10 routes?: RouteItemType[]; &#x2F;&#x2F; 二级菜单11 name?: string; &#x2F;&#x2F; 路由名称12 exact?: boolean;13 strict?: boolean;14 meta?: RouteItemMetaType;15 [key: string]: any;16&#125;17const routes: RouteItemType[] &#x3D; [18 &#123;19 path: &quot;&#x2F;manage&quot;,20 component: lazy(() &#x3D;&gt; import(&quot;..&#x2F;pages&#x2F;manage&#x2F;ManageLayout&quot;)),21 routes: [22 &#123;23 path: &quot;&#x2F;manage&#x2F;user&quot;,24 title: &quot;用户&quot;,25 meta: &#123;26 permissions: [&quot;KEY1&quot;, &quot;KEY2&quot;],27 &#125;,28 component: lazy(() &#x3D;&gt; import(&quot;..&#x2F;pages&#x2F;manage&#x2F;user&#x2F;UserLayout&quot;)),29 routes: [30 &#123;31 path: &quot;&#x2F;manage&#x2F;user&#x2F;index&quot;,32 title: &quot;用户&quot;,33 component: lazy(() &#x3D;&gt; import(&quot;..&#x2F;pages&#x2F;manage&#x2F;user&#x2F;index&#x2F;index&quot;)),34 meta: &#123;35 permissions: [&quot;KEY1&quot;],36 &#125;,37 &#125;,38 ],39 &#125;,40 ],41 &#125;42]; 根据路由配置参数动态生成路由树1import React, &#123; Suspense &#125; from &quot;react&quot;;2import &#123; Switch, Route &#125; from &quot;react-router-dom&quot;;3function RenderRoutes(props: any) &#123;4 const &#123; routes, extraProps &#x3D; &#123;&#125;, switchProps &#x3D; &#123;&#125; &#125; &#x3D; props;5 const mapFunc &#x3D; (routes: any) &#x3D;&gt; &#123;6 return routes.map((route: any) &#x3D;&gt; &#123;7 if (route.routes &amp;&amp; route.routes.length &gt; 0) &#123;8 &#x2F;&#x2F; 存在二级菜单9 return (10 &lt;Route11 key&#x3D;&#123;route.path&#125;12 path&#x3D;&#123;route.path&#125;13 exact&#x3D;&#123;route.exact&#125;14 strict&#x3D;&#123;route.strict&#125;15 render&#x3D;&#123;() &#x3D;&gt; &#123;16 return (17 &lt;Suspense fallback&#x3D;&#123;null&#125;&gt;18 &lt;Switch&gt;19 &#123;React.createElement(route.component,&#123;&#125;,mapFunc(route.routes))&#125;20 &lt;&#x2F;Switch&gt;21 &lt;&#x2F;Suspense&gt;22 );23 &#125;&#125;24 &#x2F;&gt;25 );26 &#125; else &#123;27 &#x2F;&#x2F; 只存在一个路由28 return (29 &lt;Route30 key&#x3D;&#123;route.path&#125;31 path&#x3D;&#123;route.path&#125;32 exact&#x3D;&#123;route.exact&#125;33 strict&#x3D;&#123;route.strict&#125;34 render&#x3D;&#123;(props) &#x3D;&gt; (35 &lt;Suspense fallback&#x3D;&#123;null&#125;&gt;36 &#123;route.render ? 37 (route.render(&#123; ...props, ...extraProps, route: route &#125;)) : 38 (&lt;route.component &#123;...props&#125; &#123;...extraProps&#125; route&#x3D;&#123;route&#125;&gt;&lt;&#x2F;route.component&gt;)&#125;39 &lt;&#x2F;Suspense&gt;40 )&#125;41 &#x2F;&gt;42 );43 &#125;44 &#125;);45 &#125;;46 return routes ? &lt;Switch &#123;...switchProps&#125;&gt;&#123;mapFunc(routes)&#125;&lt;&#x2F;Switch&gt; : null;47&#125;48export default RenderRoutes; 鉴权配置 鉴权流程 登录鉴权1import React, &#123; useMemo &#125; from &#39;react&#39;2import &#123; connect &#125; from &#39;react-redux&#39;3import &#123; Redirect &#125; from &#39;react-router-dom&#39;4const routeWhiteList &#x3D; [&#39;&#x2F;login&#39;, &#39;&#x2F;404&#39;, &#39;&#x2F;test&#39;]5const LoginAuth &#x3D; props &#x3D;&gt; &#123;6 const &#123; token, path, children &#125; &#x3D; props7 const isLogin &#x3D; useMemo(() &#x3D;&gt; &#123;8 if (token) &#123;9 return true10 &#125; else if (routeWhiteList.includes(path)) &#123;11 return true12 &#125; else &#123;13 return false14 &#125;15 &#125;, [path, token])16 return isLogin ? &lt;&gt;&#123;children&#125;&lt;&#x2F;&gt; : &lt;Redirect to&#x3D;&quot;&#x2F;login&quot; &#x2F;&gt;17&#125;18export default connect(function mapStateToProps(state: any) &#123;19 return &#123;20 token: state.globalUserinfo.token21 &#125;22&#125;)(LoginAuth) 路由鉴权1import React, &#123; useMemo &#125; from &#39;react&#39;2import &#123; connect &#125; from &#39;react-redux&#39;3import &#123; Redirect &#125; from &#39;react-router-dom&#39;4const RouterAuth &#x3D; props &#x3D;&gt; &#123;5 const &#123; authKeys, permissions &#x3D; [], children &#125; &#x3D; props6 const isPermissions &#x3D; useMemo(() &#x3D;&gt; &#123;7 &#x2F;&#x2F; 路由中不配置权限，默认存在权限8 if (!authKeys || authKeys.length &#x3D;&#x3D;&#x3D; 0) &#123;9 return true10 &#125; else &#123;11 &#x2F;&#x2F; 权限校验12 return permissions.some(role &#x3D;&gt; &#123;13 return authKeys.includes(role)14 &#125;)15 &#125;16 &#125;, [authKeys, permissions])17 return isPermissions ? &lt;&gt;&#123;children&#125;&lt;&#x2F;&gt; : &lt;Redirect to&#x3D;&quot;&#x2F;404&quot; &#x2F;&gt;18&#125;19export default connect(function mapStateToProps(state: any) &#123;20 return &#123;21 permissions: state.globalUserinfo.premissions22 &#125;23&#125;)(RouterAuth)","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"customize-cra项目配置","slug":"react/react10","date":"2021-09-22T16:00:00.000Z","updated":"2023-10-20T06:06:51.716Z","comments":true,"path":"2021/09/23/react/react10/","link":"","permalink":"http://yoursite.com/2021/09/23/react/react10/","excerpt":"","text":"基本安装配置 安装1yarn add react-app-rewired customize-cra -D 修改package.json的启动配置1&quot;scripts&quot;: &#123;2 &quot;start&quot;: &quot;react-app-rewired start&quot;,3 &quot;build&quot;: &quot;react-app-rewired build&quot;,4 &quot;test&quot;: &quot;react-app-rewired test&quot;,5 &quot;eject&quot;: &quot;react-scripts eject&quot;6&#125; 根目录下创建config-overrides.js文件主要的打包构建配置文件，覆盖webpack的配置 文档地址customize-cra配置 常规配置 addWebpackAlias 别名配置1const path &#x3D; require(&#39;path&#39;)2const resolve &#x3D; dir &#x3D;&gt; path.join(__dirname, dir)3&#x2F;&#x2F; ...4addWebpackAlias(&#123;5 &#39;@&#x2F;&#39;: resolve(&#39;src&#39;),6 &#x2F;&#x2F; ...7&#125;) fixBabelImports 按需加载1&#x2F;&#x2F; 包分析工具2yarn add babel-plugin-import -D 1&#x2F;* 按需引入 antd *&#x2F;2fixBabelImports(&#39;antd&#39;, &#123; 3 libraryDirectory: &#39;es&#39;, 4 style: &#39;css&#39; 5&#125;), 1&#x2F;* 按需引入 antd-mobile *&#x2F;2fixBabelImports(&#39;import&#39;, &#123;3 libraryName: &#39;antd-mobile&#39;,4 style: &#39;css&#39;5&#125;), 1&#x2F;* 按需引入lodash *&#x2F;2fixBabelImports(&quot;lodash&quot;, &#123;3 libraryDirectory: &quot;&quot;,4 camel2DashComponentName: false5&#125;), 移动适配1yarn add postcss-px2rem-exclude lib-flexible 1(config, env) &#x3D;&gt; &#123;2 &#x2F;&#x2F; 重写postcss3 rewirePostcss(config, &#123;4 plugins: ctx &#x3D;&gt; &#123;5 const isNormalDpr &#x3D; &#x2F;\\.css$&#x2F;.test(ctx.resourcePath) &amp;&amp; &#x2F;\\bantd-mobile\\b&#x2F;.test(ctx.resourcePath)6 return [7 require(&#39;postcss-flexbugs-fixes&#39;),8 require(&#39;postcss-preset-env&#39;)(&#123;9 autoprefixer: &#123;10 flexbox: &#39;no-2009&#39;11 &#125;,12 stage: 313 &#125;),14 require(&#39;postcss-px2rem-exclude&#39;)(&#123;15 remUnit: isNormalDpr ? 37.5 : 7516 &#125;),17 require(&#39;postcss-normalize&#39;)()18 ]19 &#125;20 &#125;)21 return config22&#125; 项目构建配置 依赖分析工具1yarn add webpack-bundle-analyzer 1const &#123; BundleAnalyzerPlugin &#125; &#x3D; require(&#39;webpack-bundle-analyzer&#39;) 1addWebpackPlugin(2 new BundleAnalyzerPlugin(&#123;3 analyzerMode: &#39;static&#39; &#x2F;&#x2F;输出静态报告文件report.html，而不是启动一个web服务4 &#125;)5) gzip文件压缩1yarn add compression-webpack-plugin@5.0.1 1const CompressionPlugin &#x3D; require(&#39;compression-webpack-plugin&#39;) &#x2F;&#x2F; gzip 压缩 (5.0.1版本)2const productionGzipExtensions &#x3D; &#x2F;\\.(js|css|json|txt|html|ico|svg)(\\?.*)?$&#x2F;i 1addWebpackPlugin(2 new CompressionPlugin(&#123;3 filename: &#39;[path].gz[query]&#39;,4 algorithm: &#39;gzip&#39;,5 test: productionGzipExtensions, &#x2F;&#x2F; 匹配文件名6 threshold: 10240, &#x2F;&#x2F; 对超过 10k 数据压缩7 minRatio: 0.8,8 deleteOriginalAssets: false &#x2F;&#x2F; true-删除原文件 false-不删除源文件9 &#125;)10), setWebpackOptimizationSplitChunks 代码分离spilt1setWebpackOptimizationSplitChunks(&#123;2 chunks: &#39;all&#39;,3 cacheGroups: &#123;4 &#x2F;&#x2F; reactDom: &#123;5 &#x2F;&#x2F; test: &#x2F;[\\\\&#x2F;]node_modules[\\\\&#x2F;]_?react\\-dom(.*)&#x2F;, &#x2F;&#x2F; 兼容cnpm 情况6 &#x2F;&#x2F; name: &#39;react-dom&#39;,7 &#x2F;&#x2F; chunks: &#39;initial&#39;,8 &#x2F;&#x2F; minChunks: 1,9 &#x2F;&#x2F; minSize: 0,10 &#x2F;&#x2F; priority: 3,11 &#x2F;&#x2F; reuseExistingChunk: true12 &#x2F;&#x2F; &#125;,13 libs: &#123;14 &#x2F;&#x2F; 拆分第三方库（通过npm|yarn安装的库）15 test: &#x2F;[\\\\&#x2F;]node_modules[\\\\&#x2F;]&#x2F;,16 name: &#39;chunk-libs&#39;,17 chunks: &#39;initial&#39;,18 priority: 119 &#125;20 &#125;21&#125;), cacheGroups 分包文章","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React redux","slug":"react/react02","date":"2021-08-09T16:00:00.000Z","updated":"2023-10-20T06:04:31.772Z","comments":true,"path":"2021/08/10/react/react02/","link":"","permalink":"http://yoursite.com/2021/08/10/react/react02/","excerpt":"","text":"redux介绍 redux 为状态管理厂库，主要解决在复杂场景下的数据管理 应用场景 全局状态管理，针对整个系统做数据管理。 单个路由页面，多级组件通讯 对多个 alive 页面做状态管理 核心思想 安装1yarn add redux react-redux redux-thunk 配置redux createStore 创建仓库 1import &#123; createStore &#125; from \"redux\";2const store = createStore(); // 引入 redux 厂库3export default store; Provider 容器提供页面消费（一般在根组件下处理） 1import &#123; Provider &#125; from \"react-redux\";2import store from \"./store\";3import TestPage from \"./pages/test\";4function App() &#123;5 return (6 &lt;div&gt;7 &lt;Provider store=&#123;store&#125;&gt;8 &lt;TestPage&gt;&lt;/TestPage&gt;9 &lt;/Provider&gt;10 &lt;/div&gt;11 );12&#125;13export default App; 仓库配置 state、reducer 及 异步action处理 1import &#123; createStore, combineReducers, applyMiddleware &#125; from \"redux\";2import thunk from \"redux-thunk\";3import globalUserinfoState from \"./states/globalUserinfo\";4import globalUserinfoReducer from \"./reducers/globalUserinfo\";5// 合并所有redux6const allReducers = combineReducers(&#123;7 globalUserinfo: globalUserinfoReducer,8&#125;);9const store = createStore(10 // 所有的事件11 allReducers,12 // 所有state13 &#123;14 globalUserinfo: globalUserinfoState,15 &#125;,16 // 异步处理17 applyMiddleware(thunk)18);19export default store; 路由消费 1import React from \"react\";2import &#123; connect &#125; from \"react-redux\";3import &#123; changeGlobalUserinfo &#125; from \"../../store/actions/globalUserinfo\";4const Test = (props) =&gt; &#123;5 const &#123; premissions, changeGlobalUserinfo &#125; = props;6 const handleClick = () =&gt; &#123;7 changeGlobalUserinfo(['123'])8 &#125;9 return (10 &lt;div&gt;11 &#123;JSON.stringify(premissions)&#125;12 &lt;hr /&gt;13 &lt;button onClick=&#123;handleClick&#125;&gt;点击测试&lt;/button&gt;14 &lt;/div&gt;15 );16&#125;;17export default connect(18 // state 映射到 props 中19 function mapStateToProps(state) &#123;20 return &#123;21 premissions: state.globalUserinfo.premissions,22 &#125;;23 &#125;,24 // reducer 映射到 props 中25 function mapDispathToProps(dispatch) &#123;26 return &#123;27 changeGlobalUserinfo: (payload) =&gt; dispatch(changeGlobalUserinfo(payload)),28 &#125;;29 &#125;30)(Test); redux Api state 创建1const globalUserinfoState = &#123;2premissions: [],3&#125;;4export default globalUserinfoState; 注册1import globalUserinfoState from \"./states/globalUserinfo\";2const store = createStore(3 allReducers,4 // 所有state5 &#123;6 globalUserinfo: globalUserinfoState,7 &#125;,8 applyMiddleware(thunk)9); 映射至页面props获取数据1export default connect(2 // state 映射到 props 中3 function mapStateToProps(state) &#123;4 return &#123;5 premissions: state.globalUserinfo.premissions,6 &#125;;7 &#125;,8 // reducer 映射到 props 中9 function mapDispathToProps(dispatch) &#123;10 return &#123;11 changeGlobalUserinfo: (payload) =&gt; dispatch(changeGlobalUserinfo(payload)),12 &#125;;13 &#125;14)(Test); store 对象全局获取1store.getState() reducer 创建1import initialState from \"../states/globalUserinfo\";2function globalUserinfoReducer(state = initialState, action) &#123;3 switch (action.type) &#123;4 case \"CHANGE_USERINFO\":5 return &#123;6 ...state,7 premissions: action.payload,8 &#125;;9 default:10 return state;11 &#125;12&#125;13export default globalUserinfoReducer; 注册1import globalUserinfoReducer from \"./reducers/globalUserinfo\";2// 合并所有redux3const allReducers = combineReducers(&#123;4 globalUserinfo: globalUserinfoReducer,5&#125;);6const store = createStore(7 allReducers, // 所有的事件8 &#123; globalUserinfo: globalUserinfoState &#125;,9 applyMiddleware(thunk)10); 映射至页面props获取数据1export default connect(2 // state 映射到 props 中3 function mapStateToProps(state) &#123;4 return &#123;5 premissions: state.globalUserinfo.premissions,6 &#125;;7 &#125;,8 // reducer 映射到 props 中9 function mapDispathToProps(dispatch) &#123;10 return &#123;11 // dispatch(action())12 changeGlobalUserinfo: (payload) =&gt; dispatch(changeGlobalUserinfo(payload)),13 &#125;;14 &#125;15)(Test); store 对象全局获取1store.dispatch(action('payload')); action 创建 1const CHANGE_USERINFO = \"CHANGE_USERINFO\";2// 同步方式3function changeGlobalUserinfo(payload) &#123;4 return &#123;5 type: CHANGE_USERINFO,6 payload,7 &#125;;8&#125;9export &#123; changeGlobalUserinfo &#125;; 1const CHANGE_USERINFO = \"CHANGE_USERINFO\";2// 异步处理方式3function changeGlobalUserinfo(payload) &#123;4 return async (dispatch) =&gt; &#123;5 return new Promise((resolve, reject) =&gt; &#123;6 setTimeout(() =&gt; &#123;7 dispatch(&#123;8 type: CHANGE_USERINFO,9 payload,10 &#125;);11 resolve();12 &#125;, 3000);13 &#125;);14 &#125;;15&#125;16export &#123; changeGlobalUserinfo &#125;; action 触发action由dispatch主动触发，不需要在store中注册","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"Recoil","slug":"react/react07","date":"2021-05-22T16:00:00.000Z","updated":"2023-10-20T06:06:06.498Z","comments":true,"path":"2021/05/23/react/react07/","link":"","permalink":"http://yoursite.com/2021/05/23/react/react07/","excerpt":"","text":"React 的状态管理库 Recoil。同 vuex redux … 功能类型对全局数据状态进行管理。 下载与文档 安装1npm install recoil recoil 文档地址https://www.recoiljs.cn/docs/introduction/getting-started RecoilRoot RecoilRoot 1import React from 'react';2import &#123;RecoilRoot, atom, selector, useRecoilState, useRecoilValue&#125; from 'recoil';3function App() &#123;4 return (5 &lt;RecoilRoot&gt;6 &lt;CharacterCounter /&gt;7 &lt;/RecoilRoot&gt;8 );9&#125; 初始化recoil需要将RecoilRoot组件放在，所有组件树的父节点上，最好将其放在根组件中。 Atom atom 代表一个状态 创建一个count的atom1import &#123; atom &#125; from &quot;recoil&quot;;2export const count &#x3D; atom(&#123;3 key: &quot;test_count&quot;, &#x2F;&#x2F; key 为 atom 的唯一值4 default: 0, &#x2F;&#x2F; 默认值5&#125;); useRecoilValue获取atom count1import React from &quot;react&quot;;2import &#123; useRecoilValue &#125; from &quot;recoil&quot;;3import &#123; count &#125; from &quot;..&#x2F;..&#x2F;store&#x2F;test&quot;;4function Home(props: HomeProps) &#123;5 const num &#x3D; useRecoilValue(count);6 return &lt;div&gt;&#123;num&#125;&lt;&#x2F;div&gt;;7&#125;8export default Home; useRecoilState类似于React hooks 的useState，可以对count进行读取和修改1import React from &quot;react&quot;;2import &#123; useRecoilState &#125; from &quot;recoil&quot;;3import &#123; count &#125; from &quot;..&#x2F;..&#x2F;store&#x2F;test&quot;;4function Home(props: HomeProps) &#123;5 const [num, setNum] &#x3D; useRecoilState(count);6 return (7 &lt;div onClick&#x3D;&#123;() &#x3D;&gt; setNum(num+1)&#125;&gt;8 &#123;num&#125;9 &lt;&#x2F;div&gt;10 );11&#125;12export default Home; Selector selector 代表一个派生状态。即计算属性，由其他的值计算得到一个新的值（selector）。 根据count（atom）创建一个countSince的selector1import &#123; selector &#125; from &quot;recoil&quot;;2import &#123; count &#125; from &quot;.&#x2F;atoms&quot;;3export const countSince &#x3D; selector(&#123;4 key: &quot;test_count_since&quot;,5 get: (&#123; get &#125;) &#x3D;&gt; &#123;6 return get(count) + 1;7 &#125;,8&#125;); useRecoilValue获取selector countSince1import React from &quot;react&quot;;2import &#123; useRecoilState, useRecoilValue &#125; from &quot;recoil&quot;;3import &#123; count, countSince &#125; from &quot;..&#x2F;..&#x2F;store&#x2F;test&quot;;4function Home(props: HomeProps) &#123;5 const [num, setNum] &#x3D; useRecoilState(count);6 const numSince &#x3D; useRecoilValue(countSince);7 return (8 &lt;div&gt;9 &lt;div onClick&#x3D;&#123;() &#x3D;&gt; setNum(num + 1)&#125;&gt;&#123;num&#125;&lt;&#x2F;div&gt;10 &lt;div&gt;&#123;numSince&#125;&lt;&#x2F;div&gt;11 &lt;&#x2F;div&gt;12 );13&#125;14export default Home; 自定义hooks 同其他自定义hooks一样，实现对逻辑的抽离，状态派发。 创建一个 useCountAdd 自定义hooks1import &#123; useRecoilState &#125; from &quot;recoil&quot;;2import &#123; count &#125; from &quot;.&#x2F;atoms&quot;;3export const useCountAdd &#x3D; () &#x3D;&gt; &#123;4 const [num, setNum] &#x3D; useRecoilState(count);5 return (addNumber: number) &#x3D;&gt; &#123;6 setNum(num + addNumber);7 &#125;;8&#125;; 使用 useCountAdd 对 count 进行自增1import React from &quot;react&quot;;2import &#123; useRecoilValue &#125; from &quot;recoil&quot;;3import &#123; count, useCountAdd &#125; from &quot;..&#x2F;..&#x2F;store&#x2F;test&quot;;4function Home(props: HomeProps) &#123;5 const num &#x3D; useRecoilValue(count);6 const numAdd &#x3D; useCountAdd();7 return &lt;div onClick&#x3D;&#123;() &#x3D;&gt; numAdd(1)&#125;&gt;&#123;num&#125;&lt;&#x2F;div&gt;;8&#125;9export default Home; 数据持久化 同其他状态管理库一样，由于状态缓存在页面，当页面被初始化时。状态也会被清空 本地local持久化1import &#123; DefaultValue, AtomEffect &#125; from &quot;recoil&quot;;2export const localStorageEffect &#x3D; (key: string): AtomEffect&lt;any&gt; &#x3D;&gt; (&#123;3 setSelf,4 onSet,5&#125;) &#x3D;&gt; &#123;6 const savedValue &#x3D; localStorage.getItem(key);7 if (savedValue !&#x3D; null) &#123;8 setSelf(JSON.parse(savedValue));9 &#125;10 onSet((newValue: any, oldValue: any) &#x3D;&gt; &#123;11 if (newValue instanceof DefaultValue) &#123;12 localStorage.removeItem(key);13 &#125; else &#123;14 localStorage.setItem(key, JSON.stringify(newValue));15 &#125;16 &#125;);17&#125;; count（atom）设置持久化1import &#123; atom &#125; from &quot;recoil&quot;;2import &#123; localStorageEffect &#125; from &quot;..&#x2F;effects&quot;;3export const count &#x3D; atom(&#123;4 key: &quot;test_count&quot;,5 default: 0,6 effects_UNSTABLE: [localStorageEffect(&quot;test_count&quot;)],7&#125;);","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"深入JSX","slug":"react/react01","date":"2021-04-04T16:00:00.000Z","updated":"2023-10-20T06:04:14.433Z","comments":true,"path":"2021/04/05/react/react01/","link":"","permalink":"http://yoursite.com/2021/04/05/react/react01/","excerpt":"","text":"JSX 仅仅只是 React.createElement(component, props, …children) 函数的语法糖。 React.createElement React.createElement( type, props, [...children] )type: 元素标签名 例如：divprops: 标签上的属性对象[...children]: 子节点 使用React.createElement创建React DOM 1function InputText(props) &#123;2 const input = React.createElement(\"input\", &#123;3 key: \"xxxKey\",4 onChange: (event) =&gt; &#123;5 console.log(event.target.value);6 &#125;,7 &#125;);8 return React.createElement(9 \"div\",10 &#123;11 className: \"container_box\",12 &#125;,13 [input, \"文本子节点\"]14 );15&#125; 等同于使用jsx创建React DOM 1function InputText(props) &#123;2 return (3 &lt;div&gt;4 &lt;input5 onChange=&#123;(event) =&gt; &#123;6 console.log(event.target.value);7 &#125;&#125;8 /&gt;9 文本子节点10 &lt;/div&gt;11 );12&#125; React.cloneElement React.cloneElement( element, config, [...children] )element: 用于克隆的React元素config: 为新生成的React元素添加新的props，覆盖从中克隆的props[...children]: 为新生成的React元素添加新的children，取代从克隆元素的children 创建一个列表项组件 1function ListItem(props) &#123;2 const &#123; list, handleDel &#125; = props;3 return (4 &lt;ul&gt;5 &#123;list.map((item, index) =&gt; &#123;6 return (7 &lt;li key=&#123;index&#125;&gt;8 文章&#123;item&#125;9 &lt;button onClick=&#123;() =&gt; &#123;handleDel(index)&#125;&#125;&gt;10 删除11 &lt;/button&gt;12 &lt;/li&gt;13 );14 &#125;)&#125;15 &lt;/ul&gt;16 );17&#125; 创建容器组件，用于包裹组件ListItem 1function ListContainer(props) &#123;2 const &#123; children &#125; = props;3 const getControlled = (propsType) =&gt; &#123;4 return &#123;5 ...propsType,6 handleDel: (index) =&gt; &#123;7 console.log(\"劫持 handleDel 事件...\");8 propsType.handleDel(index);9 &#125;,10 &#125;;11 &#125;;12 return (13 &lt;div className=\"list_container\"&gt;14 &lt;h1&gt;xxx大标题&lt;/h1&gt;15 &#123;React.cloneElement(children, getControlled(children.props))&#125;16 &lt;/div&gt;17 );18&#125; React.cloneElement 复制插槽children ReactDOM，并劫持事件handleDel 渲染组件 1function Home(params) &#123;2 const [list, setList] = useState([1, 2, 3, 4]);3 const handleDel = (index) =&gt; &#123;4 const arr = JSON.parse(JSON.stringify(list));5 arr.splice(index, 1);6 setList(arr);7 &#125;;8 return (9 &lt;ListContainer&gt;10 &lt;ListItem list=&#123;list&#125; handleDel=&#123;handleDel&#125; /&gt;11 &lt;/ListContainer&gt;12 );13&#125;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React Router","slug":"react/react03","date":"2021-03-20T16:00:00.000Z","updated":"2023-10-20T06:04:54.385Z","comments":true,"path":"2021/03/21/react/react03/","link":"","permalink":"http://yoursite.com/2021/03/21/react/react03/","excerpt":"","text":"路由安装引入 安装1npm i react-router-dom -S 引入1import &#123;2 HashRouter,3 BrowserRouter,4 Switch,5 Route,6 Link,7 NavLink,8 Redirect9&#125; from &quot;react-router-dom&quot;; HashRouter、HistoryRouter 为别为两种不同的的路由容器组件。 react-router-dom router组件列表 组件名称 说明 HashRouter 1. 容器组件，所有路由必须被此组件包裹。 2. 使用锚点（#）与 onhashchange事件实现sap BrowserRouter 1. 容器组件，所有路由必须被此组件包裹。 2. 使用H5的history API，实现sap不兼容IE9及以下版本。 Switch 1. 用于渲染与路径匹配的第一个子 &lt;Route/ &gt; 或 &lt;Redirect/&gt; Route 1. 根据路径匹配呈现对应的UI。 Redirect 1. 导航到一个新的的位置，新的位置将覆盖历史栈中的当前条目。 2. 只能在 &lt;Switch&gt;中使用 Link 1. 声明式、可访问的导航链接。 NavLink 1. 特殊的 Link 提供额外的样式 React Router HashRouter 基本原理1.hash 路由变化，onhashchange 事件触发2.解析路由的地址，匹配要渲染的组件 基本使用1&lt;HashRouter&gt;2 &lt;Link to&#x3D;&quot;&#x2F;home&quot;&gt;首页&lt;&#x2F;Link&gt;3 &lt;Link to&#x3D;&quot;&#x2F;about&quot;&gt;关于&lt;&#x2F;Link&gt;4 &lt;Link to&#x3D;&quot;&#x2F;study&quot;&gt;学习&lt;&#x2F;Link&gt;5 &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125; &#x2F;&gt;6 &lt;Route path&#x3D;&quot;&#x2F;about&quot; component&#x3D;&#123;About&#125; &#x2F;&gt;7 &lt;Route path&#x3D;&quot;&#x2F;study&quot; component&#x3D;&#123;Study&#125; &#x2F;&gt;8&lt;&#x2F;HashRouter&gt; HistoryRouter 基本原理1.主动触发 h5 history.pushState(state, title, url) API，改变地址栏路由。2.解析url，匹配要渲染的组件3.由于state值存在history.state中。所以区别于HashRouter路由传参数，页面刷新参数不会消失。 基本使用1&lt;BrowserRouter&gt;2 &lt;Link to&#x3D;&quot;&#x2F;home&quot;&gt;首页&lt;&#x2F;Link&gt;3 &lt;Link to&#x3D;&quot;&#x2F;about&quot;&gt;关于&lt;&#x2F;Link&gt;4 &lt;Link to&#x3D;&quot;&#x2F;study&quot;&gt;学习&lt;&#x2F;Link&gt;5 &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125; &#x2F;&gt;6 &lt;Route path&#x3D;&quot;&#x2F;about&quot; component&#x3D;&#123;About&#125; &#x2F;&gt;7 &lt;Route path&#x3D;&quot;&#x2F;study&quot; component&#x3D;&#123;Study&#125; &#x2F;&gt;8&lt;&#x2F;BrowserRouter&gt; Switch 解释说明1.用于渲染与路径匹配的第一个子 &lt;Route/ &gt; 或 &lt;Redirect/&gt;2.如果仅仅使用 那么路径匹配的都会被渲染，如果放到 里面则只会渲染一个路由。 使用案例1&lt;BrowserRouter&gt;2 &lt;Link to&#x3D;&quot;&#x2F;&quot;&gt;index&lt;&#x2F;Link&gt;3 &lt;Link to&#x3D;&quot;&#x2F;home&quot;&gt;首页&lt;&#x2F;Link&gt;4 &#123;&#x2F;* 当页面路由为 &#x2F;home 时Index组件与Home组件都渲染 *&#x2F;&#125;5 &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;Index&#125; &#x2F;&gt;6 &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125; &#x2F;&gt;7 &lt;Switch&gt;8 &#123;&#x2F;* 当页面路由为 &#x2F;home 只渲染匹配的第一个Index组件 *&#x2F;&#125;9 &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;Index&#125; &#x2F;&gt;10 &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125; &#x2F;&gt;11 &lt;&#x2F;Switch&gt;12&lt;&#x2F;BrowserRouter&gt; Route 解释说明1.根据路径匹配呈现对应的UI。 属性说明path: { string | string [] } 路由路径exact: { boolean } 是否精确匹配 URLcomponent: { Component } 需要渲染的组件render: { function } 行内渲染组件children: { function } 无论是否能匹配到路由都将显示的内容strict: { boolean } 带有尾部 “/” 的 path 只能匹配带有尾部 “/” 的 URLsensitive: { boolean } URL 是否区分大小写 基本使用1&lt;BrowserRouter&gt;2 &#123;&#x2F;* 普通 path *&#x2F;&#125;3 &lt;Route path&#x3D;&quot;&#x2F;about&quot;&gt;4 &lt;About &#x2F;&gt;5 &lt;&#x2F;Route&gt;6 &#123;&#x2F;* 数组 path 数组内路径都可以匹配 *&#x2F;&#125;7 &lt;Route path&#x3D;&#123;[&quot;&#x2F;about1&quot;, &quot;&#x2F;about2&quot;]&#125;&gt;8 &lt;About &#x2F;&gt;9 &lt;&#x2F;Route&gt;10 &#123;&#x2F;* 使用 exact 时，切换路由为 &#x2F;home 只会精准匹配Home组件 *&#x2F;&#125;11 &lt;Route path&#x3D;&quot;&#x2F;&quot; exact component&#x3D;&#123;Index&#125; &#x2F;&gt;12 &lt;Route path&#x3D;&quot;&#x2F;home&quot; exact component&#x3D;&#123;Home&#125; &#x2F;&gt;13 &#123;&#x2F;* render 允许内联组件 *&#x2F;&#125;14 &lt;Route path&#x3D;&quot;&#x2F;render&quot; render&#x3D;&#123;() &#x3D;&gt; &lt;div&gt;Render&lt;&#x2F;div&gt;&#125; &#x2F;&gt;15 &#123;&#x2F;* 无论是否匹配路由都将显示 *&#x2F;&#125;16 &lt;Route children&#x3D;&#123;Study&#125; &#x2F;&gt;17 &#123;&#x2F;* 带尾部 “&#x2F;” 才能匹配上 *&#x2F;&#125;18 &lt;Route strict path&#x3D;&quot;&#x2F;strict&#x2F;&quot;&gt;19 &lt;Strict &#x2F;&gt;20 &lt;&#x2F;Route&gt;21 &#123;&#x2F;* 区分大小写 *&#x2F;&#125;22 &lt;Route sensitive path&#x3D;&quot;&#x2F;Sensitive&quot;&gt;23 &lt;Sensitive &#x2F;&gt;24 &lt;&#x2F;Route&gt;25&lt;&#x2F;BrowserRouter&gt; Redirect 解释说明1.导航到一个新的的位置，新的位置将覆盖历史栈中的当前条目。2.只能在 &lt;Switch&gt;中使用。 属性说明from: { string } 跳转的路径to: { string|object } 重定向到的路径push: { boolean } 如果为 true，重定向会将新的位置推入历史记录，而不是替换当前条目exact: { boolean } 是否精确匹配 URLstrict: { boolean } 带有尾部 “/” 的 path 只能匹配带有尾部 “/” 的 URLsensitive: { boolean } URL 是否区分大小写 基本使用1&lt;HashRouter&gt;2 &lt;Link to&#x3D;&quot;&#x2F;&quot;&gt;index&lt;&#x2F;Link&gt;3 &lt;Link to&#x3D;&quot;&#x2F;home&quot;&gt;首页&lt;&#x2F;Link&gt;4 &lt;Link to&#x3D;&quot;&#x2F;ab&quot;&gt;关于&lt;&#x2F;Link&gt;5 &lt;Link to&#x3D;&quot;&#x2F;study&quot;&gt;学习&lt;&#x2F;Link&gt;6 &lt;Switch&gt;7 &#123;&#x2F;* 精准匹配 当路径为 &#x2F; 重定向到 &#x2F;home *&#x2F;&#125;8 &lt;Redirect from&#x3D;&quot;&#x2F;&quot; exact to&#x3D;&quot;&#x2F;home&quot; &#x2F;&gt;9 &#123;&#x2F;* 匹配 &#x2F;ab 时 重定向到 &#x2F;home 同时向history添加两条历史记录 *&#x2F;&#125;10 &lt;Redirect from&#x3D;&quot;&#x2F;ab&quot; push to&#x3D;&quot;&#x2F;about&quot; &#x2F;&gt;11 &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125; &#x2F;&gt;12 &lt;Route path&#x3D;&quot;&#x2F;about&quot; component&#x3D;&#123;About&#125; &#x2F;&gt;13 &lt;Route path&#x3D;&quot;&#x2F;study&#x2F;&quot; component&#x3D;&#123;Study&#125; &#x2F;&gt;14 &lt;&#x2F;Switch&gt;15&lt;&#x2F;HashRouter&gt; Link 解释说明1.声明式、可访问的导航链接。 属性说明to: { string|object|function } 跳转的链接地址replace: { boolean } 默认为 false，如果为 true 点击链接后将替换历史栈中当前条目，而是不添加新条目 基本使用1 &lt;BrowserRouter&gt;2 &lt;Link to&#x3D;&quot;&#x2F;home&quot;&gt;首页&lt;&#x2F;Link&gt;3 &lt;Link to&#x3D;&quot;&#x2F;about&quot; replace&gt;关于&lt;&#x2F;Link&gt;4 &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125; &#x2F;&gt;5 &lt;Route path&#x3D;&quot;&#x2F;about&quot; component&#x3D;&#123;About&#125; &#x2F;&gt;6&lt;&#x2F;BrowserRouter&gt; NavLink 解释说明1.特殊的&lt;Link/&gt;，当它与当前 URL 匹配的时候可以加上样式来渲染一些元素。 属性说明activeClassName: { string } 激活之后的 class 名activeStyle: { object } 激活之后的内联样式exact: { boolean } 是否精确匹配 URL 之后样式才会生效strict: { boolean } 带有尾部 “/” 的 path 只能匹配带有尾部 “/” 的 URL 样式才会生效isActive: { function } 添加额外的激活此链接的函数 基本使用1const isActiveFun &#x3D; (match, location) &#x3D;&gt; &#123;2 console.log(&quot;match&quot;, match);3 console.log(&quot;location&quot;, location);4 return !!match;5&#125;;6return (7 &lt;BrowserRouter&gt;8 &lt;NavLink9 to&#x3D;&quot;&#x2F;home&quot;10 activeClassName&#x3D;&quot;link_active_class&quot;11 activeStyle&#x3D;&#123;&#123; fontSize: &quot;30px&quot; &#125;&#125;12 isActive&#x3D;&#123;isActiveFun&#125;13 &gt;14 首页15 &lt;&#x2F;NavLink&gt;16 &lt;NavLink to&#x3D;&quot;&#x2F;about&quot;&gt;关于&lt;&#x2F;NavLink&gt;17 &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125; &#x2F;&gt;18 &lt;Route path&#x3D;&quot;&#x2F;about&quot; component&#x3D;&#123;About&#125; &#x2F;&gt;19 &lt;&#x2F;BrowserRouter&gt;20); Router 三大属性 history location 是指当前的位置（location） push(path, state) 向 hisotry 堆栈顶加入一个新的条目 replace(path, state)替换在 history 堆栈中的当前条目 location search 跳转路由传递在地址栏上的参数信息 state 跳转时传递的参数信息 match params 路径参数 路由跳转传递参数 match params 传递参数 路由中设置 key1&lt;Route path&#x3D;&quot;&#x2F;about&#x2F;:id?&quot; component&#x3D;&#123;About&#125; &#x2F;&gt; useHistory push 路由跳转1import &#123; useHistory &#125; from &quot;react-router-dom&quot;;2&#x2F;&#x2F; ... 3const history &#x3D; useHistory();4const onJump &#x3D; () &#x3D;&gt; &#123;5 const id &#x3D; &quot;xxx123&quot;;6 history.push(&#96;&#x2F;about&#x2F;$&#123;id&#125;&#96;);7&#125;; useParams 获取当前路由 match对象中的params1import &#123; useParams &#125; from &quot;react-router-dom&quot;;2&#x2F;&#x2F; ...3const params &#x3D; useParams();4console.log(&quot;params about&quot;, params); &#x2F;&#x2F; params about &#123;id: &quot;xxx123&quot;&#125; BrowserRouter location state 传递参数 (HashRouter 模式下 无效) useHistory push 路由跳转1import &#123; useHistory &#125; from &quot;react-router-dom&quot;;2&#x2F;&#x2F; ... 3const history &#x3D; useHistory();4const onJump &#x3D; () &#x3D;&gt; &#123;5 history.push(&#123;6 pathname: &quot;&#x2F;about&quot;,7 state: &#123;8 id: &quot;xxx234&quot;,9 type: &quot;view&quot;,10 &#125;,11 &#125;);12&#125;; useLocation 获取当前路由 location对象中的state1import &#123; useLocation &#125; from &quot;react-router-dom&quot;;2&#x2F;&#x2F; ...3const location &#x3D; useLocation();4console.log(&quot;state about&quot;, location.state); &#x2F;&#x2F;state about &#123;id: &quot;xxx234&quot;, type: &quot;view&quot;&#125; location search 传递参数 useHistory push 路由跳转1import &#123; useHistory &#125; from &quot;react-router-dom&quot;;2&#x2F;&#x2F; ... 3const history &#x3D; useHistory();4const onJump &#x3D; () &#x3D;&gt; &#123;5 history.push(&#123;6 pathname: &quot;&#x2F;home&quot;,7 search: &#96;?id&#x3D;$&#123;123&#125;&amp;type&#x3D;view&#96;,8 &#125;);9&#125;; useLocation 获取当前路由 location对象中的search1import &#123; useLocation &#125; from &quot;react-router-dom&quot;;2&#x2F;&#x2F; ...3const location &#x3D; useLocation();4console.log(&quot;search about&quot;, location.search); &#x2F;&#x2F;search about ?id&#x3D;xxx234&amp;type&#x3D;view","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React常用hooks","slug":"react/react04","date":"2021-03-13T16:00:00.000Z","updated":"2023-10-20T06:05:09.935Z","comments":true,"path":"2021/03/14/react/react04/","link":"","permalink":"http://yoursite.com/2021/03/14/react/react04/","excerpt":"","text":"useState 语法说明const [state, setState] = useState(initState)state:当前 state 值setState:用于异步更新 state 中的状态initState:state 的初始值调用更新函数 setState() 时，函数组件将 重新渲染，并赋予 state 最新的值 基础用法1const [count, setCount] &#x3D; useState(0);2return (3 &lt;div&gt;4 &lt;p&gt;&#123;count&#125;&lt;&#x2F;p&gt;5 &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;add 1&lt;&#x2F;button&gt;6 &lt;&#x2F;div&gt;7); 更新数据直接更新 setCount(count + 1) 当前count为从useState解构出的count函数式更新 setCount(currentCount =&gt; currentCount+1) 可以直接在回调函数中拿到当前count的值useState 不是自动合并更新对象，而是直接替换它。1setState(currentObject &#x3D;&gt; &#123;2 &#x2F;&#x2F; 也可以使用 Object.assign3 return &#123;...currentObject, ...updatedObject&#125;;4&#125;); useEffect 语法说明 useEffect(() =&gt; { // 在此可以执行任何带副作用操作 return () =&gt; { // 在组件卸载前执行 // 在此做一些收尾工作, 比如清除定时器/取消订阅等 } }, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行参数1：执行操作逻辑函数参数2：更新 effect 依赖项参数数组 基础用法1useEffect(() &#x3D;&gt; &#123;2 console.log(&quot;第一次渲染之后及之后每次都会执行&quot;);3&#125;);4useEffect(() &#x3D;&gt; &#123;5 &#x2F;&#x2F; componentDidMount6 console.log(&quot;只执行第一次渲染之后&quot;);7&#125;, []);8useEffect(() &#x3D;&gt; &#123;9 if (count !&#x3D;&#x3D; 0) &#123;10 &#x2F;&#x2F; componentDidUpdate11 console.log(&quot;count变化了&quot;);12 &#125;13&#125;, [count]);14useEffect(() &#x3D;&gt; &#123;15 return () &#x3D;&gt; &#123;16 &#x2F;&#x2F; componentWillUnmount17 console.log(&quot;函数组件被卸载&quot;);18 &#125;;19&#125;, []); 可以把 useEffect Hook 看做类函数组件componentDidMount() componentDidUpdate() componentWillUnmount()三个生命周期钩子的组合 useContext 使用方式1.创建上下文组件const MyContext = React.createContext()2.使用MyContext.Provider作为所有组件的容器组件，通过value属性给后代组件传递数据&lt;MyContext.Provider value={数据}&gt; 子组件 &lt;/MyContext.Provider&gt;3.后代组件通过useContext读取到value中传递的数据const {数据} = useContext(MyContext) 基本使用1const MyContent &#x3D; React.createContext();2function App() &#123;3 return (4 &lt;MyContent.Provider value&#x3D;&#123;&#123; appComponentName: &quot;app123&quot; &#125;&#125;&gt;5 &lt;h1&gt;App Component&lt;&#x2F;h1&gt;6 &lt;Parent &#x2F;&gt;7 &lt;&#x2F;MyContent.Provider&gt;8 );9&#125;10function Parent() &#123;11 return (12 &lt;div&gt;13 &lt;h2&gt;Parent Component&lt;&#x2F;h2&gt;14 &lt;Child &#x2F;&gt;15 &lt;&#x2F;div&gt;16 );17&#125;18function Child() &#123;19 const &#123; appComponentName &#125; &#x3D; useContext(MyContent);20 return (21 &lt;div&gt;22 &lt;h3&gt;Child Component&lt;&#x2F;h3&gt;23 &lt;p&gt;&#123;appComponentName&#125;&lt;&#x2F;p&gt;24 &lt;&#x2F;div&gt;25 );26&#125; useContext处理多层级传递数据的方式 useReducer 语法说明const [state, dispatch] = useReducer(reducer, initialState);state:当前 state 值dispatch:通过 type 派发 reducer中的事件reducer: (state,action) = {} 需要派发的事件 state为当前state中的值，action为dispatch传递过来的参数。initialState:state 的初始值 基本使用1const initialState &#x3D; &#123; count: 0 &#125;;2const reducer &#x3D; (state, action) &#x3D;&gt; &#123;3 const &#123; type, num &#x3D; 1 &#125; &#x3D; action;4 switch (type) &#123;5 case &quot;increment&quot;:6 return &#123; ...state, count: state.count + num &#125;;7 case &quot;decrement&quot;:8 return &#123; ...state, count: state.count - num &#125;;9 default:10 throw new Error(&quot;unknown type&quot;);11 &#125;12&#125;;13function App() &#123;14 const [state, dispatch] &#x3D; useReducer(reducer, initialState);15 return (16 &lt;div&gt;17 &lt;h1&gt;&#123;state.count&#125;&lt;&#x2F;h1&gt;18 &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123;dispatch(&#123; type: &quot;increment&quot; &#125;)&#125;&#125;&gt;加&lt;&#x2F;button&gt;19 &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123;dispatch(&#123; type: &quot;decrement&quot;, num: 2 &#125;)&#125;&#125;&gt;减&lt;&#x2F;button&gt;20 &lt;&#x2F;div&gt;21 );22&#125; 通过dispatch改变state中的值也会触发函数重新执行渲染 uesRef 获取dom节点1const inputRef &#x3D; useRef();2useEffect(() &#x3D;&gt; &#123;3 console.log(&quot;inputRef&quot;, inputRef); &#x2F;&#x2F; inputRef &#123;current: input&#125;4&#125;, []);5return (6 &lt;div&gt;7 &lt;input ref&#x3D;&#123;inputRef&#125; type&#x3D;&quot;text&quot; &#x2F;&gt;8 &lt;&#x2F;div&gt;9); 存放变量1const myDataRef &#x3D; useRef(&#123; count: 0 &#125;);2const handleAdd &#x3D; () &#x3D;&gt; &#123;3 myDataRef.current.count++;4 const currentCount &#x3D; myDataRef.current.count;5 if (currentCount &gt; 5) &#123;6 alert(currentCount);7 &#125;8&#125;;9return (10 &lt;div&gt;11 &lt;button onClick&#x3D;&#123;handleAdd&#125;&gt;加&lt;&#x2F;button&gt;12 &lt;&#x2F;div&gt;13); useRef可以存放变量，与state不同它的值修改了不会造成组件的重新渲染。 配合forwardRef与useImperativeHandle获取组件上暴露的数据1function App() &#123;2 const myComponentRef &#x3D; useRef();3 useEffect(() &#x3D;&gt; &#123;4 console.log(myComponentRef); &#x2F;&#x2F; current: &#123;text: &quot;MyComponent&quot;, testFn: ƒ&#125;5 &#125;, []);6 return (7 &lt;div&gt;8 &lt;MyComponent ref&#x3D;&#123;myComponentRef&#125; &#x2F;&gt;9 &lt;&#x2F;div&gt;10 );11&#125;12const MyComponent &#x3D; forwardRef((props, ref) &#x3D;&gt; &#123;13 const testFn &#x3D; () &#x3D;&gt; &#123;14 alert(123);15 &#125;;16 useImperativeHandle(ref, () &#x3D;&gt; (&#123;17 testFn: testFn,18 text: &quot;MyComponent&quot;,19 &#125;));20 return (21 &lt;div&gt;22 &lt;h1&gt;MyComponent&lt;&#x2F;h1&gt;23 &lt;&#x2F;div&gt;24 );25&#125;); memo 语法说明 const MyComp = memo(MyComponent);MyComponent：组件MyComp：被memo记忆的组件MyComponent组件，父组件渲染时，传入的props值未发生变化，组件不重新渲染。 基础用法1function App() &#123;2 const [count, setCount] &#x3D; useState(0);3 return (4 &lt;div&gt;5 &lt;h16 onClick&#x3D;&#123;() &#x3D;&gt; &#123; setCount(count + 1); &#125;&#125;7 &gt;8 &#123;count&#125;9 &lt;&#x2F;h1&gt;10 &lt;MyComp &#x2F;&gt;11 &lt;&#x2F;div&gt;12 );13&#125;14const MyComponent &#x3D; () &#x3D;&gt; &#123;15 console.log(&quot;MyComponent runder...&quot;);16 return (17 &lt;div&gt;18 &lt;h1&gt;MyComponent&lt;&#x2F;h1&gt;19 &lt;&#x2F;div&gt;20 );21&#125;;22const MyComp &#x3D; memo(MyComponent); useMemo 语法说明 const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);computeExpensiveValue(a,b)：执行操作逻辑函数[a, b]：更新 effect 依赖项参数数组。当依赖发生变化时useMemo会重新计算并返回新的memoizedValue值 基础用法1const [a, setA] &#x3D; useState(0);2const [b, setB] &#x3D; useState(0);3const memoizedValue &#x3D; useMemo(() &#x3D;&gt; &#123;4 return a + b;5&#125;, [a, b]);6const handleClick &#x3D; () &#x3D;&gt; &#123;7 setA(a + 1);8 setB(b + 1);9&#125;;10return (11 &lt;div&gt;12 &lt;h1&gt;&#123;memoizedValue&#125;&lt;&#x2F;h1&gt;13 &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;Change a b&lt;&#x2F;button&gt;14 &lt;&#x2F;div&gt;15); useCallback 语法说明 const memoizedCallback = useCallback(() =&gt; { callback() }, [a, b]);memoizedCallback：被记忆的函数。当父组件重新渲染时，如果当前函数已经存在，则此函数不会被重新定义，而是使用之前的函数。[a, b]：更新 memoizedCallback 依赖项参数数组。当依赖发生变化时memoizedCallback函数会被从新定义。 基本使用1function App() &#123;2 const [count, setCount] &#x3D; useState(0);3 const changeChild &#x3D; useCallback(() &#x3D;&gt; &#123;4 console.log(&quot;changeChild...&quot;);5 &#125;, []);6 return (7 &lt;div&gt;8 &lt;h19 onClick&#x3D;&#123;() &#x3D;&gt; &#123; setCount(count + 1); &#125;&#125;10 &gt;11 &#123;count&#125;12 &lt;&#x2F;h1&gt;13 &lt;MyComponent changeChild&#x3D;&#123;changeChild&#125; &#x2F;&gt;14 &lt;&#x2F;div&gt;15 );16&#125;17const MyComponent &#x3D; memo((props) &#x3D;&gt; &#123;18 console.log(&quot;MyComponent runder...&quot;);19 return (20 &lt;div&gt;21 &lt;h1&gt;MyComponent&lt;&#x2F;h1&gt;22 &lt;&#x2F;div&gt;23 );24&#125;); 当父函数重新渲染时changeChild函数被重新定义，进而使子组件的props发生改变，导致子组件重新渲染。使用useCallback处理回调函数，使该回调函数被记忆，父组件在渲染时当前函数如果已经被定义，就不会再从新定义，而是使用原来的函数，不会导致props更新。","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React生命周期","slug":"react/react06","date":"2021-03-07T16:00:00.000Z","updated":"2023-10-20T06:05:46.299Z","comments":true,"path":"2021/03/08/react/react06/","link":"","permalink":"http://yoursite.com/2021/03/08/react/react06/","excerpt":"","text":"React生命周期旧 React生命周期新","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React初体验","slug":"react/react05","date":"2021-03-07T16:00:00.000Z","updated":"2023-10-20T06:05:30.618Z","comments":true,"path":"2021/03/08/react/react05/","link":"","permalink":"http://yoursite.com/2021/03/08/react/react05/","excerpt":"","text":"virtul DOM virtul DOM 也就是虚拟节点。通过JS的Object对象模拟DOM中的真实节点对象，再通过特定的render方法将其渲染成真实的DOM节点。 jsx生成虚拟dom1const VDOM &#x3D; (2 &lt;h1 id&#x3D;&quot;title&quot;&gt;3 &lt;span&gt;Hello，React&lt;&#x2F;span&gt;4 &lt;&#x2F;h1&gt;5)6ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;)) React.createdElement生成虚拟dom1&#x2F;**2 * @description: React生成虚拟DOM3 * @param &#123;string&#125; 标签名称4 * @param &#123;Object&#125; 标签上的属性 5 * @param &#123;*&#125; 标签内的内容 6 *&#x2F;7const VDOM &#x3D; React.createElement(8 &#39;h1&#39;,9 &#123;id: &quot;title&quot;&#125;,10 React.createElement(&#39;span&#39;, &#123;&#125;, &#39;Hello，React&#39;)11)12ReactDOM.render(VDOM, document.getElementById(&#39;test&#39;)) JSX jsx类似于html文档结构，其本质是一个Object类型的对象，终会被React转化为真实DOM，呈现在页面上。 可直接在js中书写html结构，不需要写引号1const VDOM &#x3D; &lt;h1&gt;Hello, React&lt;&#x2F;h1&gt; 标签中混入JS表达式时要用{}1 const myId &#x3D; &quot;tEstId&quot;2const VDOM &#x3D; &lt;h1 id&#x3D;&#123;myId.toLowerCase()&#125;&gt;Hello, React&lt;&#x2F;h1&gt; 样式的类名指定不要使用class，使用className1const VDOM &#x3D; &lt;h1 className&#x3D;&quot;bg-color&quot;&gt;Hello, React&lt;&#x2F;h1&gt; 内联样式，使用style={object}的形式，object为样式属性对象{key:value}，短横线的样式要替换驼峰1const VDOM &#x3D; &lt;h1 style&#x3D;&#123;&#123;fontSize:&#39;50px&#39;&#125;&#125;&gt;Hello, React&lt;&#x2F;h1&gt; 根标签只能有一个1const VDOM &#x3D; (2 &lt;div&gt;3 &lt;h1&gt;Hello, React&lt;&#x2F;h1&gt;4 &lt;h1&gt;Hello, World&lt;&#x2F;h1&gt;5 &lt;&#x2F;div&gt;6) 绑定事件使用驼峰方式1class MyComponent extends React.Component &#123;2 handleClick()&#123;3 console.log(&#39;this&#39;,this) &#x2F;&#x2F; this undefined4 &#125;5 render()&#123;6 return &lt;h1 onClick&#x3D;&#123;this.handleClick&#125;&gt;Hello，React Class Component&lt;&#x2F;h1&gt;7 &#125;8&#125; 标签首字母小写，对应html中元素标签1const VDOM &#x3D; (2 &lt;div&gt;3 &lt;h1&gt;Hello, React&lt;&#x2F;h1&gt;4 &lt;test&gt;123&lt;&#x2F;test&gt;5 &#123;&#x2F;* Warning: The tag &lt;test&gt; is unrecognized in this browser. 6 If you meant to render a React component, start its name with an uppercase letter.7 in test8 in div *&#x2F;&#125;9 &lt;&#x2F;div&gt;10) 标签首字母大写，对应react组件1const VDOM &#x3D; (2 &lt;div&gt;3 &lt;h1&gt;Hello, React&lt;&#x2F;h1&gt;4 &lt;Test&gt;&lt;&#x2F;Test&gt;5 &#123;&#x2F;* Test is not defined *&#x2F;&#125;6 &lt;&#x2F;div&gt;7) {}中只能放入js表达式，而不能js语句1const list &#x3D; [&#39;Angular&#39;,&#39;React&#39;,&#39;Vue&#39;]2const VDOM &#x3D; (3 &lt;div&gt;4 &lt;h1&gt;Hello React&lt;&#x2F;h1&gt;5 &lt;ul&gt;6 &#123;7 list.map((item,index) &#x3D;&gt; &#123;8 return &lt;li key&#x3D;&#123;index&#125;&gt;&#123;item&#125;&lt;&#x2F;li&gt;9 &#125;)10 &#125;11 &lt;&#x2F;ul&gt;12 &lt;&#x2F;div&gt;13)14ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;)) 1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方。例如a a+b demo(1) arr.map() function test () {}2.语句(代码)if(){} for(){} switch(){case:xxxx} react中定义组件 函数组件1&#x2F;&#x2F;1.创建函数式组件2function MyComponent()&#123;3 console.log(this); &#x2F;&#x2F;此处的this是undefined，因为babel编译后开启了严格模式4 return &lt;h1&gt;Hello，React Function Component&lt;&#x2F;h1&gt;5&#125;6&#x2F;&#x2F;2.渲染组件到页面7ReactDOM.render(&lt;MyComponent&#x2F;&gt;,document.getElementById(&#39;test&#39;)) 执行了ReactDOM.render(…….之后，发生了什么？ 1.React解析组件标签，找到了MyComponent组件。 2.发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中。 类式组件1&#x2F;&#x2F;1.创建类式组件2class MyComponent extends React.Component &#123;3 render()&#123;4 &#x2F;&#x2F;render是放在哪里的？—— MyComponent的原型对象上，供实例使用。5 &#x2F;&#x2F;render中的this是谁？—— MyComponent的实例对象 &lt;&#x3D;&gt; MyComponent组件实例对象。6 console.log(&#39;render中的this:&#39;,this);7 return &lt;h1&gt;Hello，React Class Component&lt;&#x2F;h1&gt;8 &#125;9&#125;10&#x2F;&#x2F;2.渲染组件到页面11ReactDOM.render(&lt;MyComponent&#x2F;&gt;,document.getElementById(&#39;test&#39;)) 执行了ReactDOM.render(…….之后，发生了什么？ 1.React解析组件标签，找到了MyComponent组件。 2.发现组件是使用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法。 3.将render返回的虚拟DOM转为真实DOM，随后呈现在页面中。 组件实例核心属性 state state是React为实例组件提供存储状态数据的对象，通过setState修改状态值，进而触发render函数，重新渲染页面。 1class Weather extends React.Component&#123;2 constructor(props)&#123;3 super(props)4 &#x2F;&#x2F;初始化状态5 this.state&#x3D; &#123;6 isHot:true7 &#125;8 &#125;9 changeWeather()&#123;10 &#x2F;&#x2F;通过setState进行更新state中isHot数据，然后再次触发render方法11 this.setState(&#123;12 isHot:!this.state.isHot13 &#125;)14 &#125;15 render()&#123;16 let &#123;isHot&#125; &#x3D; this.state17 return &lt;h1 onClick&#x3D;&#123;this.changeWeather.bind(this)&#125;&gt;今天天气很&#123;isHot?&#39;炎热&#39;:&#39;凉爽&#39;&#125;&lt;&#x2F;h1&gt;18 &#125;19&#125; jsx中绑定事件this指向？由于changeWeather是作为onClick的回调，不是通过实例调用的，而是直接调用，所以this不指向当前实例。类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined。 props props组件之间数据传递，且不可修改只读。 1&#x2F;&#x2F;创建组件2class Person extends React.Component&#123;3 render()&#123;4 const &#123;name,age,sex&#125; &#x3D; this.props5 return (6 &lt;ul&gt;7 &lt;li&gt;姓名：&#123;name&#125;&lt;&#x2F;li&gt;8 &lt;li&gt;性别：&#123;sex&#125;&lt;&#x2F;li&gt;9 &lt;li&gt;年龄：&#123;age+1&#125;&lt;&#x2F;li&gt;10 &lt;&#x2F;ul&gt;11 )12 &#125;13&#125;14&#x2F;&#x2F;渲染组件到页面15const p &#x3D; &#123;name:&#39;张三&#39;,age:18&#125;16&#x2F;&#x2F;组件标签上&lt;Person &#123;...p&#125; &#x2F;&gt; 是将对象全部字段解构传入（注意：...运算符本身不可以解构对象，这里是React组件标签上的特定写法）17ReactDOM.render(&lt;Person &#123;...p&#125; sex&#x3D;&#39;男&#39;&#x2F;&gt;,document.getElementById(&#39;test&#39;)) react会将标签上的自定义属性，处理成对象，并放置在组件实例的props属性中。如果是函数组件，则可以在函数形参中接受。 对props中字段属性值进行限制 1&#x2F;&#x2F;对标签属性进行类型、必要性的限制2Person.propTypes &#x3D; &#123;3 name:PropTypes.string.isRequired, &#x2F;&#x2F;限制name必传，且为字符串4 sex:PropTypes.string,&#x2F;&#x2F;限制sex为字符串5 age:PropTypes.number&#x2F;&#x2F;限制age为数值6&#125;7&#x2F;&#x2F;指定默认标签属性值8Person.defaultProps &#x3D; &#123;9 sex:&#39;男&#39;,&#x2F;&#x2F;sex默认值为男10 age:18 &#x2F;&#x2F;age默认值为1811&#125; PropTypes 类型检查文档 ref ref标记在元素上对应其dom，ref标记在组件上对应其组件的实例 字符串形式的ref1class Demo extends React.Component&#123;2 showData&#x3D;()&#x3D;&gt;&#123;3 const &#123;input&#125; &#x3D; this.refs4 alert(input.value)5 &#125;6 render()&#123;7 return(8 &lt;div&gt;9 &lt;input ref&#x3D;&quot;input&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;点击按钮提示数据&quot;&#x2F;&gt;10 &lt;button onClick&#x3D;&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;&#x2F;button&gt;11 &lt;&#x2F;div&gt;12 )13 &#125;14&#125; 在组件内，标记在元素或组件且以字符串形式的ref，react会将其收集到实例的refs属性上字符串形式的ref，存在效率问题一般不推荐使用 回调函数形式的ref1class Demo extends React.Component&#123;2 showData&#x3D;()&#x3D;&gt;&#123;3 const &#123;input&#125; &#x3D; this4 alert(input.value)5 &#125;6 render()&#123;7 return(8 &lt;div&gt;9 &#123;&#x2F;* 内联回调 每次render渲染时会先赋值为null 再赋值当前dom或者实例 *&#x2F;&#125;10 &lt;input ref&#x3D;&#123;c &#x3D;&gt; this.input &#x3D; c &#125; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;点击按钮提示数据&quot;&#x2F;&gt;11 &lt;button onClick&#x3D;&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;&#x2F;button&gt;12 &lt;&#x2F;div&gt;13 )14 &#125;15&#125; 在组件内，标记在元素或组件且以回调函数形式的ref，可以在回调函数内部通过this，直接绑定到实例对象上 createRef的使用形式1class Demo extends React.Component&#123;2 input &#x3D; React.createRef()3 showData&#x3D;()&#x3D;&gt;&#123;4 const input &#x3D; this.input.current5 alert(input.value)6 &#125;7 render()&#123;8 return(9 &lt;div&gt;10 &lt;input ref&#x3D;&#123;this.input&#125; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;点击按钮提示数据&quot;&#x2F;&gt;11 &lt;button onClick&#x3D;&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;&#x2F;button&gt;12 &lt;&#x2F;div&gt;13 )14 &#125;15&#125; React.createRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点，且该容器与ref一一对应。Refs and the DOM","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"小程序基础使用","slug":"applets/applets01","date":"2021-02-26T16:00:00.000Z","updated":"2023-10-20T04:16:42.844Z","comments":true,"path":"2021/02/27/applets/applets01/","link":"","permalink":"http://yoursite.com/2021/02/27/applets/applets01/","excerpt":"","text":"数据绑定 WXML中的动态数据均来自对应Page的data。 “Mustache”语法（双大括号）数据绑定1&lt;view&gt; &#123;&#123;message&#125;&#125; &lt;/view&gt; 1Page(&#123;2 data: &#123;3 message: 'Hello MINA!'4 &#125;5&#125;) setData 添加/修改data中数据1Page(&#123;2 data: &#123;3 message: ''4 &#125;,5 onLoad: function (options) &#123;6 this.setData(&#123;7 message:'Hello World!'8 &#125;)9 &#125;10&#125;) 数据绑定 生命周期钩子函数 应用生命周期1App(&#123;2 onLaunch (options) &#123;3 // Do something initial when launch.4 &#125;,5 onShow (options) &#123;6 // Do something when show.7 &#125;,8 onHide () &#123;9 // Do something when hide.10 &#125;11&#125;) onLaunch: 小程序初始化完成时触发，全局只触发一次。onShow: 小程序启动，或从后台进入前台显示时触发。onHide: 小程序从前台进入后台时触发。小程序生命周期文档 页面生命周期1Page(&#123;2 onLoad: function(options) &#123;3 // 页面创建时执行4 &#125;,5 onShow: function() &#123;6 // 页面出现在前台时执行7 &#125;,8 onReady: function() &#123;9 // 页面首次渲染完毕时执行10 &#125;,11 onHide: function() &#123;12 // 页面从前台变为后台时执行13 &#125;,14 onUnload: function() &#123;15 // 页面销毁时执行16 &#125;17&#125;) onLoad: 页面创建时执行。onShow: 页面出现在前台时执行。onReady: 页面首次渲染完毕时执行。onHide: 页面从前台变为后台时执行。onUnload: 页面销毁时执行。页面初始化时 onLoad &gt; onShow &gt; onReady页面生命周期文档 WXML中常用语法 插值表达式&lcub;&lcub;&rcub;&rcub;放置 死值放置 变量可以支持运算符 &gt; &lt; ? : ( 三元运算符 ) + - 属性属性=&lcub;&lcub;死值 变量 运算符 &gt; &lt; ? : ( 三元运算符 ) + - * /&rcub;&rcub; data-xxx 自定义属性1&lt;view bind:tap=\"onGoToDetail\" data-id=\"&#123;&#123;postId&#125;&#125;\"&gt;&lt;/view&gt; 1onGoToDetail(event) &#123;2 console.log(event.currentTarget.dataset.id)3&#125; 通过data-形式自定义的属性可以在event.currentTarget.dataset中获取到。 1.自定义的属性在dataset中data-会被省略。例如 data-id =&gt; id 2.当自定义属性中存在大写字母会被转换成小写。例如 data-postId =&gt; postid 3.当自定义属性中存在多个-会被转换成驼峰。例如 data-post-id =&gt; postId style 运算符写法style=&quot;&lcub;&lcub;color?&apos;color:&apos;+color+&apos;;&apos;:&apos;&apos;&rcub;&rcub;&lcub;&lcub;size?&apos;font-size:&apos;+size+&apos;rpx&apos;:&apos;&apos;&rcub;&rcub;&quot; class 运算符写法class=&quot;text-class &lcub;&lcub;colorRed&rcub;&rcub; &lcub;&lcub;textSize&rcub;&rcub;&quot; wx:if 条件渲染1&lt;view wx:if=\"&#123;&#123;view == 'WEBVIEW'&#125;&#125;\"&gt; WEBVIEW &lt;/view&gt;2&lt;view wx:elif=\"&#123;&#123;view == 'APP'&#125;&#125;\"&gt; APP &lt;/view&gt;3&lt;view wx:else=\"&#123;&#123;view == 'MINA'&#125;&#125;\"&gt; MINA &lt;/view&gt; 条件渲染 wx:for 列表渲染1&lt;view wx:for=\"&#123;&#123;array&#125;&#125;\" wx:for-item=\"item\" wx:for-index=\"index\" wx:key=\"index\"&gt;2 &#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;3&lt;/view&gt; wx:for-item 默认值 item wx:for-index 默认值 index 列表渲染 事件1&lt;view catch:tap=\"handleViewTap\"&gt;2 &lt;text bind:tap=\"handleTextTap\"&gt;Hello World!&lt;/text&gt;3&lt;/view&gt; 1Page(&#123;2 handleViewTap: function () &#123;3 console.log('on view tap')4 &#125;,5 handleTextTap: function () &#123;6 console.log('on text tap')7 &#125;8&#125;) bind 允许事件冒泡catch 阻止事件冒泡事件系统 路由跳转 navigateTo1wx.navigateTo(&#123;2 url: '/pages/posts/posts'3&#125;) 保留当前页面，跳转到应用内的某个页面。不能跳到 tabbar 页面。不可以无限使用，小程序中页面栈最多十层。wx.navigateTo redirectTo1wx.redirectTo(&#123;2 url: '/pages/posts/posts'3&#125;) 关闭当前页面，跳转到应用内的某个页面。不能跳转到 tabbar 页面。wx.redirectTo switchTab1wx.switchTab(&#123;2 url: '/pages/posts/posts'3&#125;) 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面wx.switchTab 页面之间通讯1wx.navigateTo(&#123;2 url: '/pages/posts/posts?pid='+13&#125;) 与浏览器地址传参一样，通过在url ？ 后面 以 key=value&amp;key=value 的方式传递数据1onLoad(options) &#123;2 console.log(options) // &#123; \"pid\": \"1\" &#125;3&#125; 在跳转后的页面通过onLoad生命周期函数中拿到传递的参数对象 数据缓存 App 1App(&#123;2 globalData: 'I am global data'3&#125;) app.js文件中，在App内可以存储公共数据 1const app = getApp() 在小程序的任何位置都可以通过getApp()函数，进行访问和修改。当小程序重新加载时，数据会被初始化。 Storage 小程序的Storage，类似于浏览器的localStorage，本地永久存储。 1wx.setStorageSync('data', &#123; message: 'Storage' &#125;) setStorageSync 同步操作 增加/修改Storage数据。 1const data = wx.getStorageSync('data') getStorageSync 同步操作 获取Storage中对应key的数据。 1wx.removeStorageSync('data') removeStorageSync 同步操作 删除Storage中对应key的数据。 1wx.clearStorageSync() clearStorageSync 同步操作 清空整个Storage数据。","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"小程序初体验","slug":"applets/applets02","date":"2021-02-24T16:00:00.000Z","updated":"2023-10-20T04:16:56.088Z","comments":true,"path":"2021/02/25/applets/applets02/","link":"","permalink":"http://yoursite.com/2021/02/25/applets/applets02/","excerpt":"","text":"开发工具 小程序开发工具下载 https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html 使用开发工具创建小程序 项目名称 目录 AppID … AppID获取 微信公众平台注册账号 https://mp.weixin.qq.com/ 登录微信公众平台 开发 &gt; 开发管理 &gt; 开发设置 中查看AppID 开发工具对项目配置详情 小程序的基本结构 小程序开发代码主要由四部分组成：.json 配置文件、.wxml 模板文件、.wxss 样式文件、.js 脚本逻辑文件。 .json 配置文件 app.json 全局配置1&#123;2 \"pages\":[3 \"pages/index/index\",4 \"pages/logs/logs\"5 ],6 \"window\":&#123;7 \"backgroundTextStyle\":\"light\",8 \"navigationBarBackgroundColor\": \"#fff\",9 \"navigationBarTitleText\": \"Weixin\",10 \"navigationBarTextStyle\":\"black\"11 &#125;,12 \"style\": \"v2\",13 \"sitemapLocation\": \"sitemap.json\"14&#125; pages用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。window用于设置小程序的状态栏、导航条、标题、窗口背景色。\b小程序app.json全局配置文档 页面配置1&#123;2 &quot;navigationBarBackgroundColor&quot;: &quot;#ff0000&quot;,3 &quot;navigationBarTextStyle&quot;: &quot;black&quot;,4 &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;,5 &quot;backgroundColor&quot;: &quot;#eeeeee&quot;,6 &quot;backgroundTextStyle&quot;: &quot;light&quot;7&#125; 页面中配置项在当前页面会覆盖 app.json 的 window 中相同的配置项。小程序page.json页面配置文档 .wxml 模板文件 xwml 和 html 非常相似，都有标签、属性等等构成的页面结构 标签 与html不同，小程序的标签大部分是根据用途语义化的。如，view text … 属性 在 wxml 文件中，多了类似 vue 的属性声明，如 wx:if wx:for … WXML文档 https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/ .wxss 样式文件 wxss和css基本上没有什么差别。区别在于wxss引入了新的尺寸单位rpx。 单位rpx rpx是把屏幕的宽度均分成了750个等份，然后1rpx就代表屏幕宽度的1/750，可以更方便的布局。 导入样式 @import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束。 WXSS文档 https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html .js 脚本逻辑文件 .js文件1Page(&#123;2 data: &#123;3 text: \"This is page data.\"4 &#125;,5 onLoad: function(options) &#123;6 // 页面创建时执行7 &#125;,8 onShow: function() &#123;9 // 页面出现在前台时执行10 &#125;,11 onReady: function() &#123;12 // 页面首次渲染完毕时执行13 &#125;,14 onHide: function() &#123;15 // 页面从前台变为后台时执行16 &#125;,17 onUnload: function() &#123;18 // 页面销毁时执行19 &#125;,20 onPullDownRefresh: function() &#123;21 // 触发下拉刷新时执行22 &#125;,23 onReachBottom: function() &#123;24 // 页面触底时执行25 &#125;,26 onShareAppMessage: function () &#123;27 // 页面被用户分享时执行28 &#125;,29 onPageScroll: function() &#123;30 // 页面滚动时执行31 &#125;,32 onResize: function() &#123;33 // 页面尺寸变化时执行34 &#125;,35 onTabItemTap(item) &#123;36 // tab 点击时执行37 console.log(item.index)38 console.log(item.pagePath)39 console.log(item.text)40 &#125;,41 // 事件响应函数42 viewTap: function() &#123;43 this.setData(&#123;44 text: 'Set some data for updating view.'45 &#125;, function() &#123;46 // this is setData callback47 &#125;)48 &#125;,49 // 自由数据50 customData: &#123;51 hi: 'MINA'52 &#125;53&#125;) 小程序.js 脚本逻辑文档","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Node操作mongodb","slug":"node/node03","date":"2021-02-22T16:00:00.000Z","updated":"2023-10-20T06:07:54.168Z","comments":true,"path":"2021/02/23/node/node03/","link":"","permalink":"http://yoursite.com/2021/02/23/node/node03/","excerpt":"","text":"mongodb模块 安装1npm install mongodb --save mongodb模块的文档 https://www.npmjs.com/package/mongodb node操作mongodb1const MongoClient = require('mongodb')2// mongodb数据库地址3const url = 'mongodb://localhost:27017'4// 数据库5const dbName = 'mydb'6// 建立连接7MongoClient.connect(8 url,9 &#123;10 useUnifiedTopology: true11 &#125;,12 (err, client) =&gt; &#123;13 // 异常处理14 if (err) &#123;15 console.log('mongodb connet error', err)16 return17 &#125;18 // 没有报错，连接成功19 console.log(\"mongodb connect success\")20 // 切换到数据库，相当于 use dbName21 const db = client.db(dbName)22 // 连接集合23 const myCollection = db.collection('myCollection')24 // 查询数据25 myCollection.find().toArray((err, result) =&gt; &#123;26 if (err) &#123;27 console.error('myCollection find error', err)28 return29 &#125;30 // 输出查询结果31 console.log(result);32 // 关闭连接33 client.close()34 &#125;)35 &#125;36) 连接mongodb，切换到数据库，找到对应集合，进行增删改查。具体参考mongodb模块的文档 https://www.npmjs.com/package/mongodb mongoose模块 安装1npm install mongoose --save mongoose模块文档 https://www.npmjs.com/package/mongoose （npm） https://mongoosejs.com/ （官方文档） mongoose连接数据库1const mongoose = require('mongoose')2const url = 'mongodb://localhost:27017'3const dbName = 'myblog'4// 执行连接5mongoose.connect(`$&#123;url&#125;/$&#123;dbName&#125;`, &#123;6 useNewUrlParser: true,7 useUnifiedTopology: true,8 useFindAndModify: false,9 useCreateIndex: true10&#125;);11// 创建连接对象12const db = mongoose.connection13// 异常监听处理14db.on('error', (err) =&gt; &#123;15 console.error(err)16&#125;)17// 连接成功18// db.on('open', () =&gt; &#123;19// console.log('mongoose connect success')20// &#125;)21module.exports = mongoose mongoose.connect(‘mongodb://username:password@host:port/database’); 如果数据库开启校验 需要账户密码时 使用此规则对数据库进行连接。 Schema定义数据格式的规范，以Model规范Collection1const mongoose = require('../db')2// 用 Schema 定义数据规范3const UserSchema = mongoose.Schema(&#123;4 username: &#123;5 type: String,6 required: true,// 必须7 unique: true // 唯一，不能重复8 &#125;,9 password: String,10 realname: String11&#125;)12// Model 对应 collection13const User = mongoose.model('user', UserSchema) // user可不用加s14module.exports = User Schame文档 https://mongoosejs.com/docs/api/schema.html Model 对文档进行增删改查1const User = require('../modules/User')2// insert一条数据3// User.create(&#123;4// username: 'zhangsan',5// password: '123',6// realname: '张三'7// &#125;, (err, result) =&gt; &#123;8// if (err) &#123;9// console.error('User create error', err)10// return11// &#125;12// console.log('result :&gt;&gt; ', result);13// &#125;)14// 或者15// User.create(&#123;16// username: 'lisi',17// password: '123',18// realname: '李四'19// &#125;).then((result) =&gt; &#123;20// console.log('result', result)21// &#125;)22// delete一条数据23// User.deleteOne(&#123;24// username: 'aaa',25// password: '123'26// &#125;).then((result) =&gt; &#123;27// console.log('result', result)28// &#125;)29// update 一条数据30// User.updateOne(31// &#123;32// username: 'lisi',33// password: '123'34// &#125;,35// &#123;36// $set: &#123; realname: '历史' &#125;37// &#125;38// ).then((result) =&gt; &#123;39// console.log('result', result)40// &#125;)41// find 数据42User.find()43 .sort(&#123; _id: -1 &#125;)44 .skip(1)45 .limit(1)46 .then((result) =&gt; &#123;47 console.log('result', result)48 &#125;) model 操作集合 即可以通过回调函数的形式读取操作结果，也可以通过Promise.then读取结果model 的api 文档具体请查看 https://mongoosejs.com/docs/api/model.html","categories":[{"name":"node","slug":"node","permalink":"http://yoursite.com/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"mongodb基本使用","slug":"server/server04","date":"2021-02-16T16:00:00.000Z","updated":"2023-10-20T04:29:22.664Z","comments":true,"path":"2021/02/17/server/server04/","link":"","permalink":"http://yoursite.com/2021/02/17/server/server04/","excerpt":"","text":"环境准备 mongodb安装 社区版本安装1brew install mongodb-community https://github.com/mongodb/homebrew-brew （文档） mongodb服务启动/停止 启动1brew services start mongodb-community 停止1brew services stop mongodb-community 下载mongodb可视化工具 例如 Navicat Premium mongodb简介 数据库 mongodb是一个数据的服务或者系统。一个数据库系统可以对接多个服务，一个服务也可以对接多个数据库。 集合collection 集合是mongodb的文档组，存在于数据库中。 文档document 文档是单条数据，可以被增删改查。 bson mongodb内数据存储是一以一种二进制类型的json存储的，数据格式是一种json的格式。 NoSQL mongodb 与 一些关系型数据库不同，不需要使用SQL语句查询。 mongodb区别于关系型数据库 mysql mongodb 数据库 数据库 表格 集合 行 文档 列 字段 主键 mongodb 默认主键 _id mongodb 常用命令 数据库 产看数据库列表1show dbs 切换数据库1use mydb 当存在数据库时，切换到该数据库。当不存在数据库时，创建该数据库，并切换到该数据库。 删除数据库1use mydb2db.dropDatabase() 先切换到需要删除的数据库，然后执行db.dropDatabase()删除数据库。 集合collection 查看当前数据库集合列表1show collections 1show tables 插入文档1db.myCollection.insert(&#123;name:&quot;wangxiaoqi&quot;&#125;) 当存在集合时，向集合中插入一条数据。当集合不存在时，创建新的集合并插入数据。 删除集合1db.myCollecction.drop() 插入文档 insert 插入一条或多条数据1db.myCollection.insert(&#123;number:1&#125;) &#x2F;&#x2F; 插入单条数据2db.myCollection.insert([&#123;number:2&#125;,&#123;number:3&#125;]) &#x2F;&#x2F; 插入多条数据 insertOne 插入一条数据1db.myCollection.insertOne(&#123;number:4&#125;) insertMany 插入多条数据1db.myCollection.insertMany([&#123;number:5&#125;,&#123;number:6&#125;]) 更新文档 update 语法格式1db.myCollection.update(2 &lt;query&gt;,3 &lt;update&gt;,4 &#123;5 upsert: &lt;boolean&gt;,6 multi: &lt;boolean&gt;,7 writeConcern: &lt;ducument&gt;8 &#125;9) query: update的查询条件，类似sql update查询内where后面的update: update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的upsert: 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入multi: 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新writeConcern: 可选，抛出异常的级别 update1db.myCollection.update(&#123;number:6&#125;,&#123;$set:&#123;number:66&#125;&#125;,&#123;multi:true&#125;) 匹配number为6的文档，文档的number字段全部更新为66。 删除文档 remove 语法格式1db.myCollection.remove(2 &lt;query&gt;3 &#123;4 justOne: &lt;boolean&gt;,5 writeConcern: &lt;document&gt;6 &#125;7) query: (可选) 删除的文档的条件justOne: (可选) 如果设为 true 或 1，则只删除第一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档writeConcern: (可选) 抛出异常的级别 remove1db.myCollection.remove(&#123;number:66&#125;,&#123;justOne:true&#125;) 删除第一个number为66的文档。 删除所有数据1db.myCollection.remove(&#123;&#125;) 1db.myCollection.deleteMany(&#123;&#125;) deleteOne 删除匹配的第一条文档1db.myCollection.deleteOne(&#123;number:2&#125;) deleteMany 删除匹配到的所有文档1db.myCollection.deleteMany(&#123;number:2&#125;) 查询文档 find 语法格式1db.myCollection.find(query) query: 可选，使用查询操作符指定查询条件 条件操作符 操作 格式 范例 等于 {key:valve} db.myCollection.find({number:1}) 小于 {key:{$lt:value}} db.myCollection.find({number:{$lt:5}}) 小于等于 {key:{$lte:value}} db.myCollection.find({number:{$lte:5}}) 大于 {key:{$gt:value}} db.myCollection.find({number:{$gt:5}}) 大于等于 {key:{$gte:value}} db.myCollection.find({number:{$gte:5}}) 不等于 {key:{$ne:value}} db.myCollection.find({number:{$ne:5}}) 1db.myCollection.find(&#123;number:&#123;$gt:2,$lt:5&#125;&#125;) number 大于2小于5的文档。 and条件1db.myCollection.find(&#123;number:&#123;$gt:1&#125;,author:&quot;zhangsan&quot;&#125;) 传入多个键(key)，每个键(key)以逗号隔开，相当于 SQL 的 AND 条件。 or条件1db.myCollection.find(&#123;2 $or:[3 &#123;number:1,author:&quot;zhangsan&quot;&#125;,4 &#123;number:&#123;$gt:5&#125;&#125;5 ]6&#125;) $or 数组中 每个对象的查询结果，得到的并集。 and与or组合1db.myCollection.find(&#123;2 number:7,3 $or:[&#123;number:1&#125;,&#123;number:&#123;$gt:5&#125;&#125;]4&#125;) query 中 查询条件交集的结果。 模糊查询1db.myCollection.find(&#123;description:&#x2F;XXX&#x2F;&#125;)2&#x2F;&#x2F; 或者3db.myCollection.find(&#123;description:&#123;$regex:&#x2F;XXX&#x2F;&#125;&#125;) 查询description中包含 ‘XXX’ 的文档。 1db.myCollection.find(&#123;description:&#x2F;^XXX&#x2F;&#125;) 查询description字段以 'XXX 开头的文档。 1db.myCollection.find(&#123;description:&#x2F;XXX$&#x2F;&#125;) 查询description 字段以 'XXX' 结尾的文档。 limit指定数目1db.myCollection.find().limit(2) limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数 skip跳过数目1db.myCollecion.find().skip(2) skip方法接受一个数字参数作为跳过的记录条数 sort 排序1db.myCollection.find().sort(&#123;number:-1&#125;) sort方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列 skip、limit、sort 联合1db.myCollection.find().skip(2).limit(2).sort(&#123;number:-1&#125;) skip(), limilt(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()。","categories":[{"name":"server","slug":"server","permalink":"http://yoursite.com/categories/server/"}],"tags":[{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"pm2基本使用","slug":"server/server07","date":"2021-02-08T16:00:00.000Z","updated":"2023-10-20T04:30:01.156Z","comments":true,"path":"2021/02/09/server/server07/","link":"","permalink":"http://yoursite.com/2021/02/09/server/server07/","excerpt":"","text":"安装 pm2 安装1npm insrall pm2 -g 版本查看1pm2 --version pm2 常用命令 启动服务1pm2 start ... 可以是项目入口文件如 app.js，也可以是pm2配置文件 如pm2.conf.json。 查看列表1pm2 list 重启服务1pm2 restart (name &#x2F; id) 停止服务1pm2 stop (name &#x2F; id) 删除服务1pm2 delete (name &#x2F; id) 进程日志1pm2 log (name &#x2F; id) 进程基本信息1pm2 info (name &#x2F; id) 监听进程cpu内存信息1pm2 monit (name &#x2F; id) pm2 功能介绍 进程守护 由于 NodeJs 是单线程执行的，所以主线程抛出了一个错误就会退出程序。所以线上部署的项目需要进程守护，当程序崩溃时重启服务。 日志管理 console.log打印的文本默认会输出到 .pm2/logs/app-out.log 中。 console.error 打印的文本默认会输出到 .pm2/logs/app-error.log 中。 多进程 为了充分利用服务器资源，pm2可以对node服务进行多进程管理 多进程之间，内存无法共享。可以使用访问同一个redis实现数据共享 配置项 pm2启动配置项 pm2 start pm2.conf.json 1&#123;2 \"apps\": &#123;3 // 进程名称4 \"name\": \"pm2-test-server\",5 // 启动文件的相对路径6 \"script\": \"app.js\",7 // 文件发生变化是否重启服务8 \"watch\": false,9 // 忽略因文件变化而重启服务10 \"ignore_watch\": [11 \"node_modules\",12 \"logs\"13 ],14 // 进程数量，一般为电脑核数15 \"instances\": 4,16 // 错误日志的相对路径17 \"error_file\": \"logs/err.log\",18 // 自定义日志文件的相对路径19 \"out_file\": \"logs/out.log\",20 // 为每行日志添加时间前缀21 \"log_date_format\": \"YYYY-MM-DD HH:mm:ss\"22 &#125;23&#125;","categories":[{"name":"server","slug":"server","permalink":"http://yoursite.com/categories/server/"}],"tags":[{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"koa2基本使用","slug":"server/server03","date":"2021-02-06T16:00:00.000Z","updated":"2023-10-20T04:29:08.421Z","comments":true,"path":"2021/02/07/server/server03/","link":"","permalink":"http://yoursite.com/2021/02/07/server/server03/","excerpt":"","text":"安装 koa2 脚手架1npm install koa2-generator -g 1&#x2F;&#x2F; 项目生成2koa2 project 初始化项目结构介绍 koa2 初始化项目结构 koa2 初始化项目介绍 koa2 app.js 入口文件介绍 1// 错误处理2onerror(app) 1// post请求中传递的数据处理成json 解析至 ctx.request.body2app.use(bodyparser(&#123;3 enableTypes:['json', 'form', 'text']4&#125;))5app.use(json())6// ...7// get请求中地址栏中的数据 解析至 ctx.query / ctx.request.query ctx 结构 koa2中文文档 路由处理 创建 get post 路由1const router = require('koa-router')()2// 路由前缀3router.prefix('/api') 4router.get('/get', async (ctx, next) =&gt; &#123;5 ctx.body = &#123;6 errno: 0,7 results: &#123;8 message: '这是一个get请求测试信息！',9 data: ctx.query10 &#125;11 &#125;12&#125;)13router.post('/post', async (ctx, next) =&gt; &#123;14 ctx.body = &#123;15 errno: 0,16 results: &#123;17 message: '这是一个post请求测试信息！',18 data: ctx.request.body19 &#125;20 &#125;21&#125;)22module.exports = router 注册路由1const testsRouter = require('./routes/tests');2...3app.use(testsRouter.routes(), testsRouter.allowedMethods()) 洋葱圈模型 洋葱圈模型图 当 koa2 server 接受到一个请求时，会先经过第一个洋葱圈（如图外层最大的洋葱圈），依次再进入内层洋葱圈，最内层的洋葱圈最后到达但会最先被执行完成，第一个洋葱圈最先到达但会最后执行完成。 代码演示 1const Koa = require('koa');2const app = new Koa();3app.use(async (ctx, next) =&gt; &#123;4 console.log('第一层洋葱圈 开始');5 await next();6 const rt = ctx.response.get('X-Response-Time');7 console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;rt&#125;`);8 console.log('第一层洋葱圈 结束');9&#125;);10app.use(async (ctx, next) =&gt; &#123;11 console.log('第二层洋葱圈 开始');12 const start = Date.now();13 await next();14 const ms = Date.now() - start;15 ctx.set('X-Response-Time', `$&#123;ms&#125;ms`);16 console.log('第二层洋葱圈 结束');17&#125;);18app.use(async ctx =&gt; &#123;19 console.log('第三层洋葱圈 开始');20 ctx.body = 'Hello World';21 console.log('第三层洋葱圈 结束');22&#125;);23app.listen(3000); 执行结果 当 koa2 server 接受到一个请求时，第一个中间件会先被触发，再依次触发内层其他中间件，最内层中间件最后触发但会最先执行完成，第一个中间件最先触发但最后执行完成。 中间件原理 收集并注册中间件 创建执行中间件函数 封装ctx 实现next 1const http = require('http');2// 实现next 并对中间件实现promise处理3function componse(middlewareList) &#123;4 return function (ctx) &#123;5 function dispatch(i) &#123;6 const middleware = middlewareList[i]7 try &#123;8 Promise.resolve(9 // 注意fn.bind()返回的是一个函数并不直接执行函数本身10 middleware(ctx, dispatch.bind(null, i + 1))11 )12 &#125; catch (error) &#123;13 Promise.reject(error)14 &#125;15 &#125;16 dispatch(0)17 &#125;18&#125;19class LikeKoa2 &#123;20 constructor() &#123;21 this.middlewareList = []22 &#125;23 // 收集注册中间件24 use(fn) &#123;25 if (typeof fn === 'function') &#123;26 this.middlewareList.push(fn)27 return this28 &#125;29 &#125;3031 createContent(req, res) &#123;32 const ctx = &#123;33 req,34 res35 &#125;36 ctx.query = req.query37 return ctx38 &#125;39 handleRequest(fn, ctx) &#123;40 return fn(ctx)41 &#125;42 callback() &#123;43 const fn = componse(this.middlewareList)44 return (req, res) =&gt; &#123;45 const ctx = this.createContent(req, res)46 this.handleRequest(fn, ctx)47 &#125;48 &#125;49 // server50 listen() &#123;51 const server = http.createServer(this.callback())52 server.listen(...arguments)53 &#125;54&#125;55module.exports = LikeKoa2","categories":[{"name":"server","slug":"server","permalink":"http://yoursite.com/categories/server/"}],"tags":[{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"express基本使用","slug":"server/server02","date":"2021-02-01T16:00:00.000Z","updated":"2023-10-20T04:28:56.177Z","comments":true,"path":"2021/02/02/server/server02/","link":"","permalink":"http://yoursite.com/2021/02/02/server/server02/","excerpt":"","text":"安装 express 脚手架1npm install express-generator -g 1&#x2F;&#x2F; 项目生成2express project 单独express安装1npm install express --save 初始化项目结构介绍 express 初始化项目结构 express 初始化项目介绍 express app.js入口文件介绍1// 处理未命中路由 404 情况2var createError = require('http-errors'); 1// 将请求头中req.headers.cookie字符串 解析成 req.cookies 对象2var cookieParser = require('cookie-parser'); 1// 处理入口日志2var logger = require('morgan'); 1// 将post请求中的数据流 处理成 req.body 对象2app.use(express.json());3app.use(express.urlencoded(&#123; extended: false &#125;));4// ...5// get请求中地址栏的数据也会被express 处理成 req.query 对象 路由处理 创建 get post 路由 1const express = require('express');2const router = express.Router();3// 处理get请求4router.get('/get', (req, res, next) =&gt; &#123;5 res.json(&#123;6 errno: 0,7 results: &#123;8 message: '这是一个get请求测试信息！',9 data: req.query10 &#125;11 &#125;)12&#125;);13// 处理post请求14router.post('/post', (req, res, next) =&gt; &#123;15 res.json(&#123;16 errno: 0,17 results: &#123;18 message: '这是一个post请求测试信息！',19 data: req.body20 &#125;21 &#125;)22&#125;);23module.exports = router; 路由注册 1const testsRouter = require('./routes/tests');2...3app.use('/api/tests', testsRouter); 中间件介绍 中间件执行顺序1const express = require('express');2const app = express()3app.use((req, res, next) =&gt; &#123;4 console.log('请求开始。。。 :&gt;&gt; ', req.method, req.url);5 next()6&#125;)7app.use((req, res, next) =&gt; &#123;8 // 假设处理cookie9 req.cookies = &#123; userId: 'xxx123' &#125;10 next()11&#125;)12app.use((req, res, next) =&gt; &#123;13 // 假设处理异步14 setTimeout(() =&gt; &#123;15 req.body = &#123; a: 100, b: 200 &#125;16 next()17 &#125;, 1000);18&#125;)19app.use('/api', (req, res, next) =&gt; &#123;20 console.log('处理 /api 路由');21 next()22&#125;)23app.get('/api', (req, res, next) =&gt; &#123;24 console.log('get /api 路由');25 next()26&#125;)27app.post('/api', (req, res, next) =&gt; &#123;28 console.log('post /api 路由');29 next()30&#125;)31// 模拟登陆验证32function loginCheck(req, res, next) &#123;33 setTimeout(() =&gt; &#123;34 console.log('模拟登陆失败');35 res.json(&#123; errno: -1, msg: '登陆失败' &#125;)36 &#125;);37&#125;38// 中间件自左向右执行39app.get('/api/get-cookie', loginCheck, (req, res, next) =&gt; &#123;40 console.log('get /api/get-cookie');41 res.json(&#123; errno: 0, datd: req.cookies &#125;)42&#125;)43app.post('/api/get-post-data', (req, res, next) =&gt; &#123;44 console.log('post /api/get-post-data');45 res.json(&#123; errno: 0, datd: req.body &#125;)46&#125;)47app.use((req, res, next) =&gt; &#123;48 console.log('处理 404')49 res.json(&#123; errno: -1, msg: '404 not found' &#125;)50&#125;)51app.listen(3000, () =&gt; &#123;52 console.log('server is running on port 3000')53&#125;) 1.app.use()会默认访问任何路由，如果第一个参数为路由的路径，则只会访问当前路径下的路由。2.中间件的执行顺序按照，app.use中自左向右，代码中自上而下的顺序执行。3.app.get()与app.use()基本一致，不同的是app.get()只处理get类型的请求。4.app.post()与app.use()基本一致，不同的是app.post()只处理post类型的请求。 中间件原理 收集并注册中间件 匹配要执行的中间件 next1const http = require('http');2const slice = Array.prototype.slice3class LikeExpress &#123;4 constructor() &#123;5 this.routers = &#123;6 all: [],7 get: [],8 post: []9 &#125;10 this.middlewareSort = 011 &#125;1213 // 中间件收集注册 - start14 register(path) &#123;15 let currentMiddlewareList = []16 if (typeof path !== 'string') &#123;17 path = '/'18 currentMiddlewareList = slice.call(arguments, 0)19 &#125; else &#123;20 currentMiddlewareList = slice.call(arguments, 1)21 &#125;22 const currentRoutersList = []23 currentMiddlewareList.forEach(middleware =&gt; &#123;24 const router = &#123;&#125;25 this.middlewareSort++26 router.sort = this.middlewareSort27 router.path = path28 router.stack = middleware29 currentRoutersList.push(router)30 &#125;)31 return currentRoutersList32 &#125;33 use() &#123;34 const allRouters = this.register(...arguments)35 this.routers.all = this.routers.all.concat(allRouters)36 &#125;37 get() &#123;38 const getRouters = this.register(...arguments)39 this.routers.get = this.routers.get.concat(getRouters)40 &#125;41 post() &#123;42 const postRouters = this.register(...arguments)43 this.routers.post = this.routers.post.concat(postRouters)44 &#125;45 // 中间件收集注册 - end4647 match(method, url) &#123;48 let routersList = []49 routersList = this.routers.all.concat(this.routers[method]).filter(item =&gt; url.includes(item.path))50 const stackList = routersList.sort((a, b) =&gt; a.sort - b.sort).map(item =&gt; item.stack)51 return stackList52 &#125;53 handle(req, res, stackList) &#123;54 const next = () =&gt; &#123;55 let stack = stackList.shift()56 if (stack) &#123;57 stack(req, res, next)58 &#125;59 &#125;60 next()61 &#125;62 callback() &#123;63 return (req, res) =&gt; &#123;64 let method = req.method.toLowerCase()65 let url = req.url66 // 处理 /favicon.ico67 if (req.url == '/favicon.ico') &#123; return &#125;68 // \b扩展res.json69 res.json = (data) =&gt; &#123;70 res.setHeader('content-type', 'application/json')71 res.end(72 JSON.stringify(data)73 )74 &#125;75 // 1. 匹配要执行的中间件76 const stackList = this.match(method, url)77 // 2. next 执行78 this.handle(req, res, stackList)79 &#125;80 &#125;81 // server82 listen() &#123;83 const server = http.createServer(this.callback())84 server.listen(...arguments)85 &#125;86&#125;87function express() &#123;88 return new LikeExpress()89&#125;90module.exports = express debugger 调试 package.json配置1&quot;scripts&quot;: &#123;2 &quot;start&quot;: &quot;node --inspect&#x3D;9229 .&#x2F;bin&#x2F;www&quot;3&#125; 浏览器地址打开chrome://inspect或者about:inspect","categories":[{"name":"server","slug":"server","permalink":"http://yoursite.com/categories/server/"}],"tags":[{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"Node操作文件","slug":"node/node02","date":"2021-01-29T16:00:00.000Z","updated":"2023-10-20T06:07:41.535Z","comments":true,"path":"2021/01/30/node/node02/","link":"","permalink":"http://yoursite.com/2021/01/30/node/node02/","excerpt":"","text":"path 模块 path.resolve([…paths]) 把片段路径解析为绝对路径 1const path = require('path');2const dataFilePath = path.resolve(__dirname, './src/data.txt')3console.log(dataFilePath); // /Users/wangxiaoqi/Documents/learn/node/path-test/src/data.txt __dirname 总是指向被执行 js 文件的绝对路径 path.join([…paths]) 使用平台(mac linux windows)特定的分隔符把全部给定的 path 片段连接到一起，并规范化生成的路径。 1const path = require('path');2const joinPathName = path.join('a', 'b', 'c/d', 'e', '..')3console.log(joinPathName); // /a/b/c/d .. 表示上一层 path.relative(from, to) 从 from 到 to 的相对路径 1const path = require('path');2const aRelativeCPath = path.relative('/path-test/a', '/path-test/b/c')3console.log(aRelativeCPath); // ../b/c fs 模块 fs.readFile() 读取文件 1const fs = require('fs');2const path = require('path');3const dataFilePath = path.resolve(__dirname, 'data.txt')4// 读取文件5fs.readFile(dataFilePath, (err, data) =&gt; &#123;6 if (err) &#123;7 console.error(err);8 return9 &#125;10 // 文件是一个buffer二进制利流11 console.log('data :&gt;&gt; ', data.toString());12&#125;) fs.writeFile() 写入文件 1const fs = require('fs');2const path = require('path');3const dataFilePath = path.resolve(__dirname, 'data.txt')4const content = '写入data.txt文件内的内容\\n'5const opt = &#123;6 flag: 'a' // a 追加写入；w 覆盖写入(默认)7&#125;8fs.writeFile(dataFilePath, content, opt, (err) =&gt; &#123;9 if (err) &#123;10 console.error(err);11 &#125;12&#125;) fs.existsSync() 判断文件是否存在（同步操作） 1const fs = require('fs');2const path = require('path');3const dataFilePath = path.resolve(__dirname, 'data.txt')4// 判断文件是否存在5const isDataFile = fs.existsSync(dataFilePath)6console.log(isDataFile); stream Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。 nodejs stream 标准输入输出1process.stdin.pipe(process.stdout) request发起请求1const http = require('http');2const server = http.createServer((req,res) =&gt; &#123;3 if (req.method === 'POST') &#123;4 req.pipe(res)5 &#125;6&#125;)7server.listen(5000) stream 流的方式对文件拷贝1const path = require('path');2const fs = require('fs');3const dataFilePath = path.resolve(__dirname,'./data.txt')4const dataBakFilePath = path.resolve(__dirname,'./data-bak.txt')5// 创建读取流对象6const readStream = fs.createReadStream(dataFilePath)7// 创建写入流对象8const writeStream = fs.createWriteStream(dataBakFilePath)9readStream.pipe(writeStream)10// data 监听每次流的写入11readStream.on('data',(chunk) =&gt; &#123;12 console.log(chunk.toString());13&#125;)14// end 监听流的结束15readStream.on('end',() =&gt; &#123;16 console.log('copy done')17&#125;) stream 操作网络IO1const http = require('http');2const path = require('path');3const fs = require('fs');4const dataFilePath = path.resolve(__dirname,'./data.txt')5// 创建读取流对象6const readStream = fs.createReadStream(dataFilePath)7const server = http.createServer((req,res) =&gt; &#123;8 if (req.method === 'GET') &#123;9 readStream.pipe(res)10 &#125;11&#125;)12server.listen(5000) 流的方式读文件1// 1. 创建读取流2const stream = fs.createReadStream(path)3// 2. 绑定data事件接受数据4stream.on(\"data\", (data) =&gt; &#123;5 console.log(data)6&#125;)7// 3. 绑定end事件表示读取完毕8stream.on(\"end\", () =&gt; &#123;9 console.log(\"数据流读取完毕\")10&#125;)11// 4. 绑定error错误事件12stream.on(\"error\", (err) =&gt; &#123;13 throw err14&#125;) 流的方式写文件1// 1. 创建写入流2const opt = &#123;3 flags: 'a' // a 追加写入；w 覆盖写入(默认)4&#125;5var stream = fs.createWriteStream(path, opt)6// 2. 写入数据7stream.write(\"数据1\")8// 3. 写入完毕后结束写入流9stream.end()10// 4. 数据写入完成事件11stream.on(\"finish\", () =&gt; &#123; &#125;)12// 5. 绑定error出错事件13stream.on(\"error\", (err) =&gt; &#123; &#125;)","categories":[{"name":"node","slug":"node","permalink":"http://yoursite.com/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"Nginx基本使用","slug":"server/server06","date":"2021-01-27T16:00:00.000Z","updated":"2023-10-21T01:58:40.312Z","comments":true,"path":"2021/01/28/server/server06/","link":"","permalink":"http://yoursite.com/2021/01/28/server/server06/","excerpt":"","text":"nginx常用命令 常用命令 nginx -t （测试配置文件格式是否正确） nginx （启动） nginx -c /xxx/**/nginx.conf （指定配置文件启动） nginx -s reload （重启） nginx -s stop （停止） nginx配置文件 配置文件结构 全局块1#user nobody nobody; #配置用户或者组。2worker_processes 1; #启动进程,通常设置成和cpu的数量相等3error_log log/error.log debug; #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg4#pid /nginx/pid/nginx.pid; #指定nginx进程运行文件存放地址 events块1events &#123;2 #accept_mutex on; #设置网路连接序列化，防止惊群现象发生，默认为on3 #multi_accept on; #设置一个进程是否同时接受多个网络连接，默认为off4 #epoll是多路复用IO(I/O Multiplexing)中的一种方式,5 #仅用于linux2.6以上内核,可以大大提高nginx的性能6 #use epoll; #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport7 worker_connections 1024; #单个后台worker process进程的最大并发链接数 8&#125; http块1http &#123;2 include mime.types; #文件扩展名与文件类型映射表3 default_type application/octet-stream; #默认文件类型，默认为text/plain 4 log_format myFormat '$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for'; #自定义格式5 access_log log/access.log myFormat; #combined为日志格式的默认值6 sendfile on; #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。7 error_page 404 /404.html; #错误页8 server &#123;&#125;9&#125; server块1server &#123;2 listen 4545; #监听端口3 server_name 127.0.0.1; #监听地址 4 root html; #定义服务器的默认网站根目录位置5 location ~*^.+$ &#123;&#125; #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。6&#125; location块1#对 \"/\" 启用反向代理2location / &#123;3 proxy_pass http://localhost:8000;4&#125; 动静分离 配置location1location / &#123;2 root /www/server/nginx/app;3 expires 1d;4&#125; 1.root 静态资源相对于服务器根目录的位置2.expires 设置浏览器缓存过期时间。1d 表示1天之内访问这个URL，发送一个请求，对比服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码304，如果有修改则直接从服务器重新下载，返回状态码200。 反向代理 配置 server1server&#123;2 listen 8866;3 server_name localhost;4&#125; 配置 location1location /api/ &#123;2 proxy_pass http://localhost:8000;3 proxy_set_header Host $host;4&#125; 1.proxy_pass 代理server地址2.proxy_set_header 即允许重新定义或添加字段传递给代理服务器的请求头。该值可以包含文本、变量和它们的组合。在没有定义proxy_set_header时会继承之前定义的值。 proxy_set_header Host $host; 使用$host变量 它的值在原始请求包含Host请求头时为Host字段的值，在请求未携带Host请求头时为nginx代理服务器的地址。 proxy_set_header Host $http_host; 原始请求Host请求头的值 示例 单页应用的常规配置1worker_processes 1;2events &#123;3 worker_connections 1024;4&#125;5http &#123;6 include &#x2F;opt&#x2F;homebrew&#x2F;etc&#x2F;nginx&#x2F;mime.types;7 default_type application&#x2F;octet-stream;8 #log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;9 # &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;10 # &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;11 #access_log logs&#x2F;access.log main;12 keepalive_timeout 65;13 gzip on; #开启 gzip 压缩输出 14 gzip_min_length 1k; #最小压缩文件大小15 gzip_buffers 4 16k; #压缩缓冲区16 gzip_http_version 1.1; #压缩版本（默认 1.1，前端如果是 squid2.5 请使用 1.0） 17 gzip_comp_level 2; #压缩等级 (1 最小处理最快, 9 处理最慢传输速度最快)18 gzip_types text&#x2F;plain application&#x2F;x-javascript text&#x2F;css application&#x2F;xml; #压缩类型，默认就已经包含 text&#x2F;html19 gzip_vary on; #设置为开启，服务器返回数据时会在头部带上&quot;Vary:Accept-Encoding&quot;的标识, 默认关闭20 server &#123;21 listen 8080;22 server_name localhost;23 # 静态资源路由24 location &#x2F; &#123;25 root &#x2F;Users&#x2F;aaa&#x2F;Desktop&#x2F;FS&#x2F;xxx&#x2F;dist;26 try_files $uri $uri&#x2F; &#x2F;index.html;27 index index.html;28 &#125;29 location &#x2F;api &#123;30 proxy_pass https:&#x2F;&#x2F;xxx.com;31 &#125;32 &#125;33&#125; try_files：尝试提供请求的文件或回退到 /index.htmlinclude 和 default_type：include 指令包含了 mime.types 文件，该文件定义了文件扩展名和对应的MIME类型之间的映射关系。default_type 指令设置了文件的默认MIME类型。","categories":[{"name":"server","slug":"server","permalink":"http://yoursite.com/categories/server/"}],"tags":[{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"Node操作redis","slug":"node/node05","date":"2021-01-26T16:00:00.000Z","updated":"2023-10-20T06:08:21.753Z","comments":true,"path":"2021/01/27/node/node05/","link":"","permalink":"http://yoursite.com/2021/01/27/node/node05/","excerpt":"","text":"下载安装 redis 安装 windows https://www.runoob.com/redis/redis-install.html Mac 使用 brew install redis node模块 安装 npm install redis -S redis常用命令 连接操作命令 redis-server （本地开启服务-mac） redis-cli shutdown (停止服务) redis-cli （本地连接命令-mac） quit （关闭当前连接） 操作命令 keys * （查看数据列表） get key （查看当前key的值） set key value （insert 数据） del key （删除数据） node对接redis node redis 模块1const redis = require('redis')2// 创建客户端3const redisClient = redis.createClient(6379, '127.0.0.1')4redisClient.on('error', err =&gt; &#123;5 console.error(err);6&#125;)7// 插入数据8redisClient.set('myname', 'zhangsan', redis.print)9// 获取数据10redisClient.get('myname', (err, val) =&gt; &#123;11 if (err) &#123;12 console.error(err);13 return14 &#125;15 // 退出客户端连接16 redisClient.quit()17&#125;) redis 配置项抽离1// 环境变量2const env = process.env.NODE_ENV3// 配置4let REDIS_CONF5// 本地开发6if (env === 'dev') &#123;7 REDIS_CONF = &#123;8 port: 6379,9 host: '127.0.0.1'10 &#125;11&#125;12// 开发配置 todo13if (env === 'prod') &#123;14 REDIS_CONF = &#123;15 port: 6379,16 host: '127.0.0.1'17 &#125;18&#125;19module.exports = &#123;20 REDIS_CONF21&#125; redis 工具函数封装1const redis = require('redis');2const &#123; REDIS_CONF &#125; = require('../conf/db');3// 创建redis链接4const redisClient = redis.createClient(REDIS_CONF.port, REDIS_CONF.host)5redisClient.on('error', err =&gt; &#123;6 console.error(err)7&#125;)8// 存值函数9function set(key, val) &#123;10 if (typeof val === 'object') &#123;11 val = JSON.stringify(val)12 &#125;13 redisClient.set(key, val, redis.print)14&#125;15// 取值函数16function get(key) &#123;17 const p = new Promise((resolve, reject) =&gt; &#123;18 redisClient.get(key, (err, val) =&gt; &#123;19 // 异常处理20 if (err) &#123;21 reject(err)22 return23 &#125;24 // val 为 null 情况25 if (val === null) &#123;26 resolve(null)27 return28 &#125;29 // val 为json字符串 以及 普通字符串情况30 try &#123;31 resolve(JSON.parse(val))32 &#125; catch (error) &#123;33 resolve(val)34 &#125;35 &#125;)36 &#125;)37 return p38&#125;39module.exports = &#123;40 set,41 get42&#125;","categories":[{"name":"node","slug":"node","permalink":"http://yoursite.com/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"Cookie","slug":"server/server01","date":"2021-01-23T16:00:00.000Z","updated":"2023-10-20T04:28:37.826Z","comments":true,"path":"2021/01/24/server/server01/","link":"","permalink":"http://yoursite.com/2021/01/24/server/server01/","excerpt":"","text":"cookie 特点 cookie 是存储在浏览器中的一段字符串，无数据结构的，但是统一约定为key=value; key=value（分号后紧接着空格）的一串字符串，大小一般不超过4k。 发起http请求，会自动携带http请求所在域名的cookie。 cookie 重要属性 属性说明 属性 说明 domain 指定cookie所属的域名，默认是当前域名 path 指定cookie在哪个路径（路由下生效） maxAge cookie失效日期，单位秒。如果为整数，则该cookie在maxAge秒后失效。如果为负数，该cookie为临时cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该cookie。如果为0，标识删除该cookie。默认为-1 expires 过期时间，在设置的某个时间点后该cookie就会消失。时间要转成GMT形式，toGMTString()。 一般浏览器的cookie都是默认存储的，当关闭浏览器结束这个回话的时候，这个cookie也就会被删除 secure 该cookie是否仅被使用安全协议传输。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认false。 httpOnly 如果给某个cookie设置了httpOnly属性，则无法通过js脚本读取到该cookie信息，但是还是可以通过Application中手动修改cookie 前端操作cookie 前端通过 document.cookie 设置 cookie， 设置多个 cookie 则需要编写多条 document.cookie = ‘…’， 如果需要对 cookie 进行修改创建一条相同名称的 cookie 即可对 cookie 进行替换 设置cookie1/**2 * 通用方法： 设置cookie 方法3 * @param &#123;String&#125; name cookie 名称4 * @param &#123;String&#125; value cookie 值5 * @param &#123;Number&#125; maxAge cookie 存活时间（maxAge秒， 默认存储 30 天）6 */7function setCookie(&#123; name, value, maxAge &#125;) &#123;8 maxAge = maxAge || 30 * 24 * 60 * 60 * 1000;9 // escape： 对字符串进行编码10 document.cookie = `$&#123;name&#125;=$&#123;escape (value)&#125;;max-age=$&#123;maxAge&#125;`;11&#125; 创建：当document.cookie中没有相同的name时创建一个cookie修改：把对应document.cookie中的name的value直接替换删除：把对应document.cookie中的name的max-age设置为0 获取cookie1/**2 * 通用方法： 将 cookie 转为对象 &#123;anme: value&#125;3 * @return &#123;Object&#125; &#123;name, value&#125;4 */5function getCookieObj() &#123;6 let cookieArr = document.cookie.split(\";\");7 let obj = &#123;&#125;;8 cookieArr.forEach(v =&gt; &#123;9 let arr = v.split(\"=\");10 let key = arr[0].trim()11 let val = arr[1]12 obj[key] = unescape(val);13 &#125;);14 return obj15&#125; 后端操作cookie（nodejs） 服务端设置 cookie 主要是通过设置响应头 set-cookie 来设置 cookie， 如果需要设置多个 cookie 得多写几个 set-cookie 设置cookie 1const http = require('http');2http.createServer((request, response) =&gt; &#123;3 response.setHeader('Set-Cookie', 'token=xxx; path=/ ;max-age=30; httpOnly')4 response.end()5&#125;).listen(5000) 通过response设置cookie token值为xxx 当前域根路径 失效时间30秒 客户端不可以通过js操作 获取cookie 1const http = require('http');2http.createServer((request, response) =&gt; &#123;3 request.cookie = &#123;&#125;4 let cookieStr = request.headers.cookie || ''5 cookieStr.split(';').forEach(item =&gt; &#123;6 if (!item) &#123; return &#125;7 const arr = item.split('=')8 const key = arr[0].trim()9 const val = arr[1]10 request.cookie[key] = val11 &#125;);12 response.end()13&#125;).listen(5000) 通过request获取cookie","categories":[{"name":"server","slug":"server","permalink":"http://yoursite.com/categories/server/"}],"tags":[{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"Node操作MySQL","slug":"node/node04","date":"2021-01-20T16:00:00.000Z","updated":"2023-10-20T06:08:10.769Z","comments":true,"path":"2021/01/21/node/node04/","link":"","permalink":"http://yoursite.com/2021/01/21/node/node04/","excerpt":"","text":"下载安装 安装 mysql1npm install mysql -S 连接数据库 连接数据库1const mysql = require('mysql')2// 创建连接对象3const db = mysql.createConnection(&#123;4 host: 'localhost',5 user: 'root',6 password: 'xxxxxxx',7 port: '3306',8 database: 'myblog'9&#125;)10// 开始连接11db.connect()12// 执行sql语句13const sql = `INSERT INTO blogs (title,content,createtime,author) VALUES ('标题C','内容C',1611216592611,'wangwu');`14db.query(sql, (err, result) =&gt; &#123;15 if (err) &#123;16 console.error(err)17 return18 &#125;19 console.log('result :&gt;&gt; ', result);20&#125;)21// 结束连接22db.end() mysql项目配置 创建数据库连接配置1// 环境变量2const env = process.env.NODE_ENV3// 配置4let MYSQL_CONF5// 本地开发6if (env === 'dev') &#123;7 MYSQL_CONF = &#123;8 host: 'localhost',9 user: 'root',10 password: 'xxxxxxx',11 port: '3306',12 database: 'myblog'13 &#125;14&#125;15// 开发配置 todo16if (env === 'prod') &#123;17 MYSQL_CONF = &#123;18 host: 'localhost',19 user: 'root',20 password: 'xxxxxxx',21 port: '3306',22 database: 'myblog'23 &#125;24&#125;25module.exports = &#123;26 MYSQL_CONF27&#125; 连接数据库配置1const mysql = require('mysql');2const &#123; MYSQL_CONF &#125; = require('../conf/db');3// 创建连接对象4const db = mysql.createConnection(MYSQL_CONF)5// 开始连接6db.connect()7// 创建统一执行 sql 的函数8function exec(sql) &#123;9 const p = new Promise((resolve, reject) =&gt; &#123;10 db.query(sql, (err, result) =&gt; &#123;11 if (err) &#123;12 reject(err)13 return14 &#125;15 resolve(result)16 &#125;)17 &#125;)18 return p19&#125;20module.exports = &#123;21 exec22&#125; 暴露执行sql的函数exec并返回结果","categories":[{"name":"node","slug":"node","permalink":"http://yoursite.com/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"MySQL基本使用","slug":"server/server05","date":"2021-01-19T16:00:00.000Z","updated":"2023-10-20T04:29:35.965Z","comments":true,"path":"2021/01/20/server/server05/","link":"","permalink":"http://yoursite.com/2021/01/20/server/server05/","excerpt":"","text":"环境准备 mysql下载 下载地址https://dev.mysql.com/downloads/mysql/ 安装过程注意记住 root用户名的密码 下载mysql可视化工具 例如 Navicat Premium 常用字段属性 字符串数据类型 MySQL数据类型 含义 char(n) 固定长度，最多255个字符 varchar(n) 可变长度，最多65535个字符 tinytext 可变长度，最多255个字符 text 可变长度，最多65535个字符 mediumtext 可变长度，最多2的24次方-1个字符 longtext 可变长度，最多2的32次方-1个字符 1. char（n）和varchar（n）中括号中n代表字符的个数，并不代表字节个数，所以当使用了中文的时候(UTF8)意味着可以插入m个中文，但是实际会占用m*3个字节。 2. 同时char和varchar最大的区别就在于char不管实际value都会占用n个字符的空间，而varchar只会占用实际字符应该占用的空间+1，并且实际空间+1","categories":[{"name":"server","slug":"server","permalink":"http://yoursite.com/categories/server/"}],"tags":[{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"HTTP模块","slug":"node/node01","date":"2021-01-17T16:00:00.000Z","updated":"2023-10-20T06:07:28.219Z","comments":true,"path":"2021/01/18/node/node01/","link":"","permalink":"http://yoursite.com/2021/01/18/node/node01/","excerpt":"","text":"创建一个服务 node 提供http核心模块用于创建服务 1const http = require('http');2http.createServer((request, response) =&gt; &#123;3 response.writeHead(200, &#123; \"content-type\": \"text/plain\" &#125;)4 response.write(\"hello node\")5 response.end()6&#125;).listen(5000) 引入http模块，使用http.createServer函数创建一个服务调用response.writeHead设置响应头，第一个参数表示HTTP的响应状态，第二个参数“content-type”表示响应给客户端的类容类型调用response.write方法，写入传递给客户端的内容最后调用response.end表示此次请求已处理完成 .listen(port) 第一个参数表示监听端口号，第二个参数是监听开启后立即触发的回调函数 http.Server实例化创建一个服务，等同于上述代码 1const http = require('http');2const server = new http.Server()3server.on('request', (request, response) =&gt; &#123;4 response.writeHead(200, &#123; \"content-type\": \"text/plain\" &#125;)5 response.write(\"hello node\")6 response.end()7&#125;)8server.listen(5000) 通过创建一个http.Server对象，然后为其添加request事件监听的方式创建的服务等同于http.cresteServer createServer方法中的两个参数request和response分别代表了请求对象和响应对象。 request 是 http.IncomingMessage 的实例 response 是 http.ServerResponse 的实例 http.IncomingMessage是HTTP请求的信息，包含三个事件 data: 当请求体数据到来时，该事件被触发，该事件提供一个chunk，表示接受的数据。如果该事件没有被监听，则请求体会被抛弃。且该事件可能会被调用多次。 end: 当请求体数据传递完毕时，该事件会被触发，此后不会再有数据 close: 用户当前请求结束时，该事件被触发，不同于end，如果用户强制终止传输，也是close http.ServerResponse是返回给客户端的信息，决定了用户最终看到的内容，他有三个重要的函数，用于返回响应头、响应内容以及结束请求 response.writeHead(statusCode,[headers]): 向请求的客户端发送响应头，该函数在一个请求中最多调用一次，如果不调用，则会自动生成一个响应头 response.write(data,[encoding]): 向请求的客户端发送相应的内容，data是一个buffer或者字符串，如果data是字符串，则需要定制编码方式，默认为utf-8。在res.end调用之前可以多次调用。 response.end([data],[encoding]): 结束响应，告知客户端所有发送已经结束，当所有要返回的内容发送完毕时，该函数必须被调用一次，两个可选参数与response.write()相同。如果不掉用这个函数，客户端将一直处于等待状态。 GET 1const http = require('http')2const querystring = require('querystring');3http.createServer((req, res) =&gt; &#123;4 if (req.method === 'GET') &#123;5 const query = querystring.parse(req.url.split('?')[1])6 res.end(JSON.stringify(query))7 &#125;8&#125;).listen('5000') POST 1const http = require('http')2http.createServer((req, res) =&gt; &#123;3 if (req.method === 'POST') &#123;4 let postData = ''5 req.on('data', chunk =&gt; &#123;postData += chunk.toString()&#125;)6 req.on('end', () =&gt; &#123;7 console.log(postData)8 res.end('hello world!')9 &#125;)10 &#125;11&#125;).listen('5000') http client 客户端向服务端发起请求（类似前端ajax、axios） http模块提供了两个函数 http.request 和 http.get http.request(options,callback) options表示请求参数，常见的参数有host、port（默认80）、method（默认GET）、path（请求相对于根的路径，默认’/‘）、headers（请求头内容） callback回调函数，需要传递一个参数，为http.ClientResponse的实例 http.request返回一个http.ClientRequest的实例 1const http = require('http');2let options = &#123;3 hostname: \"127.0.0.1\",4 path: \"/?user=zhangsan&amp;age=18\",5 port: 50006&#125;7const req = http.request(options, (res) =&gt; &#123;8 res.setEncoding(\"utf-8\");9 let dataChunk = \"\"10 res.on(\"data\", (chunk) =&gt; &#123;11 dataChunk += chunk.toString()12 &#125;);13 res.on(\"end\", function () &#123;14 console.log(\"dataChunk\", dataChunk);15 &#125;);16 console.log(\"statusCode\", res.statusCode);17&#125;);18req.on(\"error\", function (err) &#123;19 console.log(err.message);20&#125;);21req.end(); http.get(options,callback) 方法是http.request方法的简化版，唯一的区别是http.get自动将请求方法设为了GET请求，同时不需要手动调用req.end()。注意http.request方法时没有调用end方法，服务器将不会收到信息。","categories":[{"name":"node","slug":"node","permalink":"http://yoursite.com/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"TS装饰器","slug":"typescript/typescript05","date":"2021-01-11T16:00:00.000Z","updated":"2023-10-20T04:26:51.968Z","comments":true,"path":"2021/01/12/typescript/typescript05/","link":"","permalink":"http://yoursite.com/2021/01/12/typescript/typescript05/","excerpt":"","text":"装饰器介绍 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为。通俗的讲装饰器就是一个方法，可以注入到类、方法、属性参数上来扩展类、属性、方法、参数的功能。常见的装饰器有：类装饰器、属性装饰器、方法装饰器、参数装饰器装饰器的写法：普通装饰器（无法传参数）、 装饰器工厂（可传参数） 类装饰器 类装饰器在类声明之前被声明（紧靠着类声明）。类装饰器应用于类构造函数，可以用来监视，修改或者替换类定义。普通装饰器 target: 当前装饰的类 1function logClass(target: any) &#123;2 console.log('target :&gt;&gt; ', target);3&#125;4@logClass5class HttpClient &#123;&#125; 装饰器工厂 params: 传入的参数target: 当前装饰的类 1function logClass(params?: any) &#123;2 return function (target: any) &#123;3 console.log('params :&gt;&gt; ', params);4 console.log('target :&gt;&gt; ', target);5 &#125;6&#125;7@logClass('url')8class HttpClient &#123;&#125; 类的原型上扩展属性方法 1function logClass(params?: any) &#123;2 return function (target: any) &#123;3 target.prototype.url = params4 target.prototype.run = function () &#123;5 console.log('run :&gt;&gt; ', this.url);6 &#125;7 &#125;8&#125;9@logClass('url')10class HttpClient &#123; &#125;11const obj: any = new HttpClient()12console.log('url', obj.url);13obj.run() 重载类的构造函数 1function classDecorator&lt;T extends &#123; new(...args: any[]): &#123;&#125; &#125;&gt;(constructor: T) &#123;2 return class extends constructor &#123;3 url: string = '啦啦啦啦啦啦'4 &#125;5&#125;6@classDecorator7class HttpClient &#123;8 public url: string | undefined9 constructor(url: string) &#123;10 this.url = url11 &#125;12 getData(): void &#123;13 console.log('HttpClient :&gt;&gt; getData');14 &#125;15&#125;16const obj: any = new HttpClient('https://www.baidu.com/')17console.log('obj :&gt;&gt; ', obj.url); // 啦啦啦啦啦啦 属性装饰器 属性装饰器声明在一个属性声明之前（紧靠着属性声明） target：对于静态成员来书是类的构造函数，对于实例成员是类的原型对象propertyKey: 当前装饰属性的名称 1function propertyDecorator(params: string) &#123;2 return function (target: any, propertyKey: string) &#123;3 console.log('target :&gt;&gt; ', target); 4 console.log('params :&gt;&gt; ', params);5 &#125;6&#125;7class HttpClient &#123;8 @propertyDecorator('啦啦啦啦啦')9 public url: string | undefined10 constructor(url: string) &#123;11 this.url = url12 &#125;13 getData() &#123;&#125;14&#125; 方法装饰器 方法装饰器声明在一个方法声明之前（紧靠着方法声明）。它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。 target：对于静态成员来说是类的构造函数，对于实例成员是类的原型对象propertyKey：被装饰方法的名称descriptor：被装饰方法的属性描述符 descriptor.configurable：表示能不能通过delete删除属性，能否修改属性的其他描述符特性，或者能否将数据属性修改为访问器属性。当我们通过let obj = {name: ‘’}声明一个对象的时候，这个对象里面所有的属性的configurable描述符的值都是true descriptor.enumerable：表示能不能通过for in或者Object.keys等方式获取到属性，我们一般声明的对象里面这个描述符的值是true,但是对于class类里面的属性来说，这个值是false descriptor.writable：表示能否修改属性的数据值，通过将这个修改为false,可以实现属性只读的效果。 descriptor.value：表示当前属性的数据值，读取属性值的时候，从这里读取；写入属性值的时候，会写到这个位置。 1function methodDecorator(params: string) &#123;2 return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;3 console.log('params :&gt;&gt; ', params);4 console.log('target :&gt;&gt; ', target);5 console.log('propertyKey :&gt;&gt; ', propertyKey);6 console.log('descriptor :&gt;&gt; ', descriptor);7 &#125;8&#125;9class HttpClient &#123;10 public url: string | undefined11 constructor(url: string) &#123;12 this.url = url13 &#125;14 @methodDecorator('啦啦啦啦啦')15 getData() &#123;&#125;16&#125; 对方法进行扩展 1function methodDecorator(params: string) &#123;2 return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;3 const fn = descriptor.value4 descriptor.value = function (...args: any[]) &#123;5 console.log(params);6 console.log(args);7 fn.apply(this, args)8 &#125;9 &#125;10&#125;11class HttpClient &#123;12 public url: string | undefined13 constructor(url: string) &#123;14 this.url = url15 &#125;16 @methodDecorator('啦啦啦啦啦')17 getData(id: number) &#123;18 console.log('哈哈哈哈');19 console.log('id :&gt;&gt; ', id);20 &#125;21&#125;22const obj: any = new HttpClient('xxx')23obj.getData(123456) 参数装饰器 参数装饰器声明在一个参数声明之前（紧靠着参数声明）。 参数装饰器应用于类构造函数或方法声明。 target：对于静态成员来说是类的构造函数，对于实例成员是类的原型对象propertyKey：被装饰参数对应函数的名称protertyIndex：被装饰参数在形参中对应的索引（函数中arguments中对应的索引） 1function paramsDecorator(params: string) &#123;2 return function (target: any, propertyKey: string, propertyIndex: number) &#123;3 console.log('params :&gt;&gt; ', params);4 console.log('target :&gt;&gt; ', target);5 console.log('propertyKey :&gt;&gt; ', propertyKey);6 console.log('propertyIndex :&gt;&gt; ', propertyIndex); // 17 &#125;8&#125;9class HttpClient &#123;10 public url: string | undefined11 constructor() &#123; &#125;12 getData(num: number, @paramsDecorator('xxx') id: number) &#123;13 &#125;14&#125; 装饰器运行时执行顺序 对于装饰同一个 类、属性、方法、方法参数来说，装饰器的执行顺序都是由内向外执行 先执行@classDecorator1，再执行@classDecorator2(‘xxx’) 1function classDecorator1(target: any) &#123;2 console.log('classDecorator1');3&#125;4function classDecorator2(params: string) &#123;5 return function (target: any) &#123;6 console.log('classDecorator2');7 &#125;8&#125;9@classDecorator2('xxx')10@classDecorator111class HttpClient &#123; &#125; 对于不同的装饰器 属性装饰器 &gt; 方法装饰器 &gt; 方法参数装饰器 &gt; 类装饰器 @propertyDecorator &gt; @methodDecorator &gt; @paramsDecorator &gt; @classDecorator 1function classDecorator(target: any) &#123;2 console.log('classDecorator');3&#125;4function propertyDecorator(target: any, propertyKey: string) &#123;5 console.log('propertyDecorator');6&#125;7function methodDecorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;8 console.log('methodDecorator');9&#125;10function paramsDecorator(target: any, propertyKey: string, propertyIndex: number) &#123;11 console.log('paramsDecorator');12&#125;13@classDecorator14class HttpClient &#123;15 @propertyDecorator16 public url: string | undefined17 constructor() &#123; &#125;18 @methodDecorator19 getData(id: number) &#123; &#125;20 setData(@paramsDecorator id: number) &#123; &#125;21&#125; 当一个方法即存在方法装饰器又存在参数装饰器，会先执行参数装饰器 再执行方法装饰器 @paramsDecorator &gt; @methodDecorator 1function methodDecorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;2 console.log('methodDecorator');3&#125;4function paramsDecorator(target: any, propertyKey: string, propertyIndex: number) &#123;5 console.log('paramsDecorator');6&#125;7class HttpClient &#123;8 constructor() &#123; &#125;9 @methodDecorator10 getData(@paramsDecorator id: number) &#123; &#125;11&#125;","categories":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"TS泛型","slug":"typescript/typescript01","date":"2021-01-10T16:00:00.000Z","updated":"2023-10-20T04:25:19.174Z","comments":true,"path":"2021/01/11/typescript/typescript01/","link":"","permalink":"http://yoursite.com/2021/01/11/typescript/typescript01/","excerpt":"","text":"简单理解 泛型其目的是解决 类 接口 方法的复用性、以及对不特定数据类型的支持 泛型语法 泛型如同传递参数一样，将类型视为一种特殊变量的形式，给参数或返回值动态的指定类型 泛型并不是只能定义一个类型变量，可以定义任何数量的类型变量 泛型函数 1function getData&lt;T&gt;(value: T): T &#123;2 return value3&#125;4getData&lt;number&gt;(123) 泛型类 1class DataClass&lt;T&gt;&#123;2 public list: T[] = []3 setData(value: T): void &#123;4 this.list.push(value)5 &#125;6 getdata(): T[] &#123;7 return this.list8 &#125;9&#125;10const d1 = new DataClass&lt;number&gt;();11const d2 = new DataClass&lt;string&gt;(); 泛型接口 1interface GenericIdentityFn&lt;T&gt; &#123; 2 (arg: T): T;3&#125;","categories":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"require.context 前端工程自动化","slug":"technical/technical02","date":"2021-01-09T16:00:00.000Z","updated":"2023-10-20T04:12:55.046Z","comments":true,"path":"2021/01/10/technical/technical02/","link":"","permalink":"http://yoursite.com/2021/01/10/technical/technical02/","excerpt":"","text":"require.context 介绍 1.require.context 是一个webpack的api2.通过执行require.context 函数获取一个特定的上下文，主要用来实现自动化导入模块 语法解析 语法: require.context(directory, useSubdirectories, regExp); require.context函数接受三个参数 directory 读取文件的路径 useSubdirectories 是否遍历文件的子目录 regExp 匹配文件的正则 require.context函数执行后返回的是一个函数，并且这个函数有三个属性 id 属性返回了匹配的文件夹相对于工程的相对路径 是否遍历子目录 匹配文件的正则 组成的字符串 keys 执行keys方法 返回了匹配文件的文件名组成的数组 reslove 方法接受一个keys方法执行结果的数组中文件名 并返回当前文件相对于整个工程的相对路径 require.context函数执行后返回的是一个函数，这个函数执行后会返回一个模块 这个函数也接受一个参数（匹配的文件名）为参数，函数执行返回的是一个模块，这个模块和使用import导入的模块是一样的 vue 项目中使用场景 自动化引入路由模块1let routers &#x3D; []2const requireContext &#x3D; require.context(&#39;.&#x2F;modules&#39;, false, &#x2F;\\.js$&#x2F;)3requireContext.keys().forEach(fileName &#x3D;&gt; &#123;4 const routerModule &#x3D; requireContext(fileName)5 routers &#x3D; [...routers, ...(routerModule.default || routerModule)]6&#125;);7export const asyncRoutes &#x3D; routers || [] 自动化引入vuex模块1import Vue from &#39;vue&#39;2import Vuex from &#39;vuex&#39;3const requireContext &#x3D; require.context(&#39;.&#x2F;modules&#39;, false, &#x2F;\\.js$&#x2F;)4const modules &#x3D; requireContext.keys().reduce((modules, fileName) &#x3D;&gt; &#123;5 &#x2F;&#x2F; 使用文件名称作为vuex模块名称6 const moduleName &#x3D; fileName.replace(&#x2F;^\\.\\&#x2F;(.*)\\.\\w+$&#x2F;, &#39;$1&#39;)7 const value &#x3D; requireContext(fileName)8 modules[moduleName] &#x3D; value.default9 return modules10&#125;, &#123;&#125;)11Vue.use(Vuex)12export default new Vuex.Store(&#123;13 modules14&#125;) 自动化引入svg1const requireAll &#x3D; requireContext &#x3D;&gt; requireContext.keys().map(requireContext);2const req &#x3D; require.context(&quot;.&#x2F;svg&quot;, false, &#x2F;\\.svg$&#x2F;);3requireAll(req); 自动化全局注册组件1import Vue from &#39;vue&#39;;2const requireContext &#x3D; require.context(&#39;.&#x2F;&#39;, false, &#x2F;\\.vue$&#x2F;)3requireContext.keys().forEach(fileName &#x3D;&gt; &#123;4 const requireModule &#x3D; requireContext(fileName)5 const componentModule &#x3D; requireModule.default || requireModule6 &#x2F;&#x2F; 使用文件名称作为组件名称7 const componentName &#x3D; fileName.replace(&#x2F;^\\.\\&#x2F;(.*)\\.\\w+$&#x2F;, &#39;$1&#39;)8 Vue.component(componentName, componentModule)9&#125;);","categories":[{"name":"技术点","slug":"技术点","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%82%B9/"}],"tags":[{"name":"技术点","slug":"技术点","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%82%B9/"}]},{"title":"TS Class 类","slug":"typescript/typescript06","date":"2020-12-05T16:00:00.000Z","updated":"2023-10-20T04:27:22.131Z","comments":true,"path":"2020/12/06/typescript/typescript06/","link":"","permalink":"http://yoursite.com/2020/12/06/typescript/typescript06/","excerpt":"","text":"类的定义 TS 通过class关键字声明类，其内constructor为构造函数（实例化时触发的方法），this 指向当前实例1class Person &#123;2 public name: string3 constructor(name: string) &#123;4 this.name = name5 &#125;6 say(): void &#123;7 alert(this.name)8 &#125;9&#125;10const p: Person = new Person('xiao qi')11console.log('p :&gt;&gt; ', p); 实例化对象为 相当于ES51function Person(name) &#123;2 this.name = name3&#125;4Person.prototype.say = function () &#123;5 alert(this.name)6&#125;7const p = new Person('xiao qi') 类的继承 TS 通过extends关键字实现继承，通过super()触发父类的构造函数，父类的this也同样指向当前实例1class Person &#123;2 public name: string3 constructor(name: string) &#123;4 this.name = name5 &#125;6 sayName(): void &#123;7 console.log('this.name :&gt;&gt; ', this.name);8 &#125;9&#125;10class Son extends Person &#123;11 public age: number12 constructor(name: string, age: number) &#123;13 super(name)14 this.age = age15 &#125;16 sayAge() &#123;17 console.log('this.age :&gt;&gt; ', this.age);18 &#125;19&#125;20const p: Son = new Son('xiao qi', 18)21p.sayName()22p.sayAge()23console.log('p :&gt;&gt; ', p); 实例化对象为 相当于ES51function Person(name) &#123;2this.name = name3&#125;4Person.prototype.sayName = function () &#123;5 console.log('this.name :&gt;&gt; ', this.name);6&#125;7function Son(name, age) &#123;8 Person.call(this, name)9 this.age = age10&#125;11Son.prototype.__proto__ = Person.prototype12Son.prototype.sayAge = function () &#123;13 console.log('this.age :&gt;&gt; ', this.age);14&#125;15const p = new Son('xiao qi', 18)16console.log('p :&gt;&gt; ', p); 类的修饰符 public: 公有 在类里面、子类、类外面 都可以访问到 protected: 保护类型 在类里面、子类里面可以访问到，在类外面不能访问到 private: 私有 在类里面可以访问，子类、类外面不能访问到 静态属性静态方法 在类里面用 static 关键字声明 无法通过this访问到1class Person &#123;2 static sex: string = '男'3 static say(): void &#123;4 alert(`性别：$&#123;Person.sex&#125;`)5 &#125;6&#125;7Person.say() 相当于ES51function Person() &#123;2&#125;3Person.sex = '男'4Person.say = function () &#123;5 alert(`性别：$&#123;Person.sex&#125;`)6&#125;7Person.say() 抽象类 typescript中的抽象类：它是提供其他类的基类，不能直接被实例化 用 abstract 关键字定义抽象类和抽象方法，抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 abstract 抽象类中 可以放抽象方法 也可以放非抽象方法 abstract 抽象方法只能放在抽象类里面 1abstract class Person &#123;2 public name: string3 constructor(name: string) &#123;4 this.name = name5 &#125;6 abstract eat(): any;7&#125;8class Son1 extends Person &#123;9 constructor(name: string) &#123;10 super(name)11 &#125;12 // Son1 必须实现 Person 中的抽象类中的抽象方法 eat13 eat(): void &#123;14 alert('Son1 吃水果')15 &#125;16&#125;17class Son2 extends Person &#123;18 constructor(name: string) &#123;19 super(name)20 &#125;21 // Son2 必须实现 Person 中的抽象类中的抽象方法 eat22 eat(): void &#123;23 alert('Son2 吃米饭')24 &#125;25&#125;","categories":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"vue cli4 项目构建优化配置","slug":"configuration/configuration03","date":"2020-11-21T16:00:00.000Z","updated":"2023-10-20T04:09:47.286Z","comments":true,"path":"2020/11/22/configuration/configuration03/","link":"","permalink":"http://yoursite.com/2020/11/22/configuration/configuration03/","excerpt":"","text":"基本配置模板 vue.config.js基本配置1module.exports &#x3D; &#123;2 &#x2F;&#x2F; 基本路径3 publicPath: &#39;&#x2F;&#39;,4 &#x2F;&#x2F; 输出文件目录5 outputDir: &#39;dist&#39;,6 &#x2F;&#x2F; eslint-loader 是否在保存的时候检查7 lintOnSave: true,8 &#x2F;&#x2F; webpack配置9 chainWebpack: () &#x3D;&gt; &#123; &#125;,10 configureWebpack: () &#x3D;&gt; &#123; &#125;,11 &#x2F;&#x2F; 生产环境是否生成 sourceMap 文件12 &#x2F;&#x2F;是否在构建生产包时生成 sourceMap 文件，false将提高构建速度(map文件能看到具体报错位置)13 productionSourceMap: false,14 &#x2F;&#x2F; css相关配置15 css: &#123;16 &#x2F;&#x2F; 是否使用css分离插件 ExtractTextPlugin css 抽离成单独文件而非直接 style内联样式写法17 extract: true,18 &#x2F;&#x2F; 开启 CSS source maps?19 sourceMap: false,20 &#x2F;&#x2F; css loader 预设器配置项21 loaderOptions: &#123;&#125;,22 &#x2F;&#x2F; 设置为 false 将所有的 *.(css|scss|sass|less|styl(us)?) 文件视为 CSS Modules 模块23 requireModuleExtension: true24 &#125;,25 &#x2F;&#x2F; webpack-dev-server 相关配置26 devServer: &#123;27 &#x2F;&#x2F;...28 &#125;,29 &#x2F;&#x2F; 第三方插件配置30 pluginOptions: &#123;31 &#x2F;&#x2F; ...32 &#125;33&#125; 打包性能优化 使用webpack-bundle-analyzer查看资源树1chainWebpack: (config) &#x3D;&gt; &#123;2 if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;) &#123;3 &#x2F;&#x2F;添加分析工具4 config5 .plugin(&#39;webpack-bundle-analyzer&#39;)6 .use(require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin)7 .end()8 &#125;9&#125; 去除map文件1productionSourceMap: false 关闭预加载1chainWebpack: (config) &#x3D;&gt; &#123;2 if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;) &#123;3 &#x2F;&#x2F;关闭预加载关闭prefetch4 &#x2F;&#x2F;vuecli4 默认开启prefetch(预先加载模块)，提前获取用户未来可能会访问的内容在首屏会把这十几个路由文件都下载下来5 config.plugins.delete(&#39;prefetch&#39;)6 config.plugins.delete(&#39;preload&#39;)7 &#125;8&#125; 压缩分割代码1chainWebpack: (config) &#x3D;&gt; &#123;2 if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;) &#123;3 &#x2F;&#x2F; 压缩代码4 config.optimization.minimize(true)5 &#x2F;&#x2F; 分割代码6 config.optimization.splitChunks(&#123;7 chunks: &#39;all&#39;8 &#125;)9 &#125;10&#125; cdn公用资源 1.忽略打包文件 1const externals &#x3D; &#123;2 vue: &#39;Vue&#39;,3 &#39;vue-router&#39;: &#39;VueRouter&#39;,4 vuex: &#39;Vuex&#39;,5 &#39;element-ui&#39;: &#39;ELEMENT&#39;6&#125; 1configureWebpack: (config) &#x3D;&gt; &#123;2 if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;) &#123;3 &#x2F;&#x2F; 忽略打包文件4 config.externals &#x3D; externals5 &#125;6&#125; 2.注入cdn资源。资源可以直接使用网上cdn资源，也可以直接下载放在 public 文件夹下 使用相对路径方式引入 1const cdn &#x3D; &#123;2 &#x2F;&#x2F; 开发环境3 dev: &#123;4 css: [],5 js: []6 &#125;,7 &#x2F;&#x2F; 生产环境8 build: &#123;9 css: [10 &#39;https:&#x2F;&#x2F;unpkg.com&#x2F;element-ui@2.14.1&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;,11 ],12 js: [13 &#39;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;vue&#x2F;2.6.11&#x2F;vue.min.js&#39;,14 &#39;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;vue-router&#x2F;3.2.0&#x2F;vue-router.min.js&#39;,15 &#39;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;vuex&#x2F;3.1.2&#x2F;vuex.min.js&#39;,16 &#39;https:&#x2F;&#x2F;unpkg.com&#x2F;element-ui@2.14.1&#x2F;lib&#x2F;index.js&#39;,17 ]18 &#125;19&#125; 1chainWebpack: config &#x3D;&gt; &#123;2 &#x2F;&#x2F; 添加CDN参数到htmlWebpackPlugin配置中3 config.plugin(&#39;html&#39;).tap(args &#x3D;&gt; &#123;4 if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;) &#123;5 args[0].cdn &#x3D; cdn.build6 &#125; else &#123;7 args[0].cdn &#x3D; cdn.dev8 &#125;9 return args10 &#125;)11&#125; 3.在 public/index.html 中注入配置的cdn 1&lt;!-- 使用CDN的CSS文件 --&gt;2&lt;% for (var i in3 htmlWebpackPlugin.options.cdn&amp;&amp;htmlWebpackPlugin.options.cdn.css) &#123; %&gt;4 &lt;link href&#x3D;&quot;&lt;%&#x3D; htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot; rel&#x3D;&quot;preload&quot; as&#x3D;&quot;style&quot; &#x2F;&gt;5 &lt;link href&#x3D;&quot;&lt;%&#x3D; htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot; rel&#x3D;&quot;stylesheet&quot; &#x2F;&gt;6&lt;% &#125; %&gt;7&lt;!-- 使用CDN加速的JS文件，配置在vue.config.js下 --&gt;8&lt;% for (var i in9 htmlWebpackPlugin.options.cdn&amp;&amp;htmlWebpackPlugin.options.cdn.js) &#123; %&gt;10 &lt;script src&#x3D;&quot;&lt;%&#x3D; htmlWebpackPlugin.options.cdn.js[i] %&gt;&quot;&gt;&lt;&#x2F;script&gt;11&lt;% &#125; %&gt; 添加 IE 兼容 使用 core-js 和 regenerator-runtime1npm i --save core-js regenerator-runtime main.js 中添加1import &#39;core-js&#x2F;stable&#39;2import &#39;regenerator-runtime&#x2F;runtime&#39; 配置 babel.config.js1const plugins &#x3D; []2module.exports &#x3D; &#123;3 presets: [[&#39;@vue&#x2F;cli-plugin-babel&#x2F;preset&#39;, &#123;useBuiltIns: &#39;usage&#39;, corejs: 3&#125;]],4 plugins5&#125;","categories":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}]},{"title":"TS函数声明","slug":"typescript/typescript02","date":"2020-11-20T16:00:00.000Z","updated":"2023-10-20T04:26:03.556Z","comments":true,"path":"2020/11/21/typescript/typescript02/","link":"","permalink":"http://yoursite.com/2020/11/21/typescript/typescript02/","excerpt":"","text":"TS中的函数和js中的大部分相同，不同之处自在于TS会对函数的形参以及返回值进行类型声明。 TS函数的类型 命名函数1function test(str: string): void &#123;2 console.log(&#39;str :&gt;&gt; &#39;, str);3&#125;4test(&#39;Hello World!&#39;) 匿名函数1const test &#x3D; function (str: string): void &#123;2 console.log(&#39;str :&gt;&gt; &#39;, str);3&#125;4test(&#39;Hello World!&#39;) 箭头函数1const test &#x3D; (str: string): void &#x3D;&gt; &#123;2 console.log(&#39;str :&gt;&gt; &#39;, str);3&#125;4test(&#39;Hello World!&#39;) 函数声明分离 使用type声明函数1type Fun &#x3D; (a: string, b: number) &#x3D;&gt; void2const test: Fun &#x3D; function (name, age) &#123;3 console.log(&#96;名字：$&#123;name&#125;，年龄：$&#123;age&#125;&#96;);4&#125;5test(&#39;xq&#39;, 18) 使用接口分离函数1interface Fun &#123;2 (a: string, b: number): void3&#125;4const test: Fun &#x3D; function (name, age) &#123;5 console.log(&#96;名字：$&#123;name&#125;，年龄：$&#123;age&#125;&#96;);6&#125;7test(&#39;xq&#39;, 18) 函数参数 可选参数1function test(a: number, b?: number): void &#123;2 console.log(&#39;a :&gt;&gt; &#39;, a);3 console.log(&#39;b :&gt;&gt; &#39;, b);4&#125;5test(1); &#x2F;&#x2F; a :&gt;&gt; 1 b :&gt;&gt; undefined6test(1, 2); &#x2F;&#x2F; a :&gt;&gt; 1 b :&gt;&gt; 2 1&#x2F;&#x2F; 可选参数可一项或多项2function test(a: number, b?: number, c?: number): number &#123;3 return a + (b || 0) + (c || 0)4&#125; 1&#x2F;&#x2F; 可选参数后面只能是可选参数2function test(a: number, b?: number, c: number): number &#123; &#x2F;&#x2F; 报错3 return a + (b || 0) + c4&#125; 默认参数1function test(a: number, b: number &#x3D; 2): number &#123;2 return a + b3&#125;4console.log(&#39;test(1) :&gt;&gt; &#39;, test(1)); &#x2F;&#x2F; 35console.log(&#39;test(1,3) :&gt;&gt; &#39;, test(1, 3));&#x2F;&#x2F; 4 剩余参数1function test(a: number, ...arg: number[]): number &#123;2 console.log(&#39;a :&gt;&gt; &#39;, a);3 let sum &#x3D; arg.reduce((total, cur) &#x3D;&gt; &#123;4 return total &#x3D; cur + total5 &#125;, 0)6 return a + sum7&#125;8console.log(&#39;total:&gt;&gt; &#39;, test(1, 2, 3, 4)); &#x2F;&#x2F; a :&gt;&gt; 1 total:&gt;&gt; 10 函数重载 当两个函数名同名，但他们的参数不一样，这时会出现函数重载情况。ts为了兼容es5 es6 重载的写法和java存在区别。1function test(str: string): string2function test(num: number): number3function test(params: any): any &#123;4 if (typeof params &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;5 return params + &#39;Hello&#39;6 &#125; else if (typeof params &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;7 return params + 18 &#125;9&#125;10console.log(test(&#39;你好！&#39;)); &#x2F;&#x2F; 你好！Hello11console.log(test(2)); &#x2F;&#x2F; 3","categories":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"TS接口（interface）","slug":"typescript/typescript03","date":"2020-11-07T16:00:00.000Z","updated":"2023-10-20T04:26:25.296Z","comments":true,"path":"2020/11/08/typescript/typescript03/","link":"","permalink":"http://yoursite.com/2020/11/08/typescript/typescript03/","excerpt":"","text":"接口interface 为什么需要接口? 为了定义对象内的各种属性。 什么是接口? 同 string,number.boolean 一样，接口也是一种类型，目的是为了约束对象内的各个属性。 严格约束对象字段及字段类型 声明的对象的字段，及字段对应的类型必须和接口中一致，不可多字段，不可少字段，不可字段类型不一致。1interface Person &#123;2 username: string,3 userage: number4&#125;5const per: Person &#x3D; &#123;6 username: &#39;xiao qi&#39;,7 userage: 188&#125; 同声明变量一样字段 也可以用 | 指定多种类型1interface Person &#123;2 username: string,3 userage: number | string 4&#125;5const per: Person &#x3D; &#123;6 username: &#39;lili&#39;,7 userage: &#39;18岁&#39;8&#125;9per.userage &#x3D; 18 属性字段可能不在情况 使用可选属性，在属性名后面添加？实现1interface Person &#123;2 username: string,3 userage: number,4 address?: string5&#125;6const per: Person &#x3D; &#123;7 username: &#39;xiao qi&#39;,8 userage: 189&#125;10per.address &#x3D; &#39;武汉&#39; 属性字段可能不够情况 使用索引签名propName，定义对象中的key和value结构，则后续属性只要满足这个结构就可以无限添加字段1interface Person1 &#123;2 [propName: string]: string3&#125;4const per1: Person1 &#x3D; &#123;5 username: &#39;xiao qi&#39;,6 sex: &#39;男&#39;,7 2: &#39;la la&#39; &#x2F;&#x2F; tips：当propName为string无论什么key都会转成字符串，不会报错8&#125;910interface Person2 &#123;11 [propName: number]: number12&#125;13const per2: Person2 &#x3D; &#123;14 0: 12315&#125; 接口继承 同JS的class类一样，TS中的接口也可以继承1interface A &#123;2 a: string3&#125;4interface B &#123;5 b: number6&#125;7interface C extends A, B &#123;8 c: boolean9&#125;10const obj: C &#x3D; &#123;11 a: &#39;aaaaa&#39;,12 b: 11111,13 c: true14&#125; 对函数约束 函数本身也是对象，也可以用接口来定义1interface Sum &#123;2 (a: number, b: number): number3&#125;4const sum: Sum &#x3D; function (x, y) &#123;5 return x + y6&#125;7sum(1, 3) 对类约束 定义完成接口后，类通过implements进行实现1interface Animal &#123;2 name: string,3 eat(name: string): void4&#125;5class Dog implements Animal &#123;6 public name: string;7 constructor(name: string) &#123;8 this.name &#x3D; name9 &#125;10 eat(food: string): void &#123;11 alert(&#96;$&#123;this.name&#125;: 吃$&#123;food&#125;！&#96;)12 &#125;13&#125;14const d: Dog &#x3D; new Dog(&#39;旺柴&#39;)15d.eat(&#39;狗粮&#39;) 既可以继承父类，也可以实现接口1interface Animal &#123;2 eat(): void3&#125;4interface Person extends Animal &#123;5 work(): void6&#125;7class Programmer &#123;8 public name: string9 constructor(name: string) &#123;10 this.name &#x3D; name11 &#125;12 work(): void &#123;13 alert(&#96;$&#123;this.name&#125;写代码！&#96;)14 &#125;15&#125;16class Web extends Programmer implements Person &#123;17 constructor(name: string) &#123;18 super(name)19 &#125;20 eat(): void &#123;21 alert(&#96;$&#123;this.name&#125;吃米饭！&#96;)22 &#125;23&#125;24const p: Person &#x3D; new Web(&#39;张三&#39;)25p.work()26p.eat()","categories":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"Typescript环境搭建","slug":"typescript/typescript07","date":"2020-10-31T16:00:00.000Z","updated":"2023-10-20T04:27:36.608Z","comments":true,"path":"2020/11/01/typescript/typescript07/","link":"","permalink":"http://yoursite.com/2020/11/01/typescript/typescript07/","excerpt":"","text":"安装编译 安装1npm install -g typescript 运行 将ts编译成js，并输出js文件 1tsc helloworld.ts ts-node 安装1npm install -g ts-node 运行 同node 运行js 一样，ts-node 同样可以将 ts 在终端中执行并输出 1ts-node helloworld.ts vscode 自动编译 直接使用 tsc –watch 对单个文件自动编辑 1tsc --watch helloworld.ts 使用 tsconfig.json 对多文件自动编译 当前项目根目录下 tsc –init 生成配置文件1tsc --init 找到 vscode 终端 =&gt; 运行任务 =&gt; typescript =&gt; tsc:监视-xxx/tsconfig.json","categories":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"TS类型声明","slug":"typescript/typescript04","date":"2020-10-31T16:00:00.000Z","updated":"2023-10-20T04:26:38.875Z","comments":true,"path":"2020/11/01/typescript/typescript04/","link":"","permalink":"http://yoursite.com/2020/11/01/typescript/typescript04/","excerpt":"","text":"typescript 中的数据类型 布尔类型（boolean） 数字类型（number） 字符串类型（string） 数组类型（array） 元组类型（tuple） 枚举类型（enum） 任意类型（any） null 和 undefined void类型 never类型 boolean number string 简单类型的变量声明 布尔类型 boolean1let bool: boolean &#x3D; true2&#x2F;&#x2F; bool &#x3D; &#39;&#39; &#x2F;&#x2F; error : Type &#39;string&#39; is not assignable to type &#39;boolean&#39;3console.log(&#39;bool :&gt;&gt; &#39;, bool); 数字类型 （整数、浮点数）number 1let num: number &#x3D; 1.12&#x2F;&#x2F; num &#x3D; &quot;&quot; &#x2F;&#x2F; error : Type &#39;string&#39; is not assignable to type &#39;number&#39;.3num &#x3D; 24console.log(&#39;num :&gt;&gt; &#39;, num); 字符串类型 string1let str: string &#x3D; &quot;hello&quot;2&#x2F;&#x2F; str &#x3D; 2 &#x2F;&#x2F; error : Type &#39;number&#39; is not assignable to type &#39;string&#39;.3str &#x3D; &#39;hello world!&#39;4console.log(&#39;str :&gt;&gt; &#39;, str); 数组和元组类型的变量声明 一 整个数组数据类型一致 :Array&lt; number &gt;1&#x2F;&#x2F; 纯数字数字2const arr1: Array&lt;number&gt; &#x3D; [1, 2, 3] :string[]1&#x2F;&#x2F; 纯字符串数组2const arr2: string[] &#x3D; [&#39;hello&#39;, &#39;world&#39;]; 二 整个数组数据类型不一致情况 联合类型声明数组(number|string)[]1&#x2F;&#x2F; 数字或字符串数组2const arr3: (number | string)[] &#x3D; [&#39;1&#39;, &#39;1&#39;, 2, 1] 三 自由任意类型元素的数组 any[]1&#x2F;&#x2F; 任意类型2const arr4: any[] &#x3D; [&#39;1&#39;, 2, false, undefined] 四 严格限定类型和长度的元组 :[string,number,boolean]1&#x2F;&#x2F; 限定每项类型 与 长度2const arr5: [string, number, boolean] &#x3D; [&#39;1&#39;, 2, false] enum枚举类型 枚举用于表示固定的几个取值，如 性别 男女。 定义运用1enum Gender &#123;2 Male &#x3D; 0,3 Femal &#x3D; 14&#125;5let sex: Gender &#x3D; Gender.Femal 默认值1&#x2F;&#x2F; TS中的枚举类型的取值, 默认是从上至下从0开始递增的2enum Gender &#123;3 Male, &#x2F;&#x2F; 04 Femal &#x2F;&#x2F; 15&#125;6console.log(&#39;Gender :&gt;&gt; &#39;, Gender); &#x2F;&#x2F; &#123;0: &quot;Male&quot;, 1: &quot;Femal&quot;, Male: 0, Femal: 1&#125; 1enum Gender &#123;2 Male&#x3D;3, &#x2F;&#x2F; 33 Femal &#x2F;&#x2F; 44&#125;5console.log(&#39;Gender :&gt;&gt; &#39;, Gender); &#x2F;&#x2F; &#123;3: &quot;Male&quot;, 4: &quot;Femal&quot;, Male: 3, Femal: 4&#125; 用 | 指定多种类型 当一个变量可能存在多个类型值时，可以使用 | 指定多个类型1let temp: number | string | boolean &#x3D; 1232temp &#x3D; &#39;xiao qi&#39;3temp &#x3D; true any 任意类型 当不清楚值得类型时，可以使用any，任何数据类型的值都可以赋值给any1let val: any;2val &#x3D; true3val &#x3D; 1234val &#x3D; &#39;hello world&#39;5val &#x3D; [1, &#39;2&#39;, 3]6val &#x3D; null7val &#x3D; undefined null 和 undefined undefined和null各自的类型分别为undefined和null1let u: undefined &#x3D; undefined;2let n: null &#x3D; null; void 类型 void与any相反，表示没有任何类型，一般用于函数返回值。在TS中只有undefined可以赋值给void类型。1function test(): void &#123;2 console.log(&#39;hello world!&#39;);3&#125;4let val: void &#x3D; test()5console.log(&#39;val :&gt;&gt; &#39;, val); &#x2F;&#x2F; undefined never 类型 表示永远不存在的值类型，一般用于抛出异常或者根本不可能有返回值的函数。1function test():never &#123;2 throw new Error(&#39;报错了&#39;);3&#125;4test(); 接口 interface 类型 定义应用1interface Person &#123;2 name: String,3 age: number4&#125;5const per: Person &#x3D; &#123;6 name: &#39;xiao qi&#39;,7 age: 18,8&#125;","categories":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"vue-cli4","slug":"configuration/configuration08","date":"2020-10-24T16:00:00.000Z","updated":"2023-10-21T02:28:15.753Z","comments":true,"path":"2020/10/25/configuration/configuration08/","link":"","permalink":"http://yoursite.com/2020/10/25/configuration/configuration08/","excerpt":"","text":"环境变量配置 在项目根目录中新建.env.* 创建环境变量的配置文件 在环境变量的配置文件中 可以设置以VUE_APP_ 开头的变量，在代码中可以通过 process.env.VUE_APP_ 访问。此外始终可用的还有两个特殊的变量NODE_ENV 和BASE_URL。 package.json 里的 scripts 命令行，通过配置 –mode xxx 来执行不同环境的配置文件 为了修改方便，一般还会配置config文件 - config/index.js 1&#x2F;&#x2F; 根据环境引入不同配置 process.env.VUE_APP_ENV2const config &#x3D; require(&#39;.&#x2F;env.&#39; + process.env.VUE_APP_ENV)3module.exports &#x3D; config - env.* .js 1module.exports &#x3D; &#123;2 baseUrl: &#39;http:&#x2F;&#x2F;localhost:8080&#39;, &#x2F;&#x2F; 项目地址3 baseApi: &#39;https:&#x2F;&#x2F;test.xxx.com&#x2F;api&#39;, &#x2F;&#x2F; 本地api请求地址4 &#x2F;&#x2F; todo5&#125; - 项目中使用 1&#x2F;&#x2F; 根据环境不同引入不同baseApi地址2import &#123; baseApi &#125; from &#39;@&#x2F;config&#39; vue.config.js 基础配置 根目录下创建 vue.config.js1module.exports &#x3D; &#123;2 publicPath: &#39;.&#x2F;&#39;, &#x2F;&#x2F; 署应用包时的基本 URL。 3 outputDir: &#39;dist&#39;, &#x2F;&#x2F; 生产环境构建文件的目录4 assetsDir: &#39;static&#39;, &#x2F;&#x2F; outputDir的静态资源(js、css、img、fonts)目录5 lintOnSave: false,6 productionSourceMap: false, &#x2F;&#x2F; 如果你不需要生产环境的 source map，可以将其设置为 false 以加速生产环境构建。7 devServer: &#123;8 port: 8080, &#x2F;&#x2F; 端口号9 open: false, &#x2F;&#x2F; 启动后打开浏览器10 &#x2F;&#x2F; ...11 &#125;12&#125; 配置 proxy 代理 解决项目中的跨域问题 在 vue.config.js中 配置 proxy1module.exports &#x3D; &#123;2 devServer: &#123;3 &#x2F;&#x2F; ....4 proxy: &#123;5 &#x2F;&#x2F;配置跨域6 &#39;&#x2F;api&#39;: &#123;7 target: &#39;https:&#x2F;&#x2F;test.xxx.com&#39;, &#x2F;&#x2F; 接口的域名8 changOrigin: true, &#x2F;&#x2F; 开启代理，在本地创建一个虚拟服务端9 pathRewrite: &#123;10 &#39;^&#x2F;api&#39;: &#39;&#x2F;&#39;11 &#125;12 &#125;13 &#125;14 &#125;15&#125; 配置 externals 引入 cdn cdn 首屏加载优化使用注意事项 1. 项目中使用的是公共 CDN 不稳定 2. 尽量使用同一个域名，域名解析也是需要时间 排除包文件，设置cdn1const IS_PROD &#x3D; [&#39;production&#39;].includes(process.env.NODE_ENV)2&#x2F;&#x2F; externals3const externals &#x3D; &#123;4 vue: &#39;Vue&#39;,5 &#39;vue-router&#39;: &#39;VueRouter&#39;,6 vuex: &#39;Vuex&#39;,7&#125;8&#x2F;&#x2F; CDN外链，会插入到index.html中9const cdn &#x3D; &#123;10 &#x2F;&#x2F; 开发环境11 dev: &#123;12 css: [],13 js: []14 &#125;,15 &#x2F;&#x2F; 生产环境16 build: &#123;17 css: [],18 js: [19 &#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.6.11&#x2F;dist&#x2F;vue.min.js&#39;,20 &#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue-router@3.1.5&#x2F;dist&#x2F;vue-router.min.js&#39;,21 &#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vuex@3.1.2&#x2F;dist&#x2F;vuex.min.js&#39;,22 ]23 &#125;24&#125;25module.exports &#x3D; &#123;26 configureWebpack: config &#x3D;&gt; &#123;27 &#x2F;&#x2F; 为生产环境修改配置...28 if (IS_PROD) &#123;29 &#x2F;&#x2F; externals30 config.externals &#x3D; externals31 &#125;32 &#125;,33 chainWebpack: config &#x3D;&gt; &#123;34 &#x2F;**35 * 添加CDN参数到htmlWebpackPlugin配置中36 *&#x2F;37 config.plugin(&#39;html&#39;).tap(args &#x3D;&gt; &#123;38 if (IS_PROD) &#123;39 args[0].cdn &#x3D; cdn.build40 &#125; else &#123;41 args[0].cdn &#x3D; cdn.dev42 &#125;43 return args44 &#125;)45 &#125;46&#125; 在 public/index.html 中注入配置的cdn1&lt;!-- 使用CDN的CSS文件 --&gt;2&lt;% for (var i in3 htmlWebpackPlugin.options.cdn&amp;&amp;htmlWebpackPlugin.options.cdn.css) &#123; %&gt;4 &lt;link href&#x3D;&quot;&lt;%&#x3D; htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot; rel&#x3D;&quot;preload&quot; as&#x3D;&quot;style&quot; &#x2F;&gt;5 &lt;link href&#x3D;&quot;&lt;%&#x3D; htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot; rel&#x3D;&quot;stylesheet&quot; &#x2F;&gt;6&lt;% &#125; %&gt;7&lt;!-- 使用CDN加速的JS文件，配置在vue.config.js下 --&gt;8&lt;% for (var i in9 htmlWebpackPlugin.options.cdn&amp;&amp;htmlWebpackPlugin.options.cdn.js) &#123; %&gt;10 &lt;script src&#x3D;&quot;&lt;%&#x3D; htmlWebpackPlugin.options.cdn.js[i] %&gt;&quot;&gt;&lt;&#x2F;script&gt;11&lt;% &#125; %&gt; 添加 IE 兼容 使用 core-js 和 regenerator-runtime1npm i --save core-js regenerator-runtime main.js 中添加1import &#39;core-js&#x2F;stable&#39;2import &#39;regenerator-runtime&#x2F;runtime&#39; 配置 babel.config.js1const plugins &#x3D; []2module.exports &#x3D; &#123;3 presets: [[&#39;@vue&#x2F;cli-plugin-babel&#x2F;preset&#39;, &#123;useBuiltIns: &#39;usage&#39;, corejs: 3&#125;]],4 plugins5&#125;","categories":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}]},{"title":"ES6 Class 类","slug":"javascript/javascript06","date":"2020-10-17T16:00:00.000Z","updated":"2023-10-20T06:11:02.621Z","comments":true,"path":"2020/10/18/javascript/javascript06/","link":"","permalink":"http://yoursite.com/2020/10/18/javascript/javascript06/","excerpt":"","text":"语法糖解析 ES6 class 在实例化对象时 会调用 类 里面的 constructor() 方法，逐行执行constructor内代码 并默认返回实例。所以ES6 constructor内部的this指向实例 ES6 内部的方法 就是原型对象上的方法 ES6 的class 1class Kind &#123;2 constructor(obj) &#123;3 this.a &#x3D; obj.a4 &#125;5 say() &#123;6 console.log(&#39;say :&gt;&gt; &#39;, this.a);7 &#125;8&#125;9let objA &#x3D; new Kind(&#123; a: 1 &#125;) ES5 中 构造函数实例化对象时 是调用构造函数本身，并默认返回实例对象。所以 构造函数内部的this指向实例。不过在ES5中我们都清楚 原型上的constructor === 构造函数 等同于 ES5 1function Kind(obj) &#123;2 this.a &#x3D; obj.a3&#125;4Kind.prototype.say &#x3D; function () &#123;5 console.log(&#39;say :&gt;&gt; &#39;, this.a);6&#125;7let objA &#x3D; new Kind(&#123; a: 1 &#125;) getter和setter 在class的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，对该属性数据劫持。 ES6 get set 1class Kind &#123;2 constructor(obj) &#123;3 this._a &#x3D; obj.a4 &#125;5 get a() &#123;6 console.log(&#39;正在取值a...&#39;, this._a);7 return this._a8 &#125;9 set a(newVal) &#123;10 console.log(&#39;正在存值a...&#39;, newVal);11 this._a &#x3D; newVal12 &#125;13&#125;14let objA &#x3D; new Kind(&#123; a: 1 &#125;) ES5 一般使用 Object.defineProperty 对数据进行劫持 this 指向当前对象 ES5 Object.defineProperty 1const objA &#x3D; &#123;&#125;2Object.defineProperty(objA, &quot;a&quot;, &#123;3 get() &#123;4 console.log(&quot;正在取值a...&quot;, this._a);5 return this._a;6 &#125;,7 set(newVal) &#123;8 console.log(&quot;正在存值a...&quot;, newVal);9 this._a &#x3D; newVal;10 &#125;11&#125;); 静态属性 ES6 class 提供了 static 静态属性关键字，只属性或方法允许在class使用。 ES6 class 未提供 public ,但默认都为 public ES6 class 未提供 private(私有属性) 1class Kind &#123;2 static b &#x3D; 123 constructor(obj) &#123;4 this.a &#x3D; obj.a5 console.log(&#39;Kind.b :&gt;&gt; &#39;, Kind.b);6 &#125;7 say() &#123;8 console.log(&#39;Kind.b :&gt;&gt; &#39;, Kind.b);9 Kind.eat()10 &#125;11 static eat() &#123;12 console.log(&#39;eat...&#39;);13 &#125;14&#125;15let objA &#x3D; new Kind(&#123; a: 1 &#125;)16objA.say()17&#x2F;&#x2F; objA.eat() error 继承 extends 当 class 存在继承时，实例化对象时。首先也是会调用本身的constructor()，但是不同的是 执行本身的constructor()方法时，必须通过super()方法 将父类的constructor() 也调用一次，最后默认返回实例。所以 继承时 父类 与 子类 中的 this 指向实例。 1class Son extends Parent &#123;2&#125;3&#x2F;&#x2F; 等同于4class Son extends Parent &#123;5 constructor(...args) &#123;6 super(...args);7 &#125;8&#125; 当super以函数的形式调用时，执行父函数的构造函数constructor()。当super以对象的形式使用时指向父类。 父类的静态方法，也会被子类继承。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"附件上传下载","slug":"technical/technical01","date":"2020-09-09T16:00:00.000Z","updated":"2023-10-20T04:12:33.166Z","comments":true,"path":"2020/09/10/technical/technical01/","link":"","permalink":"http://yoursite.com/2020/09/10/technical/technical01/","excerpt":"","text":"附件上传 通过 type=”file” 类型的input 获取到文件1&lt;input ref&#x3D;&quot;file&quot; type&#x3D;&quot;file&quot; style&#x3D;&quot;display:none&quot; @change&#x3D;&quot;upload&quot; &#x2F;&gt; 由于原生input的样式不太美观，一般会模拟触发input的事件1&#x2F;&#x2F; 清楚缓存，防止同一个文件，连续两次不触发change事件2this.$refs.file.value &#x3D; &quot;&quot;;3&#x2F;&#x2F; 模拟派发点击事件4this.$refs.file.dispatchEvent(new MouseEvent(&quot;click&quot;)); 获取到文件，FormData 处理1&#x2F;&#x2F; 得到文件的数组2this.$refs.file.files; 1&#x2F;*2注意：new FormData3 1.只能通过 append() 方法对文件进行添加，第一个参数为后台所需要的key值，第二个参数可以为文件也可以为其他值4 2.多个附件只能通过循环 append 方式添加5*&#x2F;6var formData &#x3D; new FormData();7var fileList &#x3D; his.$refs.file.files;8for (var i &#x3D; 0; i &lt; fileList.length; i++) &#123;9 formData.append(&quot;file&quot;, fileList[i]);10&#125; axios 请求处理，一般不指定文件类型（axios默认Form Data）。1headers: &#123;2 &#39;Content-Type&#39;: false &#x2F;&#x2F; 不要指定请求的数据类型3&#125; 附件下载（后台返回二进制流） axios 中声明响应数据类型1responseType: &#39;blob&#39; 使用 a 链接的download 属性1var a &#x3D; document.createElement(&#39;a&#39;);2&#x2F;&#x2F; content 后台返回的二进制流（blob）3var url &#x3D; window.URL.createObjectURL(content);4&#x2F;&#x2F; 文件名称和文件类型(后缀) 定义5var filename &#x3D; &#39;XXX.zip&#39;;6a.href &#x3D; url;7a.download &#x3D; filename;8a.click();9window.URL.revokeObjectURL(url); &#x2F;&#x2F; 释放 附件下载（服务器资源地址） 1window.location.href &#x3D; url 1&lt;a href&#x3D;&quot;服务器资源url&quot; download&#x3D;&quot;下载时文件名.docx&quot;&gt;点击显示名&lt;&#x2F;a&gt;","categories":[{"name":"技术点","slug":"技术点","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%82%B9/"}],"tags":[{"name":"技术点","slug":"技术点","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%82%B9/"}]},{"title":"vue自定义指令directive","slug":"vue/vue14","date":"2020-09-04T16:00:00.000Z","updated":"2023-10-20T04:23:13.982Z","comments":true,"path":"2020/09/05/vue/vue14/","link":"","permalink":"http://yoursite.com/2020/09/05/vue/vue14/","excerpt":"","text":"简单介绍 vue官方介绍：对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 所以我认为 directive 的绝大多数用于处理，静态的UI交互逻辑的封装。 注册使用 与 filter component mixin 注册使用方式类似，directive 也是使用 install function 在这种方式注册 局部注册 书写指令1export default &#123;2 bind(el, binding, vnode) &#123;3 &#x2F;&#x2F; 第一次绑定4 &#125;,5 update(el, binding, vnode) &#123;6 &#x2F;&#x2F; 当视图发生变化7 &#125;8&#125;; 引入组件局部注册1import test from &quot;.&#x2F;test.js&quot;;2export default &#123;3 directives: &#123; test &#125;4&#125; 全局注册 书写指令1export default &#123;2 install: function (Vue) &#123;3 Vue.directive(&quot;demo&quot;, &#123;4 bind(el, binding, vnode) &#123;5 &#x2F;&#x2F; 第一次绑定6 &#125;,7 update(el, binding, vnode) &#123;8 &#x2F;&#x2F; 当视图发生变化9 &#125;10 &#125;);11 &#125;12&#125;; Vue.use 全局注册1import Vue from &quot;vue&quot;;2import demo from &quot;.&#x2F;demo&quot;;3Vue.use(demo); main.js 导入1import &quot;@&#x2F;directive&quot;; 常用钩子函数介绍 指令的钩子函数 一共5个 bind inserted update componentUpdated unbind 具体详细解释看官网，这里只介绍常用的两个，以及常用的钩子函数参数。 钩子函数 bind 只调用一次，指令第一次绑定到元素时调用 update 官方：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。 简单理解：当指令节点下的视图发生变化时，触发update。 钩子函数参数 el 指令所绑定的元素，可以用来直接操作 DOM。 binding 一个对象，包含以下常用 property value: 指令传入的绑定值。 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。","categories":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/categories/vue-2-0/"}],"tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/tags/vue-2-0/"}]},{"title":".sync修饰符使用详解","slug":"vue/vue03","date":"2020-08-19T16:00:00.000Z","updated":"2023-10-20T04:20:46.479Z","comments":true,"path":"2020/08/20/vue/vue03/","link":"","permalink":"http://yoursite.com/2020/08/20/vue/vue03/","excerpt":"","text":"简单介绍 .sync 与 v-model 类似，也是用来解决数据的双向绑定。 .sync 本质上也是语法糖。用自定义属性，与自定义事件，配合使用实现数据双向绑定。 语法糖实现 子组件部分：子组件通过props接收到数据，再通过自定义事件把修改后数据传出去 父组件部分：父组价通过自定义属性把数据传递出去，再监听自定义事件，根据自定义事件传递的数据修改属性值 子组件部分 1&lt;template&gt;2 &lt;div class&#x3D;&quot;child&quot;&gt;3 &lt;p&gt;我是子组件&lt;&#x2F;p&gt;4 &lt;p&gt;-------------&lt;&#x2F;p&gt;5 &lt;input class&#x3D;&quot;inp&quot; @input&#x3D;&quot;onInput&quot; :value&#x3D;&quot;text&quot; &#x2F;&gt;6 &lt;&#x2F;div&gt;7&lt;&#x2F;template&gt;8&lt;script&gt;9export default &#123;10 props: &#123;11 text: &#123;12 type: String13 &#125;14 &#125;,15 methods: &#123;16 onInput(e) &#123;17 this.$emit(&quot;child-event&quot;, e.target.value);18 &#125;19 &#125;20&#125;; 父组件部分 1&lt;template&gt;2 &lt;div class&#x3D;&quot;parent&quot;&gt;3 &lt;p&gt;我是一个父组件&lt;&#x2F;p&gt;4 &lt;br &#x2F;&gt;5 &lt;h1&gt;&#123;&#123;text&#125;&#125;&lt;&#x2F;h1&gt;6 &lt;br &#x2F;&gt;7 &lt;Child :text&#x3D;&quot;text&quot; @child-event&#x3D;&quot;(val)&#x3D;&gt;&#123; text&#x3D;val &#125;&quot; &#x2F;&gt;8 &lt;&#x2F;div&gt;9&lt;&#x2F;template&gt;10&lt;script&gt;11import Child from &quot;.&#x2F;Child&quot;;12export default &#123;13 components: &#123; Child &#125;,14 data() &#123;15 return &#123;16 text: &quot;父组件上默认文本&quot;17 &#125;;18 &#125;19&#125;;20&lt;&#x2F;script&gt; 语法糖解析 通过以上的实现方式，结合vue官网，我们就可以清楚的知道，当我们使用 :text.sync 实际完成了一下几个事情 将自定义属性text通过props传递给子组件 监听v-on:update:text 事件触发 v-on:update:text事件触发会传递过来的数据复制给当前text .sync修饰符实现数据双向绑定 和v-model实现原理一样，.sync也是通过 watch 与 computed 实现数据双向绑定，我本人推荐第二种使用方式 watch监听 和 过渡属性 immediate: true 1&lt;template&gt;2 &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;modelText&quot; &gt;3&lt;&#x2F;template&gt;4&lt;script&gt;5export default &#123;6 props: &#123;7 text: &#123;8 type: String,9 default: &quot;&quot;10 &#125;11 &#125;,12 data () &#123;13 return &#123;14 modelText: &quot;&quot;15 &#125;;16 &#125;,17 watch: &#123;18 text: &#123;19 immediate: true,20 handler (newVal) &#123;21 this.modelText &#x3D; newVal;22 &#125;23 &#125;,24 modelText (newVal) &#123;25 this.$emit(&quot;update:text&quot;, newVal);26 &#125;27 &#125;28&#125;;29&lt;&#x2F;script&gt; 计算属性 setter getter 1&lt;template&gt;2 &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;modelText&quot; &gt;3&lt;&#x2F;template&gt;4&lt;script&gt;5export default &#123;6 props: &#123;7 text: &#123;8 type: String,9 default: &quot;&quot;10 &#125;11 &#125;,12 computed: &#123;13 modelText: &#123;14 get () &#123;15 return this.text;16 &#125;,17 set (newVal) &#123;18 this.$emit(&quot;update:text&quot;, newVal);19 &#125;20 &#125;21 &#125;22&#125;;23&lt;&#x2F;script&gt; 具体 https://github.com/wangxiaoqi0123/vue-cli3-vant/tree/ae/src/views/learn/sync","categories":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/categories/vue-2-0/"}],"tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/tags/vue-2-0/"}]},{"title":"移动端css兼容处理","slug":"css/css01","date":"2020-08-13T16:00:00.000Z","updated":"2023-10-20T06:13:43.353Z","comments":true,"path":"2020/08/14/css/css01/","link":"","permalink":"http://yoursite.com/2020/08/14/css/css01/","excerpt":"","text":"1. 禁止用户缩放1&lt;meta2 name&#x3D;&quot;viewport&quot;3 content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0,minimum-scale&#x3D;1.0,maximum-scale&#x3D;1.0,user-scalable&#x3D;no,viewport-fit&#x3D;cover&quot;4&#x2F;&gt; 2. iphoneX 兼容适配 设置视口viewport-fit=cover 1&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;viewport-fit&#x3D;cover&quot;&gt; 通过 constant() / env() 可以获取到非安全边距，再结合 padding 或 margin 来控制页面元素避开非安全区域。 1&#x2F;&#x2F; safe-area-inset-left：安全区域距离左边界距离，横屏时适配2&#x2F;&#x2F; safe-area-inset-right：安全区域距离右边界距离，横屏时适配3&#x2F;&#x2F; safe-area-inset-top：安全区域距离顶部边界距离，竖屏下刘海屏为44px，iphone6系列20px，竖屏刘海适配关键4&#x2F;&#x2F; safe-area-inset-bottom：安全区域距离底部边界距离，竖屏下为34px，竖屏小黑条适配关键56padding-bottom: constant(safe-area-inset-bottom); &#x2F;* iOS 11.0 *&#x2F;7padding-bottom: env(safe-area-inset-bottom); &#x2F;* iOS 11.2 *&#x2F; 3. 禁止复制与选中文本 1.no-select &#123;2 -webkit-user-select: none;3 -moz-user-select: none;4 -khtml-user-elect: none;5 user-select: none;6&#125; 4. 禁止图片长按 1img &#123;2 pointer-events: none; &#x2F;*禁用鼠标*&#x2F;3&#125; 5. ios滚动不流畅 1body &#123;2 -webkit-overflow-scrolling: touch;3&#125; 6. 安卓键盘弹起视口变小 获取完整屏幕宽高设置新的视口 onresize监听视口变化动态隐藏按钮 7. h5调用安卓或者ios的拨号功能 1&lt;a href&#x3D;&quot;tel:13111111111&quot;&gt;点击拨打13111111111&lt;&#x2F;a&gt;","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"css自定义变量var()函数","slug":"css/css02","date":"2020-08-13T16:00:00.000Z","updated":"2023-10-20T06:13:53.984Z","comments":true,"path":"2020/08/14/css/css02/","link":"","permalink":"http://yoursite.com/2020/08/14/css/css02/","excerpt":"","text":"简单介绍 var() 函数是由css语言提供的，用来自定义css变量的函数。 语法使用 声明变量 使用 --变量名：value 的形式，在根节点/父节点/当前节点 下创建变量1body &#123;2 --red: #f003&#125; 使用变量 使用var()函数，引用 根节点/父节点/当前节点 下声明的变量，完成后样式就可以生效了1.title &#123;2 color: var(--red);3&#125; vue中应用 data 中声明 js 变量1 data() &#123;2 return &#123;3 color: &quot;red&quot;4 &#125;;5&#125; 通过style的方式创建css变量1&lt;div class&#x3D;&quot;box&quot; :style&#x3D;&quot;&#96;--color:$&#123;color&#125;&#96;&quot;&gt;&lt;&#x2F;div&gt; 在css代码中该元素下使用变量1.box &#123;2 width: 200px;3 height: 200px;4 border: 1px solid #000;5 background-color: var(--color);6&#125; 动态改变js中的color变量就可以动态改变动态改变改box中的颜色1&lt;van-button @click&#x3D;&quot;color&#x3D;&#39;green&#39;&quot;&gt;green&lt;&#x2F;van-button&gt; https://github.com/wangxiaoqi0123/vue-cli3-vant/blob/ae/src/views/learn/cv/index.vue 兼容性？ 具体兼容性本人也不知道兼容怎么样，心里也没谱。不过我在小程序中 vant小程序UI库 中见到过这种使用方式。","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"Decorator装饰器","slug":"javascript/javascript03","date":"2020-08-10T16:00:00.000Z","updated":"2023-10-20T06:10:10.235Z","comments":true,"path":"2020/08/11/javascript/javascript03/","link":"","permalink":"http://yoursite.com/2020/08/11/javascript/javascript03/","excerpt":"","text":"装饰器介绍 装饰器（Decorator）是ES2016提出来的一个提案，当前处于Stage 2阶段，目前还没有定案。 本质上是一个函数，使用方式以 @ + 函数名 的形式。 是一种与类（class）相关的语法，用来包装或者修改类或者类的方法的行为。 装饰器属性描述 target 对应修饰方法的父类 name 对应修饰方法的名称(string) descriptor descriptor.configurable：表示能不能通过delete删除属性，能否修改属性的其他描述符特性，或者能否将数据属性修改为访问器属性。当我们通过let obj = {name: ‘’}声明一个对象的时候，这个对象里面所有的属性的configurable描述符的值都是true descriptor.enumerable：表示能不能通过for in或者Object.keys等方式获取到属性，我们一般声明的对象里面这个描述符的值是true,但是对于class类里面的属性来说，这个值是false descriptor.writable：表示能否修改属性的数据值，通过将这个修改为false,可以实现属性只读的效果。 descriptor.value：表示当前属性的数据值，读取属性值的时候，从这里读取；写入属性值的时候，会写到这个位置。 举个例子1class Parent &#123;2 @testable3 test() &#123;4 &#x2F;&#x2F; console.log(&quot;hello World :&gt;&gt; &quot;, &quot;hello World&quot;);5 &#125;6&#125;7function testable(target, name, descriptor) &#123;8 console.log(&quot;target :&gt;&gt; &quot;, target, typeof target); &#x2F;&#x2F; 对应父类Parent9 console.log(&quot;name :&gt;&gt; &quot;, name, typeof name); &#x2F;&#x2F; 直接输出 test string10 console.log(&quot;descriptor :&gt;&gt; &quot;, descriptor, typeof descriptor); &#x2F;&#x2F; 描述属性对象11 console.log(&quot;descriptor.value :&gt;&gt; &quot;, descriptor.value); &#x2F;&#x2F; 对应当前test()函数12 target.isTestable &#x3D; true;13&#125; 类的装饰 类的装饰 一般主要使用 target 属性在其类上添加属性与方法1function testable(target) &#123;2 target.prototype.isTestable &#x3D; true;3&#125;4@testable5class MyTestableClass &#123;&#125;6let obj &#x3D; new MyTestableClass();7obj.isTestable &#x2F;&#x2F; true 方法的装饰 方法的装饰 一般组要使用 descriptor.value 属性对当前修饰的方法进行重写 包装 一般会包裹一层方法用于传递参数1import &#123; Toast &#125; from &quot;vant&quot;;2&#x2F;**3* loading 装饰器4* @param &#123;*&#125; message 提示信息5* @param &#123;function&#125; errorFn 异常处理逻辑6*&#x2F;7export const loading &#x3D; function (message &#x3D; &quot;加载中...&quot;, errorFn &#x3D; function () &#123; &#125;) &#123;8 return function (target, name, descriptor) &#123;9 const fn &#x3D; descriptor.value;10 descriptor.value &#x3D; async function (...rest) &#123;11 const loading &#x3D; Toast.loading(&#123;12 message: message,13 forbidClick: true14 &#125;);15 try &#123;16 return await fn.call(this, ...rest);17 &#125; catch (error) &#123;18 &#x2F;&#x2F; 在调用失败，且用户自定义失败的回调函数时，则执行19 errorFn &amp;&amp; errorFn.call(this, error, ...rest);20 console.error(error);21 &#125; finally &#123;22 loading.clear();23 &#125;24 &#125;;25 &#125;;26&#125;; 装饰器环境配置 Vue项目vue-cli3/4来新建的项目，默认支持了装饰器，不需要再配置太多额外的东西，如果你的项目使用了eslint,那么需要给eslint配置以下内容。1parserOptions: &#123;2 ecmaFeatures:&#123;3 &#x2F;&#x2F; 支持装饰器4 legacyDecorators: true5 &#125;6&#125; 最后 https://github.com/wangxiaoqi0123/vue-cli3-vant/tree/ae/src/views/learn/de","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"vue路由管控","slug":"configuration/configuration04","date":"2020-08-08T16:00:00.000Z","updated":"2023-10-20T04:10:02.772Z","comments":true,"path":"2020/08/09/configuration/configuration04/","link":"","permalink":"http://yoursite.com/2020/08/09/configuration/configuration04/","excerpt":"","text":"1. 创建router 将路由拆分成静态路由与动态路由。静态路由：所有用户均可以访问。动态路由：根据meta内roles权限组动态生成 1import Vue from &quot;vue&quot;;2import Router from &quot;vue-router&quot;;3Vue.use(Router);45&#x2F;**6 * constantRoutes7 * 没有权限要求的基本页面8 * 所有角色都可以访问9 *10 * keepAlive&#x3D;true 页面缓存11 *&#x2F;12export const constantRoutes &#x3D; [13 &#123;14 path: &quot;&#x2F;login&quot;,15 name: &quot;login&quot;,16 meta: &#123;17 title: &quot;登录&quot;18 &#125;,19 component: () &#x3D;&gt; import(&quot;@&#x2F;views&#x2F;login&#x2F;index&quot;)20 &#125;21];2223&#x2F;**24 * asyncRoutes25 * 需要根据用户角色动态加载的路由26 *27 * roles 必须是字符串数组 根据字符串数组 动态匹配路由28 * roles 不写默认所有人都有权限29 *&#x2F;30export const asyncRoutes &#x3D; [31 &#123;32 path: &quot;&#x2F;async&quot;,33 name: &quot;async&quot;,34 meta: &#123;35 title: &quot;async&quot;,36 roles: [&quot;admin&quot;, &quot;editor&quot;]37 &#125;,38 component: () &#x3D;&gt; import(&quot;@&#x2F;views&#x2F;async&quot;)39 &#125;,40 &#x2F;&#x2F; 404页面必须放置在末尾!!!41 &#123; path: &quot;*&quot;, redirect: &quot;&#x2F;404&quot;, hidden: true &#125;42];4344const createRouter &#x3D; () &#x3D;&gt;45 new Router(&#123;46 &#x2F;&#x2F; mode: &#39;history&#39;, &#x2F;&#x2F; require service support47 scrollBehavior: () &#x3D;&gt; (&#123; y: 0 &#125;),48 routes: constantRoutes49 &#125;);50const router &#x3D; createRouter();5152export function resetRouter() &#123;53 const newRouter &#x3D; createRouter();54 router.matcher &#x3D; newRouter.matcher; &#x2F;&#x2F; reset router55&#125;5657export default router; 2. 创建根据权限组动态生成路由方法 此方法引用vue-element-admin动态获取动态路由方法 1import &#123; asyncRoutes, constantRoutes &#125; from &quot;@&#x2F;router&quot;;2&#x2F;**3 * Use meta.role to determine if the current user has permission4 * @param roles5 * @param route6 *&#x2F;7function hasPermission(roles, route) &#123;8 if (route.meta &amp;&amp; route.meta.roles) &#123;9 return roles.some(role &#x3D;&gt; route.meta.roles.includes(role));10 &#125; else &#123;11 return true;12 &#125;13&#125;14&#x2F;**15 * Filter asynchronous routing tables by recursion16 * @param routes asyncRoutes17 * @param roles18 *&#x2F;19export function filterAsyncRoutes(routes, roles) &#123;20 const res &#x3D; [];21 routes.forEach(route &#x3D;&gt; &#123;22 const tmp &#x3D; &#123; ...route &#125;;23 if (hasPermission(roles, tmp)) &#123;24 if (tmp.children) &#123;25 tmp.children &#x3D; filterAsyncRoutes(tmp.children, roles);26 &#125;27 res.push(tmp);28 &#125;29 &#125;);30 return res;31&#125;32const state &#x3D; &#123;33 routes: [],34 addRoutes: []35&#125;;36const mutations &#x3D; &#123;37 SET_ROUTES: (state, routes) &#x3D;&gt; &#123;38 state.addRoutes &#x3D; routes;39 state.routes &#x3D; constantRoutes.concat(routes);40 &#125;41&#125;;42const actions &#x3D; &#123;43 generateRoutes(&#123; commit &#125;, roles) &#123;44 return new Promise(resolve &#x3D;&gt; &#123;45 let accessedRoutes;46 if (roles.includes(&quot;admin&quot;)) &#123;47 accessedRoutes &#x3D; asyncRoutes || [];48 &#125; else &#123;49 accessedRoutes &#x3D; filterAsyncRoutes(asyncRoutes, roles);50 &#125;51 commit(&quot;SET_ROUTES&quot;, accessedRoutes);52 resolve(accessedRoutes);53 &#125;);54 &#125;55&#125;;56export default &#123;57 namespaced: true,58 state,59 mutations,60 actions61&#125;; 3. 根据全局路由守卫，动态管控路由1import router from &quot;.&#x2F;index&quot;;2import store from &quot;..&#x2F;store&#x2F;index&quot;;3import NProgress from &quot;nprogress&quot;; &#x2F;&#x2F; progress bar4import &quot;nprogress&#x2F;nprogress.css&quot;; &#x2F;&#x2F; progress bar style5import &#123; getToken &#125; from &quot;@&#x2F;libs&#x2F;token&quot;;6import &#123; setTitle &#125; from &quot;@&#x2F;libs&#x2F;tools&quot;;7NProgress.configure(&#123; showSpinner: false &#125;); &#x2F;&#x2F; NProgress Configuration89const whiteList &#x3D; [&quot;&#x2F;login&quot;, &quot;&#x2F;404&quot;, &quot;&#x2F;test&quot;]; &#x2F;&#x2F; no redirect whitelist1011router.beforeEach(async (to, from, next) &#x3D;&gt; &#123;12 &#x2F;&#x2F; 开始进度条13 NProgress.start();1415 &#x2F;&#x2F; 确定用户是否已经登录16 const hasToken &#x3D; getToken();1718 if (hasToken) &#123;19 if (to.path &#x3D;&#x3D;&#x3D; &quot;&#x2F;login&quot;) &#123;20 &#x2F;&#x2F; 如果已登录，则重定向到主页21 next(&#123; path: &quot;&#x2F;&quot; &#125;);22 NProgress.done();23 &#125; else &#123;24 &#x2F;&#x2F; 确定用户是否通过getInfo获得了他的权限角色25 const hasRoles &#x3D; store.state.user.roles &amp;&amp; store.state.user.roles.length &gt; 0;26 if (hasRoles) &#123;27 next();28 &#125; else &#123;29 try &#123;30 &#x2F;&#x2F; roles 必须是字符串数组对象 such as: [&#39;admin&#39;] or ,[&#39;developer&#39;,&#39;editor&#39;]31 const &#123; roles &#125; &#x3D; await store.dispatch(&quot;user&#x2F;getInfo&quot;);3233 &#x2F;&#x2F; 根据角色生成可访问路由图34 const accessRoutes &#x3D; await store.dispatch(&quot;permission&#x2F;generateRoutes&quot;, roles);35 &#x2F;&#x2F; 动态添加可访问路由36 router.addRoutes(accessRoutes);3738 &#x2F;&#x2F; 避免首页两次重定向39 if (to.path &#x3D;&#x3D;&#x3D; &quot;&#x2F;home&quot;) &#123;40 next();41 &#125; else &#123;42 &#x2F;&#x2F; 设置replace: true，这样导航将不会留下历史记录43 next(&#123; ...to, replace: true &#125;);44 &#125;45 &#125; catch (error) &#123;46 &#x2F;&#x2F; 清楚 token 重新登录47 await store.dispatch(&quot;user&#x2F;resetToken&quot;);48 next(&quot;&#x2F;login&quot;);49 NProgress.done();50 console.log(&quot;error :&gt;&gt; &quot;, error);51 &#125;52 &#125;53 &#125;54 &#125; else &#123;55 &#x2F;* 没有 token 未登录 *&#x2F;56 if (whiteList.indexOf(to.path) !&#x3D;&#x3D; -1) &#123;57 &#x2F;&#x2F; 在免登录白名单中，直接登录58 next();59 &#125; else &#123;60 &#x2F;&#x2F; 其他没有访问权限的页面被重定向到登录页面。61 next(&quot;&#x2F;login&quot;);62 NProgress.done();63 &#125;64 &#125;65&#125;);66router.afterEach(to &#x3D;&gt; &#123;67 &#x2F;&#x2F; 动态设置HTML meta Title68 setTitle(to, router.app);69 &#x2F;&#x2F; 完成进度条70 NProgress.done();71&#125;); 4. 具体 https://github.com/wangxiaoqi0123/vue-cli3-vant","categories":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}]},{"title":"项目环境配置cross-env","slug":"configuration/configuration01","date":"2020-08-05T16:00:00.000Z","updated":"2023-10-20T04:09:54.621Z","comments":true,"path":"2020/08/06/configuration/configuration01/","link":"","permalink":"http://yoursite.com/2020/08/06/configuration/configuration01/","excerpt":"","text":"安装1npm install --save-dev cross-env 使用 package.json中配置是环境变量VUE_APP_ENV为 开发: dev / 测试：test / 正式：prod 1&#123;2 &quot;scripts&quot;: &#123;3 &quot;dev&quot;: &quot;cross-env VUE_APP_ENV&#x3D;dev vue-cli-service serve --open&quot;,4 &quot;test&quot;: &quot;cross-env VUE_APP_ENV&#x3D;test vue-cli-service serve --open&quot;,5 &quot;build:test&quot;: &quot;cross-env VUE_APP_ENV&#x3D;test vue-cli-service build&quot;,6 &quot;build:prod&quot;: &quot;cross-env VUE_APP_ENV&#x3D;prod vue-cli-service build&quot;,7 &#125;8&#125; 项目中根据环境变量 配置不同的 运行环境 例如：axios 的基础路径 ，项目打包路径 … 1switch (process.env.VUE_APP_ENV) &#123;2 case &quot;dev&quot;:3 BASE_API &#x3D; &quot;&quot;; &#x2F;&#x2F; 开发环境的 接口地址4 break;5 case &quot;test&quot;:6 BASE_API &#x3D; &quot;&quot;; &#x2F;&#x2F; 测试环境的接口地址7 break;8 case &quot;prod&quot;:9 BASE_API &#x3D; &quot;&quot;; &#x2F;&#x2F; 正式环境接口地址10 break;11&#125; cross-env 1.它是运行跨平台设置和使用环境变量(Node中的环境变量)的脚本。2.webpack中本身提供NODE_ENV环境变量，分别对应 开发：development / 生产：production。但是windows不支持NODE_ENV=development的设置方式，使用cross-env可以做到对windows的兼容。","categories":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}]},{"title":"移动端rem适配","slug":"configuration/configuration02","date":"2020-08-05T16:00:00.000Z","updated":"2023-10-20T04:09:57.939Z","comments":true,"path":"2020/08/06/configuration/configuration02/","link":"","permalink":"http://yoursite.com/2020/08/06/configuration/configuration02/","excerpt":"","text":"简单实现rem适配 使用onresize事件，当设备窗口发生变化时，动态设置根节点的font-size 设置尺寸时，以标准设计稿为基础设置，一般以750视口下font-size为100px动态换算当前设备的font-size（750一般为设计稿尺寸）1window.onresize &#x3D; function () &#123;2 &#x2F;&#x2F;窗口发生改变时 触发事件 用来做响应式3 &#x2F;&#x2F;将根节点的fontsize 设置为100px 作为 1rem4 var clientX &#x3D; document.documentElement.clientWidth;5 &#x2F;&#x2F;750:100 &#x3D; clientX:?6 &#x2F;&#x2F;标准设计稿:100px &#x3D; 当前设备宽: ?7 document.documentElement.style.fontSize &#x3D; (clientX &#x2F; 7.5) + &quot;px&quot;;8&#125; 淘宝适配与网易适配 网易适配: 设计稿宽度是 750px，假定当前设计稿的 1rem = 100px，那么 屏幕宽度：设计稿宽度 = 设备的rem:设计稿假定的rem(100)1html&#123;2 font-size: calc(100vw&#x2F;7.5);3 font-size: -webkit-calc(100vw&#x2F;7.5);4&#125; 淘宝适配: 把设备宽度 100vw 分成 10等份，假设当前设备的rem 等于 其中的一份，那么1rem = 10vw1&#x2F;&#x2F; 安装2npm i lib-flexible -S 1&#x2F;&#x2F; main.js 中引入2import &#39;lib-flexible&#39; lib-flexible与postcss-px2rem-exclude适配方案 设置理想视口：把默认的layout viewport的宽度设为移动设备的屏幕宽度，得到理想视口1&lt;meta2 name&#x3D;&quot;viewport&quot;3 content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0,minimum-scale&#x3D;1.0,maximum-scale&#x3D;1.0,user-scalable&#x3D;no,viewport-fit&#x3D;cover&quot;4&#x2F;&gt; 下载安装1npm install lib-flexible postcss-px2rem-exclude --save-dev mian.js引入 lib-flexible1&#x2F;&#x2F; 移动端适配2import &quot;lib-flexible&quot;; 创建.postcssrc.js 使用postcss-px2rem-exclude将px转译为rem1module.exports &#x3D; ctx &#x3D;&gt; &#123;2 &#x2F;&#x2F; vant 文件使用 37.5 适配3 const isNormalDpr &#x3D;4 &#x2F;\\.css$&#x2F;.test(ctx.file.basename) &amp;&amp; &#x2F;\\bvant\\b&#x2F;.test(ctx.file.dirname);5 return &#123;6 plugins: &#123;7 autoprefixer: &#123;&#125;,8 &quot;postcss-px2rem-exclude&quot;: &#123;9 remUnit: isNormalDpr ? 37.5 : 7510 &#125;11 &#125;12 &#125;;13&#125;; 或者1module.exports &#x3D; &#123;2 plugins: &#123;3 autoprefixer: &#123;&#125;,4 &quot;postcss-px2rem-exclude&quot;: &#123;5 &quot;remUnit&quot;: 75,6 exclude: &#x2F;node_modules&#x2F;i &#x2F;&#x2F; 忽略node_modules文件夹下所有文件的适配7 &#125;8 &#125;9&#125; postcss-px-to-viewport适配方案 设置理想视口：把默认的layout viewport的宽度设为移动设备的屏幕宽度，得到理想视口1&lt;meta2 name&#x3D;&quot;viewport&quot;3 content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0,minimum-scale&#x3D;1.0,maximum-scale&#x3D;1.0,user-scalable&#x3D;no,viewport-fit&#x3D;cover&quot;4&#x2F;&gt; 下载安装1npm i postcss-px-to-viewport -D 创建.postcssrc.js 使用postcss-px-to-viewport将px转译为vw1module.exports &#x3D; &#123;2 plugins: &#123;3 autoprefixer: &#123;&#125;, &#x2F;&#x2F; 用来给不同的浏览器自动添加相应前缀，如-webkit-，-moz-等等4 &quot;postcss-px-to-viewport&quot;: &#123;5 &quot;viewportWidth&quot;: 750,6 &quot;minPixelValue&quot;: 1,7 &quot;mediaQuery&quot;: false,8 &quot;selectorBlackList&quot;: [&quot;van&quot;],9 &quot;landscape&quot;: true,10 &quot;landscapeUnit&quot;: &quot;vw&quot;,11 &quot;landscapeWidth&quot;: 2048 12 &#125;13 &#125;14&#125;; 查看postcss-px-to-viewport文档 https://github.com/evrone/postcss-px-to-viewport/blob/master/README_CN.md","categories":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"项目基础配置","slug":"项目基础配置","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"}]},{"title":"JS防抖与节流","slug":"javascript/javascript08","date":"2020-08-02T16:00:00.000Z","updated":"2023-10-20T06:11:35.309Z","comments":true,"path":"2020/08/03/javascript/javascript08/","link":"","permalink":"http://yoursite.com/2020/08/03/javascript/javascript08/","excerpt":"","text":"防抖（debounce） 触发事件后在规定时间内函数只能执行一次，如果在规定时间内又触发了事件，则重新计算函数执行时间 简单实现 1function debounce(func, wait) &#123;2 let timeout;3 return function () &#123;4 let context &#x3D; this;5 let args &#x3D; arguments;6 if (timeout) clearTimeout(timeout);7 timeout &#x3D; setTimeout(() &#x3D;&gt; &#123;8 func.apply(context, args)9 &#125;, wait);10 &#125;11&#125; 原理 利用闭包延长 timeout 变量生命周期 除了第一次函数执行外，每执行一次函数，先关闭定时器，再重新打开定时器 节流（throttle） 事件连续触发时，在规定时间内只执行一次函数 简单实现 1function throttle(func, wait) &#123;2 let timeout;3 return function() &#123;4 let context &#x3D; this;5 let args &#x3D; arguments;6 if (!timeout) &#123;7 timeout &#x3D; setTimeout(() &#x3D;&gt; &#123;8 timeout &#x3D; null;9 func.apply(context, args)10 &#125;, wait)11 &#125;12 &#125;13&#125; 原理 利用闭包延长 timeout 变量生命周期 执行函数时，当 timeout 存在值时不执行定时器，定时器执行完成时将 timeout 置为 null 项目中使用 函数防抖和节流 在公共方法中（如 utils.js 中），加入函数防抖和节流方法1&#x2F;**2* @desc 函数防抖3* @param func 函数4* @param wait 延迟执行毫秒数5* @param immediate true 表立即执行，false 表非立即执行6*&#x2F;7export function _debounce(func, wait, immediate) &#123;8 let timeout;9 return function () &#123;10 let context &#x3D; this;11 let args &#x3D; arguments;12 if (timeout) clearTimeout(timeout);13 if (immediate) &#123;14 var callNow &#x3D; !timeout;15 timeout &#x3D; setTimeout(() &#x3D;&gt; &#123;16 timeout &#x3D; null;17 &#125;, wait);18 if (callNow) func.apply(context, args);19 &#125; else &#123;20 timeout &#x3D; setTimeout(function () &#123;21 func.apply(context, args);22 &#125;, wait);23 &#125;24 &#125;;25&#125;2627&#x2F;**28* @desc 函数节流29* @param func 函数30* @param wait 延迟执行毫秒数31* @param type 1 表时间戳版，2 表定时器版32*&#x2F;33export function _throttle(func, wait, type &#x3D; 1) &#123;34 if (type &#x3D;&#x3D;&#x3D; 1) &#123;35 var previous &#x3D; 0;36 &#125; else if (type &#x3D;&#x3D;&#x3D; 2) &#123;37 var timeout;38 &#125;39 return function () &#123;40 let context &#x3D; this;41 let args &#x3D; arguments;42 if (type &#x3D;&#x3D;&#x3D; 1) &#123;43 let now &#x3D; Date.now();44 if (now - previous &gt; wait) &#123;45 func.apply(context, args);46 previous &#x3D; now;47 &#125;48 &#125; else if (type &#x3D;&#x3D;&#x3D; 2) &#123;49 if (!timeout) &#123;50 timeout &#x3D; setTimeout(() &#x3D;&gt; &#123;51 timeout &#x3D; null;52 func.apply(context, args);53 &#125;, wait);54 &#125;55 &#125;56 &#125;;57&#125; 在需要使用的组件引用1import &#123; _debounce, _throttle &#125; from &quot;@&#x2F;libs&#x2F;utils.js&quot; 在 methods 中使用1methods: &#123;2 debounceClick: _debounce(function() &#123;3 &#x2F;&#x2F; todo 4 &#125;, 200),5 throttleClick: _throttle(function() &#123;6 &#x2F;&#x2F; todo 7 &#125;, 2000)8&#125; 直接使用npm 安装（指令） https://www.npmjs.com/package/v-debounce-throttle 项目中直接引入文件手动 use 安装 （指令） https://github.com/wangxiaoqi0123/vue-cli3-vant/tree/master/src/directive/debounce-throttle","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"Vue $attrs与$listeners","slug":"vue/vue04","date":"2020-07-21T16:00:00.000Z","updated":"2023-10-20T04:21:04.174Z","comments":true,"path":"2020/07/22/vue/vue04/","link":"","permalink":"http://yoursite.com/2020/07/22/vue/vue04/","excerpt":"","text":"简单讲 $attrs 将父组件上的自定义属性，传递到指定的子属性的内部 $listeners 子组件上触发的事件，在父组件上也可以监听到 $attrs 将父组件上的自定义属性，通过v-bind=&#39;$attrs&#39;，传递到绑定的子组件内部 不包含所有父作用域的绑定 class 和 style inheritAttrs默认为true，通过设置 inheritAttrs: false 取消组件的根元素也同样继承属性 父组件在页面上使用 1&lt;Parent title&#x3D;&quot;hello world&quot;&#x2F;&gt; 父组件内给子组件设置 v-bind:&#39;$attrs&#39; 1&lt;template&gt;2 &lt;div&gt;3 &lt;p&gt;我是父组件&lt;&#x2F;p&gt;4 &lt;Child v-bind&#x3D;&quot;$attrs&quot; name&#x3D;&quot;我是子组件&quot; &#x2F;&gt;5 &lt;&#x2F;div&gt;6&lt;&#x2F;template&gt;7&lt;script&gt;8import Child from &quot;.&#x2F;Child&quot;;9export default &#123;10 props: &#123;11 text: &#123;12 type: String,13 default: &quot;&quot;14 &#125;15 &#125;,16 components: &#123; Child &#125;17&#125;;18&lt;&#x2F;script&gt; 子组件内部接受数据 (props/$atters) 1&lt;template&gt;2 &lt;div&gt;3 &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;p&gt;4 &lt;p&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;p&gt;5 &lt;&#x2F;div&gt;6&lt;&#x2F;template&gt;7&lt;script&gt;8export default &#123;9 props: &#123;10 title: &#123;11 type: String,12 default: &quot;&quot;13 &#125;,14 name: &#123;15 type: String,16 default: &quot;&quot;17 &#125;18 &#125;19&#125;;20&lt;&#x2F;script&gt; $listeners 将子组件内触发的事件，传递到父组件上 通过在父组件内部 给子组件 设置 v-on=&quot;$listeners&quot;，父组件标签上就可以自定义子组件内触发的事件 父组件在页面上使用 1&lt;template&gt;2 &lt;Parent @child-event&#x3D;&quot;handleChild&quot; @parent-event&#x3D;&quot;handleParent&quot;&#x2F;&gt;3&lt;&#x2F;template&gt;4&lt;script&gt;5import Parent from &quot;.&#x2F;modules&#x2F;Parent&quot;;6export default &#123;7 components: &#123; Parent &#125;,8 methods: &#123;9 handleChild(val) &#123;10 alert(val);11 &#125;,12 handleParent(val) &#123;13 alert(val);14 &#125;15 &#125;16&#125;;17&lt;&#x2F;script&gt; 父组件内给子组件设置 v-on=&quot;$listeners&quot; 1&lt;template&gt;2 &lt;div&gt;3 &lt;van-button type&#x3D;&quot;info&quot; @click&#x3D;&quot;$emit(&#39;parent-event&#39;,&#39;父事件&#39;)&quot;&gt;父事件&lt;&#x2F;van-button&gt;4 &lt;Child v-on&#x3D;&quot;$listeners&quot; v-bind&#x3D;&quot;$attrs&quot; name&#x3D;&quot;我是子组件&quot; &#x2F;&gt;5 &lt;&#x2F;div&gt;6&lt;&#x2F;template&gt;7&lt;script&gt;8import Child from &quot;.&#x2F;Child&quot;;9export default &#123;10 components: &#123; Child &#125;,11&#125;;12&lt;&#x2F;script&gt; 子组件内发布是事件 1&lt;template&gt;2 &lt;van-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;$emit(&#39;child-event&#39;,&#39;子事件&#39;)&quot;&gt;子事件&lt;&#x2F;van-button&gt;3&lt;&#x2F;template&gt; 最后 具体请查看 https://github.com/wangxiaoqi0123/vue-cli3-vant/tree/master/src/views/learn/al","categories":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/categories/vue-2-0/"}],"tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/tags/vue-2-0/"}]},{"title":"Vuex 底层实现原理","slug":"vue/vue18","date":"2020-07-21T16:00:00.000Z","updated":"2023-10-20T04:24:15.414Z","comments":true,"path":"2020/07/22/vue/vue18/","link":"","permalink":"http://yoursite.com/2020/07/22/vue/vue18/","excerpt":"","text":"1. 创建store挂载到根节点上 创建Store1class Store &#123;2 constructor(options) &#123;&#125;3&#125; 实例Store对象1import Vuex from &#39;.&#x2F;vuex&#39;;2export default new Vuex.Store(&#123;&#125;) 将Store的实例挂载Vue根节点1import store from &#39;.&#x2F;store&#39;;2new Vue(&#123;3 store,4 router,5 render: h &#x3D;&gt; h(App)6&#125;).$mount(&#39;#app&#39;) 2. 挂载全局mixin (子节点在渲染时，添加根节点的store) 创建全局mixin，子节点挂载根节点store1const install &#x3D; (Vue) &#x3D;&gt; &#123;2 Vue.mixin(&#123;3 beforeCreate() &#123;4 &#x2F;&#x2F; 备注：组件渲染是从根节点向子节点渲染5 &#x2F;&#x2F; 使每个组件上都存在根节点的store6 if (this.$options &amp;&amp; this.$options.store) &#123;7 &#x2F;&#x2F; 从根节点上拿到store8 this.$store &#x3D; this.$options.store9 &#125; else &#123;10 &#x2F;&#x2F; 从父组件上查找11 this.$store &#x3D; this.$parent &amp;&amp; this.$parent.$store12 &#125;13 &#125;14 &#125;)15&#125;16export default &#123;17 install,18&#125; 全局挂载mixin1import Vue from &#39;vue&#39;;2import Vuex from &#39;.&#x2F;vuex&#39;;34Vue.use(Vuex) 3. state getters mutations actions 方法实现 state 实现1import Vue from &#39;vue&#39;;2class Store &#123;3 constructor(options) &#123;4 this.vm &#x3D; new Vue(&#123;5 &#x2F;&#x2F; 实现数据双向绑定6 data: &#123;7 state: options.state8 &#125;9 &#125;)10 &#125;11 &#x2F;&#x2F; 创建并暴露state引用12 get state() &#123;13 return this.vm.state14 &#125;15&#125; getters 实现1import Vue from &#39;vue&#39;;2class Store &#123;3 constructor(options) &#123;4 let getters &#x3D; options.getters || &#123;&#125; &#x2F;&#x2F; 传入的getters5 this.getters &#x3D; &#123;&#125; &#x2F;&#x2F; 当前实例getters6 &#x2F;&#x2F; 传入的getters复制到实例上7 Object.keys(getters).forEach(getterName &#x3D;&gt; &#123;8 Object.defineProperty(this.getters, getterName, &#123;9 get: () &#x3D;&gt; &#123;10 return getters[getterName](this.state)11 &#125;12 &#125;)13 &#125;)14 &#125;15&#125; mutations 实现1import Vue from &#39;vue&#39;;2class Store &#123;3 constructor(options) &#123;4 let mutations &#x3D; options.mutations || &#123;&#125; &#x2F;&#x2F; 传入的mutations5 this.mutations &#x3D; &#123;&#125; &#x2F;&#x2F; 当前实例mutations6 &#x2F;&#x2F; 传入的mutations复制到实例上7 Object.keys(mutations).forEach(mutationName &#x3D;&gt; &#123;8 this.mutations[mutationName] &#x3D; payload &#x3D;&gt; &#123;9 mutations[mutationName](this.state, payload)10 &#125;11 &#125;)12 &#125;13 &#x2F;&#x2F; 创建调用mutations内方法的函数14 commit &#x3D; (method, payload) &#x3D;&gt; &#123;15 &#x2F;&#x2F; 注意：使用箭头函数，避免dispatch 嵌套使用时 this 指向问题16 this.mutations[method](payload)17 &#125;18&#125; actions 实现1import Vue from &#39;vue&#39;;2class Store &#123;3 constructor(options) &#123;4 &#x2F;&#x2F; actions5 let actions &#x3D; options.actions || &#123;&#125; &#x2F;&#x2F; 传入的actions6 this.actions &#x3D; &#123;&#125;7 &#x2F;&#x2F; 传入的actions复制到实例上8 Object.keys(actions).forEach(actionName &#x3D;&gt; &#123;9 this.actions[actionName] &#x3D; payload &#x3D;&gt; &#123;10 actions[actionName](this, payload)11 &#125;12 &#125;)13 &#125;14 &#x2F;&#x2F; 创建调用actions内方法的函数15 dispatch &#x3D; (method, payload) &#x3D;&gt; &#123;16 &#x2F;&#x2F; 注意：使用箭头函数，避免dispatch 嵌套使用时 this 指向问题17 this.actions[method](payload)18 &#125;19&#125; 完整实现1import Vue from &#39;vue&#39;;2class Store &#123;3 constructor(options) &#123;4 &#x2F;&#x2F; state5 this.vm &#x3D; new Vue(&#123;6 &#x2F;&#x2F; 实现数据双向绑定7 data: &#123;8 state: options.state9 &#125;10 &#125;)1112 &#x2F;&#x2F; getters13 let getters &#x3D; options.getters || &#123;&#125; &#x2F;&#x2F; 传入的getters14 this.getters &#x3D; &#123;&#125; &#x2F;&#x2F; 当前实例getters15 &#x2F;&#x2F; 传入的getters复制到实例上16 Object.keys(getters).forEach(getterName &#x3D;&gt; &#123;17 Object.defineProperty(this.getters, getterName, &#123;18 get: () &#x3D;&gt; &#123;19 return getters[getterName](this.state)20 &#125;21 &#125;)22 &#125;)2324 &#x2F;&#x2F; mutations25 let mutations &#x3D; options.mutations || &#123;&#125; &#x2F;&#x2F; 传入的mutations26 this.mutations &#x3D; &#123;&#125; &#x2F;&#x2F; 当前实例mutations27 &#x2F;&#x2F; 传入的mutations复制到实例上28 Object.keys(mutations).forEach(mutationName &#x3D;&gt; &#123;29 this.mutations[mutationName] &#x3D; payload &#x3D;&gt; &#123;30 mutations[mutationName](this.state, payload)31 &#125;32 &#125;)3334 &#x2F;&#x2F; actions35 let actions &#x3D; options.actions || &#123;&#125; &#x2F;&#x2F; 传入的actions36 this.actions &#x3D; &#123;&#125;37 &#x2F;&#x2F; 传入的actions复制到实例上38 Object.keys(actions).forEach(actionName &#x3D;&gt; &#123;39 this.actions[actionName] &#x3D; payload &#x3D;&gt; &#123;40 actions[actionName](this, payload)41 &#125;42 &#125;)4344 &#125;4546 &#x2F;&#x2F; 创建调用mutations内方法的函数47 commit &#x3D; (method, payload) &#x3D;&gt; &#123;48 &#x2F;&#x2F; 注意：使用箭头函数，避免dispatch 嵌套使用时 this 指向问题49 this.mutations[method](payload)50 &#125;5152 &#x2F;&#x2F; 创建调用actions内方法的函数53 dispatch &#x3D; (method, payload) &#x3D;&gt; &#123;54 &#x2F;&#x2F; 注意：使用箭头函数，避免dispatch 嵌套使用时 this 指向问题55 this.actions[method](payload)56 &#125;5758 &#x2F;&#x2F; 创建并暴露state引用59 get state() &#123;60 return this.vm.state61 &#125;62&#125;63const install &#x3D; (Vue) &#x3D;&gt; &#123;64 Vue.mixin(&#123;65 beforeCreate() &#123;66 &#x2F;&#x2F; 备注：组件渲染是从根节点向子节点渲染67 &#x2F;&#x2F; 使每个组件上都存在根节点的store68 if (this.$options &amp;&amp; this.$options.store) &#123;69 &#x2F;&#x2F; 从根节点上拿到store70 this.$store &#x3D; this.$options.store71 &#125; else &#123;72 &#x2F;&#x2F; 从父组件上查找73 this.$store &#x3D; this.$parent &amp;&amp; this.$parent.$store74 &#125;75 &#125;76 &#125;)77&#125;78export default &#123;79 install,80 Store81&#125; 4. 最后 具体请查看 https://github.com/wangxiaoqi0123/vue-vuex-hand","categories":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/categories/vue-2-0/"}],"tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/tags/vue-2-0/"}]},{"title":"Iterator与Generator","slug":"javascript/javascript05","date":"2020-07-20T16:00:00.000Z","updated":"2023-10-20T06:10:45.392Z","comments":true,"path":"2020/07/21/javascript/javascript05/","link":"","permalink":"http://yoursite.com/2020/07/21/javascript/javascript05/","excerpt":"","text":"Iterator（迭代器） 概念 iterator是一种接口机制，为不同的数据结构提供统一的访问机制 作用 为各种数据结构（Object、Array、Set、Map…），提供一个统一的、简便的访问接口 使得数据结构的成员能够按照某种次序排列 ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费 执行顺序 创建一个指针对象，指向当前数据结构的起始位置。也就是说遍历器对象本质上，就是一个指针对象 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员 不断调用指针的next方法，直到它指向数据结构的结束位置 模拟next()方法执行 1let it &#x3D; makeIterator([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])2function makeIterator(arr) &#123;3 let nextIndex &#x3D; 0;4 return &#123;5 next: function () &#123;6 return nextIndex &lt; arr.length ? &#123;7 value: arr[nextIndex++],8 done: false9 &#125; : &#123;10 value: undefined,11 done: true12 &#125;13 &#125;14 &#125;15&#125;16console.log(&#39;it.next() :&gt;&gt; &#39;, it.next());&#x2F;&#x2F; &#123; value:&#39;a&#39;, done:false &#125;17console.log(&#39;it.next() :&gt;&gt; &#39;, it.next());&#x2F;&#x2F; &#123; value:&#39;b&#39;, done:false &#125;18console.log(&#39;it.next() :&gt;&gt; &#39;, it.next());&#x2F;&#x2F; &#123; value:&#39;c&#39;, done:false &#125;19console.log(&#39;it.next() :&gt;&gt; &#39;, it.next());&#x2F;&#x2F; &#123; value:undefined, done:true &#125; js数据结构内置iterator接口 Object、Array、Set、Map…内置iterator接口调用方法Symbol.iterator,原型上可查看到 1let arr &#x3D; [&#39;aa&#39;, &#39;bb&#39;, &#39;cc&#39;]2let it &#x3D; arr[Symbol.iterator](); &#x2F;&#x2F;调用Array内置的iterator接口3console.log(&#39;it.next() :&gt;&gt; &#39;, it.next());&#x2F;&#x2F;&#123;value: &quot;aa&quot;, done: false&#125;4console.log(&#39;it.next() :&gt;&gt; &#39;, it.next());&#x2F;&#x2F;&#123;value: &quot;bb&quot;, done: false&#125;5console.log(&#39;it.next() :&gt;&gt; &#39;, it.next());&#x2F;&#x2F;&#123;value: &quot;cc&quot;, done: false&#125;6console.log(&#39;it.next() :&gt;&gt; &#39;, it.next());&#x2F;&#x2F;&#123;value: undefined, done: true&#125; Generator（迭代器生成函数） 概念 Generator是一个迭代器生成函数，其返回值是一个迭代器（Iterator），可用于异步调用 语法 在function后面，函数名之前有个 * ，用来表示函数为Generator函数 函数内部有yield表达式，yield用来定义函数内部的状态 执行机制 调用Generator函数和普通函数一样，在函数名后面加上 () 即可，但是Generator函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针，所以要调用遍历对象Iterator的next方法，指针就会从函数头部或者上一次停下来的地方开始执行 基本使用1function* tell() &#123;2 console.log(&#39;a&#39;);3 yield &#39;a&#39; &#x2F;&#x2F; 暂停的标识4 console.log(&#39;b&#39;);5 yield &#39;b&#39;6&#125;7let it &#x3D; tell() &#x2F;&#x2F; 执行tell()返回的是一个Iterator对象，并不是函数的执行8console.log(it.next());9console.log(it.next()); 分段调用传参1function* myGenerator() &#123;2 console.log(1)3 let a &#x3D; yield &#x2F;&#x2F; 1.暂停标识 2.第二次next的传参4 console.log(&#39;a :&gt;&gt; &#39;, a);5 let b &#x3D; yield6 console.log(&#39;b :&gt;&gt; &#39;, b);7&#125;8let it &#x3D; myGenerator()9it.next(10) &#x2F;&#x2F; 1 第一个next 传参数没有任何意义10it.next(20) &#x2F;&#x2F; 2011it.next(30) &#x2F;&#x2F; 30","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"JS事件执行机制","slug":"javascript/javascript11","date":"2020-07-17T16:00:00.000Z","updated":"2023-10-20T06:12:16.950Z","comments":true,"path":"2020/07/18/javascript/javascript11/","link":"","permalink":"http://yoursite.com/2020/07/18/javascript/javascript11/","excerpt":"","text":"进程与线程 进程 程序的独立执行，它占有一片独有的内存空间 线程 是进程的一个独立执行单元 是程序执行的一个完整流程 是CPU的最小的调度单元 相关 应用程序必须运行在某个进程的某个线程上 一个进程中至少有一个运行的线程：主线程，进程启动后自动创建 一个进程中也可以同时运行多个线程，程序多线程运行 一个进程内的数据可以供其中的多个线程直接共享 多个进程之间的数据是不能直接共享的 线程池（thread pool）: 保存多个线程对象的容器，实现线程对象的反复利用 浏览器内核模块（主要） 主线程 js引擎模块：负责js程序的编译与运行 html,css文档解析模块：负责页面文本的解析 DOM/CSS模块：负责dom/css在内存中的相关处理 布局和渲染模块：负责页面的布局和效果的绘制（内存中的对象） 分线程 定时器模块：负责定时器的管理 事件响应模块：负责事件的管理 网路请求模块：扶着ajax请求 事件循环 （event loop） 执行初始化代码，将事件回调函数交给对应的管理模块 当事件发生时，管理模块会将回调函数及其数据添加到回调队列中 只有当初始化代码执行完后（可能需要一定时间），才会遍历读取回调队列中的回调函数执行 宏任务和微任务 宿主环境提供的叫宏任务，由语言标准提供的叫微任务 宿主环境 简单来说就是能使javascript完美运行的环境，只要能完美运行javascript的载体就是javascript的宿主环境。目前我们常见的两种宿主环境有浏览器和node 语言标准 JavaScript是一种编程语言，JavaScript由ECMA制定标准，称之为ECMAScript,所以由语言标准提供的就是微任务，比如ES6提供的promise.then Object.observe 等。 事件循环中宏任务与微任务 JS异步机制，遇到宏任务，先执行宏任务，将宏任务放入event queue，然后再执行微任务，将微任务放入eventqueue，但是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回调函数，然后再从宏任务的queue拿宏任务的回调函数","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"JS基础","slug":"JS基础","permalink":"http://yoursite.com/tags/JS%E5%9F%BA%E7%A1%80/"}]},{"title":"JS零碎知识","slug":"javascript/javascript10","date":"2020-07-16T16:00:00.000Z","updated":"2023-10-20T06:12:03.541Z","comments":true,"path":"2020/07/17/javascript/javascript10/","link":"","permalink":"http://yoursite.com/2020/07/17/javascript/javascript10/","excerpt":"","text":"内存溢出 一种程序运行的错误 当程序运行需要的内存超过了剩余内存时，就抛出内存溢出的错误 内存泄漏 占用内存没有及时释放 内存泄漏多了就容易导致内存溢出 常见的内存泄漏（1）意外的全局变量（2）没有及时清理的计时器或回调函数（3）闭包 this this 是什么（1）任何函数本质上都是通过某个对象来调用的（如果没有直接指定就是window）（2）所有函数内部都有一个变量this它的值就是调用当前函数的对象 如何确定this的值（1）全局函数调用时，this 为 window（2）以方法的形式调用时，this就为调用方法的那个对象（3）以构造函数的形式实例对象，则构造函数中的this为实例出的对象（4）以call() apply() 方法调用时，this为这两个方法指定的对象（传入的第一个参数）（5）响应函数的this就是绑定事件的那个元素，给谁绑定事件this就为谁（6）ES6中箭头函数没有this，他的this为当前作用域中的this 事件冒泡 所谓的事件冒泡值得就是事件的向上传到，当后代元素上的事件被触发时，其祖先元素上的相同事件也会触发 取消事件冒泡的方法（1）event.cancelBubble = true（2）event.stopPropagation() 事件委派 将事件统一绑定给元素共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"JS基础","slug":"JS基础","permalink":"http://yoursite.com/tags/JS%E5%9F%BA%E7%A1%80/"}]},{"title":"JS闭包","slug":"javascript/javascript07","date":"2020-07-16T16:00:00.000Z","updated":"2023-10-20T06:11:20.163Z","comments":true,"path":"2020/07/17/javascript/javascript07/","link":"","permalink":"http://yoursite.com/2020/07/17/javascript/javascript07/","excerpt":"","text":"闭包理解 如何产生闭包 当一个嵌套的内部（子）函数引用的嵌套的外部（父）函数时，就产生了闭包 闭包是什么 使用chrome调试产看（对应父函数的执行上下文==&gt;Local 中 子函数的 Closure里面 ） 理解一：闭包是嵌套的内部函数 理解二：包含被引用变量（函数）的对象 闭包存在于嵌套的内部函数中 执行函数定义就会产生闭包（不用调用函数内部） 产生闭包的条件 函数嵌套 内部函数引用了外部函数的数据（变量/函数） 常见闭包 将函数作为另一个函数的返回值 1&lt;script&gt;2 function fn1() &#123;3 var a &#x3D; 1;4 function fn2() &#123;5 a++;6 console.log(&#39;a :&gt;&gt; &#39;, a);7 &#125;8 return fn29 &#125;10 var f &#x3D; fn1()11 f()12&lt;&#x2F;script&gt; 将函数实参传递给另一个函数调用 1&lt;script&gt;2 function showDelay(msg, time) &#123;3 setTimeout(() &#x3D;&gt; &#123;4 alert(msg)5 &#125;, time);6 &#125;7 showDelay(&#39;hello world&#39;, 2000)8&lt;&#x2F;script&gt; 闭包作用 使用函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期） 函数执行完成后，函数内部声明的局部变量一般是不存在的，只有存在于闭包中的变量才可能存在 让函数外部可以操作（读写）到函数内部的数据（变量/函数） 函数外部不能直接访问函数内部的变量，但是可以通过闭包去操作它 闭包的生命周期 产生：在嵌套内部函数定义执行完成时就产生了（不是在调用时） 父函数调用时执行上下文对象创建完成时 死亡：在嵌套的内部函数成为垃圾对象时1&lt;script&gt;2 function fn1() &#123;3 &#x2F;&#x2F; 此时闭包就已经产生了（函数提升，内部函数对象已经创建了）4 var a &#x3D; 1;5 function fn2() &#123;6 a++;7 console.log(&#39;a :&gt;&gt; &#39;, a);8 &#125;9 return fn210 &#125;11 var f &#x3D; fn1()12 f()13 f &#x3D; null &#x2F;&#x2F; 闭包死亡（包含闭包的函数对象成为垃圾对象）14&lt;&#x2F;script&gt; 闭包应用定义Js模块 1function myModule () &#123;2 &#x2F;&#x2F; 私有数据3 var msg &#x3D; &#39;Hello World&#39;4 &#x2F;&#x2F; 操作数据的函数5 function doToUpper () &#123;6 console.log(&#39;doToUpper() :&gt;&gt; &#39;, msg.toUpperCase())7 &#125;8 function doToLower () &#123;9 console.log(&#39;doToLower() :&gt;&gt; &#39;, msg.toLowerCase())10 &#125;11 &#x2F;&#x2F; 向外暴露的对象（给外部使用的方法）12 return &#123;13 doToUpper,14 doToLower15 &#125;16&#125; 1&lt;script src&#x3D;&quot;myModules.js&quot;&gt;&lt;&#x2F;script&gt;2&lt;script&gt;3 var module &#x3D; myModule()4 module.doToUpper()5 module.doToLower()6&lt;&#x2F;script&gt; 1(function (window) &#123;2 &#x2F;&#x2F; 私有数据3 var msg &#x3D; &#39;Hello World&#39;4 &#x2F;&#x2F; 操作数据的函数5 function doToUpper () &#123;6 console.log(&#39;doToUpper() :&gt;&gt; &#39;, msg.toUpperCase())7 &#125;8 function doToLower () &#123;9 console.log(&#39;doToLower() :&gt;&gt; &#39;, msg.toLowerCase())10 &#125;11 &#x2F;&#x2F; 向外暴露的对象（给外部使用的方法）12 window.myModule &#x3D; &#123;13 doToUpper,14 doToLower15 &#125;16&#125;)(window) 1&lt;script src&#x3D;&quot;myModules.js&quot;&gt;&lt;&#x2F;script&gt;2&lt;script&gt;3 myModule.doToUpper()4 myModule.doToLower()5&lt;&#x2F;script&gt; 闭包缺点 缺点 函数执行完成后，函数内的局部变量没有释放，占用内存时间会变长 容易造成内存泄漏 解决 及时释放内存 未解之谜1&lt;script&gt;2 function fun(n, o) &#123;3 console.log(o);4 return &#123;5 fun: function (m) &#123;6 return fun(m, n)7 &#125;8 &#125;9 &#125;10 var a &#x3D; fun(0); a.fun(1); a.fun(2); a.fun(3); &#x2F;&#x2F; undefined,?,?,?11 var b &#x3D; fun(0).fun(1).fun(2).fun(3); &#x2F;&#x2F; undefined,?,?,?12 var c &#x3D; fun(0).fun(1); c.fun(2); c.fun(3) &#x2F;&#x2F; undefined,?,?,？ 13&lt;&#x2F;script&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"JS基础","slug":"JS基础","permalink":"http://yoursite.com/tags/JS%E5%9F%BA%E7%A1%80/"}]},{"title":"JS作用域","slug":"javascript/javascript16","date":"2020-07-15T16:00:00.000Z","updated":"2023-10-20T06:13:03.853Z","comments":true,"path":"2020/07/16/javascript/javascript16/","link":"","permalink":"http://yoursite.com/2020/07/16/javascript/javascript16/","excerpt":"","text":"作用域 理解 一个代码段所在的区域 它是静态的，在编写代码时就确定了 分类 全局作用域 函数作用域 作用 隔离变量，不同的作用域下同名变量不会有冲突 作用域与执行上下文 区别一 全局作用域之外，每个函数都会创建自己的作用域。作用域在函数定义时就已经确定了，而不是在函数调用时 全局执行上下文是在全局作用域确定之后，js代码马上执行之前创建 函数执行上下文是在函数调用时，函数体代码执行之前创建 区别二 作用域是静态的，只要函数定义好了就一直存在，且不会再变化 执行上下文是动态的，调用函数时创建，函数调用结束时就会自动释放 联系 执行上下文是从属于于所在的作用域 全局上下文环境==&gt;全局作用域 函数上下文环境==&gt;对应的函数使用域 作用域链 理解 多个上下级关系的作用域形成的链，它的方向是从下向上的（从内到外） 查找变量时就是沿着作用域链来查找的 查找一个变量的查找规则 在当前作用域下的执行上下文中查找对应的属性，如果有直接返回，否则进入2 在上一级作用域的执行上下文中查找对应的属性，如果有直接返回，否则进入3 再次执行2的相同操作，直到全局作用域，如果还找不到就抛出异常 思考 10 还是 20 ？ 1var x &#x3D; 10;2function fn() &#123;3 console.log(&#39;x :&gt;&gt; &#39;, x); &#x2F;&#x2F; 10 还是 20 ？4&#125;5function show(f) &#123;6 var x &#x3D; 207 f()8&#125;9show(fn);","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"JS基础","slug":"JS基础","permalink":"http://yoursite.com/tags/JS%E5%9F%BA%E7%A1%80/"}]},{"title":"JS执行上下文","slug":"javascript/javascript15","date":"2020-07-15T16:00:00.000Z","updated":"2023-10-20T06:12:56.896Z","comments":true,"path":"2020/07/16/javascript/javascript15/","link":"","permalink":"http://yoursite.com/2020/07/16/javascript/javascript15/","excerpt":"","text":"全局执行上下文 在执行全局代码前将window确定为全局执行上下文 对全局数据进行预处理 var定义的全局变量==&gt;undefined，添加为window的属性 function声明的全局函数==&gt;赋值（fun），添加为window的方法 this==&gt;赋值（window） 开始执行全局代码 函数执行上下文 在调用函数之前，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟的，存在于栈内存中） 对局部参数进行预处理 形参变量==&gt;赋值（实参）==&gt;添加为执行上下文的属性 arrguments(伪数组)==&gt;赋值（实参列表），添加为执行上下文的属性 var定义的局部变量==&gt;undefined，添加为执行上下文的属性 function声明的函数==&gt;赋值（fun），添加为执行上下文的方法 this==&gt;赋值（调用函数的对象） 开始执行函数体代码 执行上下文栈 在全局代码执行前，JS引擎就会创建一个栈来存储管理所有的执行上下文对象 在全局执行上下文（window）确定后，将其添加到栈中（压栈） 在函数执行上下文创建后，将其添加到栈中（压栈） 在当前函数执行完后，将栈顶的对象移除（出栈） 当所有代码执行完成后，栈中只剩下window","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"JS基础","slug":"JS基础","permalink":"http://yoursite.com/tags/JS%E5%9F%BA%E7%A1%80/"}]},{"title":"JS函数的prototype","slug":"javascript/javascript09","date":"2020-07-14T16:00:00.000Z","updated":"2023-10-20T06:11:49.445Z","comments":true,"path":"2020/07/15/javascript/javascript09/","link":"","permalink":"http://yoursite.com/2020/07/15/javascript/javascript09/","excerpt":"","text":"函数的prototype属性 每个函数都有一个prototype属性，它默认指向一个Object空对象（即称为：原型对象） 原型对象中有一个属性 constructor，它指向函数对象1console.log(Date.prototype.constructor &#x3D;&#x3D;&#x3D; Date) &#x2F;&#x2F; true 给原型对象添加属性（一般都是方法），函数所有的实例对象自动拥有构造函数原型中的属性（方法） 显式原型与隐式原型 每个函数function都有一个 prototype，即显式原型（属性） 每个实例对象都有一个__proto__，可称为隐式原型（属性） 对象的隐式原型的值为其对应构造函数的显示原型的值 1function Fn()&#123;&#125;2var fn &#x3D; new Fn()3console.log(Fn.prototype &#x3D;&#x3D;&#x3D; fn.__proto__) &#x2F;&#x2F; true 函数的prototype属性：在定义函数时自动添加，默认值是一个空的Object对象 对象的__proto__属性：创建对象时自动添加，默认值是构造函数的prototype属性值 prototype 图解","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"JS基础","slug":"JS基础","permalink":"http://yoursite.com/tags/JS%E5%9F%BA%E7%A1%80/"}]},{"title":"JS原型链","slug":"javascript/javascript14","date":"2020-07-14T16:00:00.000Z","updated":"2023-10-20T06:12:49.887Z","comments":true,"path":"2020/07/15/javascript/javascript14/","link":"","permalink":"http://yoursite.com/2020/07/15/javascript/javascript14/","excerpt":"","text":"原型链 访问一个对象属性时 先在自身属性中查找，找到返回 如果没有，再沿着__proto__这条链先上查找，找到返回 如果最终没找到，返回undefined 作用：查找对象的属性（方法） 构造函数/原型/实例对象的关系（图解） 声明构造函数时 会添加prototype属性 它的值是一个Object空对象 Object空对象为构造函数Object的实例，它的隐式原型__prpto__指向构造函数的显式原型 构造函数Object的原型对象的隐式原型__proto__的值为 null Function/Object/自定义构造函数（图解） 构造函数Function通过new自身创建，他的显式原型与隐式原型是同一个对象 构造函数Object与自定义构造函数通过new Function 创建，属于构造函数Function的实例，它们的隐式原型__proto__指向构造函数Function的显式原型对象。 原型链继承 定义父类型构造函数 给父类型的原型添加方法 定义子类型构造函数 把父类型的实例对象赋值给子类型的原型 给子类型的原型对象上添加方法 实例子类型对象：可以调用父类型的方法 1&lt;script&gt;2 &#x2F;&#x2F; 父类型3 function Supper() &#123;4 this.supProp &#x3D; &#39;Supper property&#39;5 &#125;6 Supper.prototype.showSupperProp &#x3D; function () &#123;7 console.log(&#39;this.supProp :&gt;&gt; &#39;, this.supProp);8 &#125;9 &#x2F;&#x2F; 子类型10 function Sub() &#123;11 this.subProp &#x3D; &#39;Sub property&#39;12 &#125;13 &#x2F;&#x2F; 子类型的原型对象为父类型的一个实例对象14 Sub.prototype &#x3D; new Supper()15 &#x2F;&#x2F; 让子类型的原型的constructor指向子类型16 Sub.prototype.constructor &#x3D; Sub17 Sub.prototype.showSubProp &#x3D; function () &#123;18 console.log(&#39;this.subProp :&gt;&gt; &#39;, this.subProp);19 &#125;20 var sub &#x3D; new Sub()21 sub.showSupperProp() &#x2F;&#x2F; Supper property22&lt;&#x2F;script&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"JS基础","slug":"JS基础","permalink":"http://yoursite.com/tags/JS%E5%9F%BA%E7%A1%80/"}]},{"title":"JS数据变量内存","slug":"javascript/javascript12","date":"2020-07-13T16:00:00.000Z","updated":"2023-10-20T06:12:30.783Z","comments":true,"path":"2020/07/14/javascript/javascript12/","link":"","permalink":"http://yoursite.com/2020/07/14/javascript/javascript12/","excerpt":"","text":"数据 内存中存储的特定信息，本质上是一些0101… 内存 可储存数据的空间 一小块内存的两个部分 内部存储的数据 地址值 内存分类 栈: 全局变量/局部变量 堆: 对象 变量 可变化的量，由变量名和变量值组成 每个变量都对应一小块内存，变量名用来查找对应的内存，变量值就是内存中保存的数据 内存数据变量三者之间的关系 内存用来存储数据的空间 变量是内存的标识 变量创建 赋值 读取 过程 创建 当声明 var obj = { name: ‘Tom’ }，相当于在堆内存开辟一块变量内存地址：0x123存储数据name:&#39;Tom&#39;，同时在栈内存开辟一块变量，变量名obj存储数据为堆内存的引用地址：0x123 赋值 当声明 var a = obj，相当于在栈内存开辟一块变量，变量名a，同时将栈内存中变量obj的数据拷贝一份，赋值给变量a 读取 当执行console.log(obj)，会根据栈内存中obj变量保存的堆内存的引用地址：0x123找到对应的堆内存，将其保存的值(数据)输出","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"JS基础","slug":"JS基础","permalink":"http://yoursite.com/tags/JS%E5%9F%BA%E7%A1%80/"}]},{"title":"JS数据类型","slug":"javascript/javascript13","date":"2020-07-13T16:00:00.000Z","updated":"2023-10-20T06:12:38.292Z","comments":true,"path":"2020/07/14/javascript/javascript13/","link":"","permalink":"http://yoursite.com/2020/07/14/javascript/javascript13/","excerpt":"","text":"分类 基本（值）类型 String: 任意字符串 Number: 任意数字 Boolean: true/false undefined: undefined null: null 对象（引用）类型 Object: 任意对象 Function: 一种特别的对象（可书写逻辑，可执行） Array: 一种特别的对象（数值下标，内部数据是有序的） 判断 typeof: 返回数据类型的字符串表达 可以判断: undefined / 数值 / 字符串 / 布尔值 / function 不能判断: null与object object与array instanceof 判断对象的具体类型（实例 instanceof 构造函数）true/false === 可以判断：undefined , null undefined undefined代表变量定义未赋值 null定义并赋值了，只是值为null null 初始赋值，表明将要赋值为对象 让对象成为垃圾对象（被垃圾回收机制回收） 严格区分变量类型与数据类型 数据的类型 基本类型 对象类型 变量的类型（变量内存值得类型） 基本类型: 保存的为基本类型的数据 引用类型: 保存的为内存引用地址","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"JS基础","slug":"JS基础","permalink":"http://yoursite.com/tags/JS%E5%9F%BA%E7%A1%80/"}]},{"title":"async await 使用方式","slug":"javascript/javascript02","date":"2020-07-11T16:00:00.000Z","updated":"2023-10-20T06:09:51.171Z","comments":true,"path":"2020/07/12/javascript/javascript02/","link":"","permalink":"http://yoursite.com/2020/07/12/javascript/javascript02/","excerpt":"","text":"作用: 用于将 JS异步链式化 使代码从上向下顺序执行, 相当于promise的 .then 的链式操作 asyns 声明了此函数为异步函数 默认返回一个 promise 对象(函数后面可以接 .then 返回的结果就是 async函数里面 return的值 ) await 一般是一个 promise 封装的异步函数 await的结果 是promise返回成功的回调 resolve 的值 1&#x2F;&#x2F; 声明了此函数为异步函数2async asyFun() &#123;3 try &#123;4 let res &#x3D; await this.test();5 console.log(&quot;res :&quot;, res); &#x2F;&#x2F; 随便什么数据6 return res;7 &#125; catch (error) &#123;8 console.log(&quot;error :&quot;, error);9 &#125;10&#125;,11&#x2F;&#x2F; 一般是一个 promise 封装的异步函数12test() &#123;13 return new Promise((resolve, reject) &#x3D;&gt; &#123;14 &#x2F;&#x2F; 做一些异步操作15 setTimeout(function() &#123;16 resolve(&quot;随便什么数据&quot;);17 &#125;, 2000);18 &#125;);19&#125;,20&#x2F;&#x2F; 默认返回一个 promise 对象21handle() &#123;22 this.asyFun().then(data &#x3D;&gt; &#123;23 console.log(&quot;data :&quot;, data); &#x2F;&#x2F; 随便什么数据24 &#125;);25&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Promise 介绍","slug":"javascript/javascript17","date":"2020-07-11T16:00:00.000Z","updated":"2023-10-20T06:13:18.485Z","comments":true,"path":"2020/07/12/javascript/javascript17/","link":"","permalink":"http://yoursite.com/2020/07/12/javascript/javascript17/","excerpt":"","text":"1. Promise是一个构造函数 一般把 一个功能 (或者请求) 封装成 一个函数 并将promise对象返回 1function runAsync()&#123;2 return new Promise(function(resolve, reject)&#123;3 &#x2F;&#x2F;做一些异步操作4 setTimeout(function()&#123;5 console.log(&#39;执行完成&#39;);6 resolve(&#39;随便什么数据&#39;);7 &#125;, 2000);8 &#125;);9&#125;10runAsync() 2. Promise的链式操作 封装好的函数返 return promise对象 then 的回调函数中 要把下一个要执行的函数 return 1runAsync1()2.then(function(data)&#123;3 console.log(data);4 return runAsync2();5&#125;)6.then(function(data)&#123;7 console.log(data);8 return runAsync3();9&#125;)10.then(function(data)&#123;11 console.log(data);12&#125;); 3. then 与 catch then 回调的是resolve回调函数 catch 回调的是reject回调函数 , 且 一旦链式操作里面有 错误 则后面的then不会执行,直接执行catch 4. resolve 与 reject Promise.resolve方法返回一个promise的实例，状态为 resolve 1Promise.resolve(&#39;success&#39;);&#x2F;&#x2F;等价于如下2new Promise((resolve)&#x3D;&gt;&#123;3 resolve(&#39;success&#39;);4&#125;) Promise.reject方法与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected 1Promise.reject(&#39;error&#39;);&#x2F;&#x2F;等价于如下2new Promise((resolve, reject)&#x3D;&gt;&#123;3 reject(&#39;error&#39;);4&#125;) 5. all 所有的promise函数并行执行最后结果一起返回到 results 1Promise2.all([runAsync1(), runAsync2(), runAsync3()])3.then(function(results)&#123;4 console.log(results);5&#125;); 6. race 谁先执行完成就返回谁的数据,其他的都不用 1Promise2.race([runAsync1(), runAsync2(), runAsync3()])3.then(function(results)&#123;4 console.log(results);5&#125;);","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Vue slot 插槽","slug":"vue/vue16","date":"2020-07-11T16:00:00.000Z","updated":"2023-10-20T04:23:44.616Z","comments":true,"path":"2020/07/12/vue/vue16/","link":"","permalink":"http://yoursite.com/2020/07/12/vue/vue16/","excerpt":"","text":"1. 默认插槽 默认插槽 只有一个 添加后 组件标签对里面直接写入类容 1&lt;template&gt;2 &lt;div&gt;3 &lt;h1&gt;header&lt;&#x2F;h1&gt;4 &lt;slot&gt;5 &lt;!-- 添加一个默认插槽，可以在外部随意定义内容 --&gt;6 &lt;&#x2F;slot&gt;7 &lt;&#x2F;div&gt;8&lt;&#x2F;template&gt; 1&lt;template&gt;2 &lt;div&gt;3 &lt;Content&gt;4 &lt;!-- Content组件 添加的slot 内容 --&gt;5 &lt;div&gt;hello world&lt;&#x2F;div&gt;6 &lt;&#x2F;Content&gt;7 &lt;&#x2F;div&gt;8&lt;&#x2F;template&gt; 2. 具名插槽 通过name 指定名称 添加后 组件标签对里 指定对应名称的slot 书写类容 1&lt;template&gt;2 &lt;div&gt;3 &lt;h1&gt;header&lt;&#x2F;h1&gt;4 &lt;slot&gt;5 &lt;!-- 添加一个默认插槽，可以在外部随意定义内容 --&gt;6 &lt;&#x2F;slot&gt;7 &lt;slot name&#x3D;&quot;footer&quot;&gt;8 &lt;!-- 添加 name 名称 外部可指定footer名称来定义内容 --&gt;9 &lt;&#x2F;slot&gt;10 &lt;&#x2F;div&gt;11&lt;&#x2F;template&gt; 1&lt;template&gt;2 &lt;div&gt;3 &lt;Content&gt;4 &lt;div&gt;hello world&lt;&#x2F;div&gt;5 &lt;!-- v-slot:footer 指定 &lt;solt name&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;solt&gt; 的插槽 --&gt;6 &lt;template v-slot:footer&gt;footer&lt;&#x2F;template&gt;7 &lt;&#x2F;Content&gt;8 &lt;&#x2F;div&gt;9&lt;&#x2F;template&gt; 3. 作用域插槽 通过 v-bind 传递出 数据 添加后 通过 v-slot:main=”scope” 下就可以接受组件传递出的数据 1&lt;template&gt;2 &lt;div&gt;3 &lt;h1&gt;header&lt;&#x2F;h1&gt;4 &lt;!-- 通过 v-bind 传递出 数据 --&gt;5 &lt;slot name&#x3D;&quot;main&quot; v-bind&#x3D;&quot;&#123;text:&#39;hello world&#39;&#125;&quot;&gt;&lt;&#x2F;slot&gt;6 &lt;&#x2F;div&gt;7&lt;&#x2F;template&gt; 1&lt;template&gt;2 &lt;div&gt;3 &lt;Content&gt;4 &lt;!-- v-slot:main&#x3D;&quot;scope&quot; 接受到slot传递出的数据 --&gt;5 &lt;template v-slot:main&#x3D;&quot;scope&quot;&gt;&#123;&#123;scope.text&#125;&#125;&lt;&#x2F;template&gt;6 &lt;&#x2F;Content&gt;7 &lt;&#x2F;div&gt;8&lt;&#x2F;template&gt; 4. 默认值插槽 顾名思义 插槽内添加默认值 使用插槽时，插槽内部不添加任意值 就使用插槽 内默认的值 1&lt;template&gt;2 &lt;div&gt;3 &lt;h1&gt;header&lt;&#x2F;h1&gt;4 &lt;slot name&#x3D;&quot;main&quot; v-bind&#x3D;&quot;&#123;text:&#39;hello world&#39;&#125;&quot;&gt;5 &lt;p&gt;这是mian插槽的默认值标签 当使用插槽时 插槽里不添加任意内容 就使用当前默认值&lt;&#x2F;p&gt;6 &lt;&#x2F;slot&gt;7 &lt;&#x2F;div&gt;8&lt;&#x2F;template&gt;","categories":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/categories/vue-2-0/"}],"tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/tags/vue-2-0/"}]},{"title":"Vue 生命周期钩子","slug":"vue/vue08","date":"2020-07-10T16:00:00.000Z","updated":"2023-10-20T04:22:00.164Z","comments":true,"path":"2020/07/11/vue/vue08/","link":"","permalink":"http://yoursite.com/2020/07/11/vue/vue08/","excerpt":"","text":"beforeCreate() 可以获取this(组件 实例)，但无法获取真实的数据和节点 created() 可以获取this(组件 实例)和真实的数据，但无法获取真实的节点 beforeMount() 这个阶段，它渲染出了虚拟DOM mounted() 这个阶段，它渲染出了真实DOM beforeUpdate() 发生更新，可以获取更新后的数据，但是节点还未更新完 updated() 更新完成，数据和节点都是最新的 beforeDestroy() 组件销毁之前的一瞬间 destroyed() 组件被销毁 activated() 组件被激活 deactivated()组件未激活","categories":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/categories/vue-2-0/"}],"tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/tags/vue-2-0/"}]},{"title":"Vue 路由守卫","slug":"vue/vue01","date":"2020-06-18T16:00:00.000Z","updated":"2023-10-20T04:20:12.016Z","comments":true,"path":"2020/06/19/vue/vue01/","link":"","permalink":"http://yoursite.com/2020/06/19/vue/vue01/","excerpt":"","text":"beforeEach 全局前置守卫钩子 router.beforeEach to 即将要进入的目标 路由对象 from 当前导航正要离开的路由 next 路由拦截器 1router.beforeEach((to, from, next) &#x3D;&gt; &#123;2 &#x2F;&#x2F; ...3&#125;) afterEach 全局后置守卫钩子 router.afterEach afterEach 不会接受 next 函数也不会改变导航本身 1router.afterEach((to, from) &#x3D;&gt; &#123;2 &#x2F;&#x2F; ...3&#125;) beforeRouteEnter 进入组件时路由守卫 beforeRouteEnter(to,from,next){} to 进入到哪个路由(默认当前) from 从哪个路由进入 进入之前获取不到 this next 路由拦截器 第一个参数 等价于this 1&lt;script&gt;2export default &#123;3 data()&#123;4 return&#123;5 name:&quot;Arya&quot;6 &#125;7 &#125;,8 beforeRouteEnter(to, from, next) &#123;9 &#x2F;&#x2F; 不能获取组件实例 &#96;this&#96; 因为当钩子执行前，组件实例还没被创建10 console.log(&quot;this :&gt;&gt; &quot;, this);11 next(vm &#x3D;&gt; &#123;12 alert(&quot;hello&quot; + vm.name);13 &#125;);14 &#125;15&#125;16&lt;&#x2F;script&gt; beforeRouteLeave 离开组件时路由守卫 beforeRouteLeave(to,from,next){} from 从哪个路由离开 (默认当前) to 离开到哪个路由 注意 直接为函数的写法 才可以获取到 this next 路由拦截器 第一个参数 等价于 this 1beforeRouteLeave(to, from, next) &#123;2 &#x2F;&#x2F; 导航离开该组件的对应路由时调用 可以访问组件实例 &#96;this&#96;3 &#x2F;&#x2F; 注意 直接为函数的写法 才可以获取到 &#96;this&#96;4 if (confirm(&quot;确定离开此页面吗？&quot;) &#x3D;&#x3D;&#x3D; true) &#123;5 next();6 &#125; else &#123;7 next(false);8 &#125;9&#125; 路由守卫的应用 vue路由守卫实际上为我们提供了一个类似生命周期的函数事件，让我们可以在进入路由前，离开路由时，可以写一下逻辑代码。 to和form，是路由守卫回调函数提供的，进入/离开的两个路由信息对象。它包含了路由所在的所有信息，包含 meta、query、params、path … 这些我们常用的信息","categories":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/categories/vue-2-0/"}],"tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/tags/vue-2-0/"}]},{"title":"export与exports","slug":"javascript/javascript04","date":"2020-06-18T16:00:00.000Z","updated":"2023-10-20T06:10:27.996Z","comments":true,"path":"2020/06/19/javascript/javascript04/","link":"","permalink":"http://yoursite.com/2020/06/19/javascript/javascript04/","excerpt":"","text":"CommonJS 方式 动态引入 代码执行时引入 CommonJS 解构导出exports.key1 = value1exports.key2 = value2exports.key3 = value3 var {key1,key2,key3} = require(‘路径’) CommonJS 对象导出module.exports = { …} var obj = require(‘路径’) ES6 方式 静态引入，代码编译时引入 ES6 结构导出export const key = valueexport function fn () {}export class Fn{} import {key,fn,Fn} from “路径” ES6 对象导出export default {…} import obj from “路径” ES6 模块导入导出 只适合 结构的方式export { key1 , key2} from “路径”","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"watch监听属性 computed计算属性","slug":"vue/vue17","date":"2020-06-18T16:00:00.000Z","updated":"2023-10-20T04:23:58.182Z","comments":true,"path":"2020/06/19/vue/vue17/","link":"","permalink":"http://yoursite.com/2020/06/19/vue/vue17/","excerpt":"","text":"computed 是计算值 有get set 两个方法 默认是 get 应用：就是简化tempalte里面计算和处理props或$emit的传值 具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数 watch 是观察的动作， 应用：监听props，$emit或本组件的值执行异步操作 无缓存性，页面重新渲染时值不变化也会执行 用法 相同 computed 与 watch 里面计算/监听的函数 形式上是函数 实际上是变量 区别一 copmuted 计算的是一个自定义的变量 变量不可以在 data 中存在 watch 监听的是一个必须 已经存在的变量 (data , computed, props …) 区别二 computed 必须依赖一个或者多个数据项,然后对数据进行操作计算, 从而返回一个计算值 ,有get set 两个方法 默认是get方法, set方法 手动添加 可以接受一个修改后的值 val 形参 watch 监听的是一个存在的变量, 且 函数可以接受 newVal, oldVal 两个形参 区别三 computed 不能够实现异步操作 watch 允许异步操作 computed 使用 默认get方法 直接依赖data props computed 等等 中数据 1computed: &#123;2 sum() &#123;3 return this.num1 + this.num2;4 &#125;5&#125; get set 写法 1computed: &#123;2 sum: &#123;3 get() &#123;4 return this.num1 + this.num2;5 &#125;,6 set(val) &#123;7 console.log(&quot;val :&gt;&gt; &quot;, val);8 &#125;9 &#125;10&#125; watch 使用 默认写法 直接监听data中数据的变化1watch: &#123;2 num(newV, oldV) &#123;3 console.log(&quot;newV :&gt;&gt; &quot;, newV);4 console.log(&quot;oldV :&gt;&gt; &quot;, oldV);5 &#125;6&#125; 对象深度监听1watch: &#123;2 &quot;obj.num&quot;: &#123;3 deep: true,4 handler(newV, oldV) &#123;5 console.log(&quot;newV :&gt;&gt; &quot;, newV);6 console.log(&quot;oldV :&gt;&gt; &quot;, oldV);7 &#125;8 &#125;9&#125; immediate 数据首次绑定watch立即执行1watch: &#123;2 &quot;obj.num&quot;: &#123;3 deep: true,4 immediate: true,5 handler(newV, oldV) &#123;6 console.log(&quot;newV :&gt;&gt; &quot;, newV);7 console.log(&quot;oldV :&gt;&gt; &quot;, oldV);8 &#125;9 &#125;10&#125; 总结computed return 依赖值计算的结果watch 监听的变量 发生变化时执行函数内部的语句","categories":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/categories/vue-2-0/"}],"tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/tags/vue-2-0/"}]},{"title":"阿里巴巴图标库","slug":"css/css03","date":"2020-06-18T16:00:00.000Z","updated":"2023-10-20T06:14:03.037Z","comments":true,"path":"2020/06/19/css/css03/","link":"","permalink":"http://yoursite.com/2020/06/19/css/css03/","excerpt":"","text":"线上引用 查找图标添加至项目 进入项目 复制 Font class 在线生成 的地址//at.alicdn.com/t/font_1199553_u7298mmz27i.css 页面 link 引用 注意加 http: 1&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;http:&#x2F;&#x2F;at.alicdn.com&#x2F;t&#x2F;font_1199553_u7298mmz27i.css&quot;&gt; 标签 clas 添加 iconfont 和 对应图标名 1&lt;i class&#x3D;&quot;iconfont icon-xxx&quot;&gt;&lt;&#x2F;i&gt; 当项目 添加新的 图标 在线地址要更新 页面的引用地址也要更新 下载引用 查找图标添加至项目 进入项目 点击下载 解压文件 选取 iconfont.css iconfont.eot iconfont.svg iconfont.ttf iconfont.woff 文件, 放在项目 assets 文件夹下 (最好新建一个文件夹 一起放进去) main.js 中引入 iconfont.css 文件 1import &quot;@&#x2F;assets&#x2F;font&#x2F;iconfont.css&quot;; 标签 clas 添加 iconfont 和 对应图标名 1&lt;i class&#x3D;&quot;iconfont icon-xxx&quot;&gt;&lt;&#x2F;i&gt; 当项目 添加新的 图标 整个文件夹需要重新打包 替换 UI库扩展 iconfontUI 一般也是icon一般也是使用字体图标 所以可以在可添加字体图标的组件上使用 icon=”iconfont icon-xxx” 方式扩展","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"vuex 使用","slug":"vue/vue19","date":"2020-06-18T16:00:00.000Z","updated":"2023-10-20T04:24:40.494Z","comments":true,"path":"2020/06/19/vue/vue19/","link":"","permalink":"http://yoursite.com/2020/06/19/vue/vue19/","excerpt":"","text":"vuex 模块化分类主模块 1import Vue from &quot;vue&quot;;2import Vuex from &quot;vuex&quot;;3import VuexPersistence from &quot;vuex-persist&quot;; &#x2F;&#x2F; vuex 数据持久化45import user from &quot;.&#x2F;module&#x2F;user&quot;; &#x2F;&#x2F; 需要引入的小模块67const vuexLocal &#x3D; new VuexPersistence(&#123;8 storage: window.sessionStorage, &#x2F;&#x2F; 配置浏览器存储位置9 modules: [&quot;user&quot;] &#x2F;&#x2F; 需要持久化的模块10&#125;);1112Vue.use(Vuex);13const store &#x3D; new Vuex.Store(&#123;14 modules: &#123;15 user &#x2F;&#x2F; 模块合并16 &#125;,17 plugins: [vuexLocal.plugin]18&#125;);19export default store; vuex-persist 数据持久化插件 npm install –save vuex-persist 子模块 1const user &#x3D; &#123;2 namespaced: true, &#x2F;&#x2F; 添加模块名称3 state: &#123; &#x2F;&#x2F; 声明全局变量 &#125;,4 getters:&#123; &#x2F;&#x2F; 计算属性 &#125;5 mutations: &#123; &#x2F;&#x2F; 使用 commit(&quot;state 变量名&quot;, value) 提交变量 &#125;,6 actions: &#123; &#x2F;&#x2F; 使用 dispatch(&#123;执行上下文对象&#125;,value) 提交 进而提交mutations 修改state中的值 &#125;7&#125;;8export default user; vuex 使用介绍namespaced vuex中的store分模块管理，需要在store的index.js中引入各个模块，为了解决不同模块命名冲突的问题，将不同模块的namespaced:true，之后在不同页面中引入getter、actions、mutations时，需要加上所属的模块名 state vuex 模块中使用1state: &#123;2 num: 03&#125; 页面使用1import &#123; mapState &#125; from &quot;vuex&quot;; 1computed: &#123;2 ...mapState(&#123;3 num: state &#x3D;&gt; state.user.num4 &#125;)5&#125; 当映射的属性的名称与 state 的 子节点(一级节点) 名称相同时，我们也可以给 mapState 传一个字符串数组。 getters vuex 模块中使用1getters: &#123;2 num1: state &#x3D;&gt; &#123; &#x2F;&#x2F; 通过方法访问3 return state.num + 1;4 &#125;,5 num2: (state, getters) &#x3D;&gt; &#123; &#x2F;&#x2F; 通过属性访问6 return getters.num1 + 10;7 &#125;8&#125; 页面使用1import &#123; mapGetters &#125; from &quot;vuex&quot;; 1computed: &#123;2 ...mapGetters(&#123;3 num1: &quot;user&#x2F;num1&quot;,4 num2: &quot;user&#x2F;num2&quot;5 &#125;)6&#125;, 当映射的属性的名称与 getters 的 子节点(一级节点) 名称相同时，我们也可以给 mapGetters 传一个字符串数组。 mutations 主要用来改变 state 中的数据 不可以书写异步 vuex 模块中使用1mutations: &#123;2 SET_NUM: (state, num) &#x3D;&gt; &#123;3 state.num &#x3D; num;4 &#125;5&#125; 页面使用 $store.commit1&#x2F;&#x2F; namespaced 设置为true 需要设置模块路径2this.$store.commit(&#39;user&#x2F;SET_NUM&#39;,value) mapMutations1import &#123; mapMutations &#125; from &quot;vuex&quot;; 1methods: &#123;2 &#x2F;&#x2F; this.setNum(value) 相当于 this.$store.commit(&#39;user&#x2F;SET_NUM&#39;,value)3 ...mapMutations(&#123;4 setNum: &quot;user&#x2F;SET_NUM&quot;5 &#125;)6&#125; 当映射mutation的名称与 mutation 的 子节点(一级节点) 名称相同时，我们也可以给 mapMutations 传一个字符串数组。 actions 主要用于处理异步动作 vuex 模块中使用1actions: &#123;2 &#x2F;&#x2F; 第一个参数为执行上下文对象 &#123; commit, dispatch, getters &#125; 等等3 async Num(&#123; commit &#125;, num) &#123;4 try &#123;56 &#x2F;&#x2F; 等待异步结果返回后 返回 Promise7 &#x2F;&#x2F; await ...89 return new Promise((resolve, reject) &#x3D;&gt; &#123;10 if (num &gt; 5) &#123;11 &#x2F;&#x2F; 模块内部 不管namespaced是否设置为true 不写模块前缀12 commit(&quot;SET_NUM&quot;, num);13 resolve(num);14 &#125; else &#123;15 reject(num);16 &#125;17 &#125;);18 &#125; catch (e) &#123;19 await Promise.reject(e);20 &#125;21 &#125;22&#125; 页面使用 $store.dispatch1&#x2F;&#x2F; namespaced 设置为true 需要设置模块路径2this.$store.dispatch(&#39;user&#x2F;Num&#39;,value) mapActions1import &#123; mapActions &#125; from &quot;vuex&quot;; 1methods: &#123;2 &#x2F;&#x2F; this.Num(value) 相当于 this.$store.dispatch(&#39;user&#x2F;Num&#39;,value)3 ...mapActions(&#123;4 Num: &quot;user&#x2F;Num&quot;5 &#125;)6&#125; 当映射action的名称与 action 的 子节点(一级节点) 名称相同时，我们也可以给 mapActions 传一个字符串数组。","categories":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/categories/vue-2-0/"}],"tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/tags/vue-2-0/"}]},{"title":"Vue install use 全局挂载","slug":"vue/vue15","date":"2020-06-18T16:00:00.000Z","updated":"2023-10-20T04:23:28.271Z","comments":true,"path":"2020/06/19/vue/vue15/","link":"","permalink":"http://yoursite.com/2020/06/19/vue/vue15/","excerpt":"","text":"Vue.use( plugin ) 参数 {Object | Function} plugin 安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。该方法需要在调用 new Vue() 之前被调用。 全局 components 挂载 准备一个封装完成组件 引入组件,install1import FormDate from &quot;.&#x2F;FormDate.vue&quot;;2&#x2F;&#x2F; 定义 Form 对象3const From &#x3D; &#123;4 &#x2F;&#x2F; install 是默认的方法。当外界在 use 这个组件的时候，就会调用本身的 install 方法，同时传一个 Vue 这个类的参数。5 install: function(Vue) &#123;6 Vue.component(&quot;FormDate&quot;, FormDate);7 &#125;8&#125;;9&#x2F;&#x2F; 导出10export default From; 引入mian.js use 挂载全局1import From from &#39;.&#x2F;components&#x2F;form&#x2F;index.js&#39;2Vue.use(Form) 项目全局直接使用组件 全局 filters 挂载 书写全局 filters 1const filter &#x3D; &#123;&#125;;2filter.install &#x3D; function (Vue) &#123;3 &#x2F;&#x2F; val 默认要过滤的值4 &#x2F;&#x2F; list 过滤器使用时传入的值，不传则没有5 Vue.filter(&quot;TextMap&quot;, (val, list) &#x3D;&gt; &#123;6 let obj &#x3D; list &amp;&amp; list.find(item &#x3D;&gt; item.value &#x3D;&#x3D;&#x3D; val);7 if (obj) &#123;8 return obj.text;9 &#125; else &#123;10 return &quot;&quot;;11 &#125;12 &#125;);13&#125;;14export default filter; 引入mian.js use 挂载全局1import filter from &quot;.&#x2F;libs&#x2F;filter.js&quot;;2Vue.use(filter); 项目全局直接使用过滤器1&lt;div&gt;&#123;&#123;value|TextMap(list)&#125;&#125;&lt;&#x2F;div&gt; 全局 directive 挂载 书写全局 directive1const directive &#x3D; &#123;&#125;;2directive.install &#x3D; function (Vue) &#123;3 Vue.directive(&quot;mydirective&quot;, &#123;4 bind: function () &#123; &#125;,5 inserted: function () &#123; &#125;,6 update: function () &#123; &#125;,7 componentUpdated: function () &#123; &#125;,8 unbind: function () &#123; &#125;9 &#125;);10&#125;;11export default directive; 引入mian.js use 挂载全局1import directive from &quot;.&#x2F;libs&#x2F;directive.js&quot;;2Vue.use(directive); 项目全局直接使用自定义指令1&lt;div v-mydirective&gt;&lt;&#x2F;div&gt; 全局方法挂载 书写全局 方法1export default &#123;2 install(Vue, options) &#123;3 Vue.prototype.$utils &#x3D; &#123;4 &#x2F;&#x2F; 获取连接参数值5 getUrlParams(name) &#123;6 var reg &#x3D; new RegExp(&quot;(^|&amp;)&quot; + name + &quot;&#x3D;([^&amp;]*)(&amp;|$)&quot;, &quot;i&quot;);7 var r &#x3D; window.location.search.substr(1).match(reg);8 if (r !&#x3D; null) &#123;9 return unescape(r[2]);10 &#125;11 return null;12 &#125;13 &#125;;14 &#125;15&#125;; 引入mian.js use 挂载全局1import utils from &quot;@&#x2F;libs&#x2F;utils.js&quot;;2Vue.use(utils); 全局中使用1this.$utils.getUrlParams(name)","categories":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/categories/vue-2-0/"}],"tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/tags/vue-2-0/"}]},{"title":"Vue 单文件组件","slug":"vue/vue05","date":"2020-06-18T16:00:00.000Z","updated":"2023-10-20T04:21:15.448Z","comments":true,"path":"2020/06/19/vue/vue05/","link":"","permalink":"http://yoursite.com/2020/06/19/vue/vue05/","excerpt":"","text":"1&lt;template&gt;2 &lt;div&gt;3 &lt;!-- 书写html区域 --&gt;4 &lt;&#x2F;div&gt;5&lt;&#x2F;template&gt;6&lt;script&gt;7 export default &#123;8 components: &#123;9 &#x2F;&#x2F; 挂载小组件10 &#125;,11 props: [], &#x2F;&#x2F; 接受父组件传递的值12 data() &#123;13 return &#123;14 &#x2F;&#x2F; 声明全局15 &#125;;16 &#125;,17 computed: &#123;18 &#x2F;&#x2F; 计算属性19 &#125;,20 watch: &#123;21 &#x2F;&#x2F; 监听数据值的变化22 &#125;,23 created() &#123;24 &#x2F;&#x2F; vue 被实例化 完成25 &#125;,26 mounted() &#123;27 &#x2F;&#x2F; vue 页面节点渲染完毕28 &#125;,29 methods: &#123;30 &#x2F;&#x2F; 书写 vue 函数31 &#125;32 &#125;;33&lt;&#x2F;script&gt;34&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;35&#x2F;* 书写css区域 *&#x2F;36&lt;&#x2F;style&gt; template 默认只能有一个根节点 可书写 指令 事件 差值表达式 filter 等等 components 注册引入该模板文件 的局部组件 props 接受父组件 传递的数据 data 作为主要数据源 computed 依赖其他数据源的值 计算出新值 watch 监听数据发生变化 created 组件 被实例化 完成 created 页面节点渲染完毕 methods 书写 function scoped 针对当前文件样式锁定","categories":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/categories/vue-2-0/"}],"tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/tags/vue-2-0/"}]},{"title":"Vue 页面缓存 keep-alive","slug":"vue/vue12","date":"2020-06-18T16:00:00.000Z","updated":"2023-10-20T04:22:46.717Z","comments":true,"path":"2020/06/19/vue/vue12/","link":"","permalink":"http://yoursite.com/2020/06/19/vue/vue12/","excerpt":"","text":"配置页面缓存 app.vue 使用keep-alive进行缓存 1&lt;template&gt;2 &lt;div id&#x3D;&quot;app&quot;&gt;3 &lt;keep-alive&gt;4 &lt;router-view v-if&#x3D;&quot;$route.meta.keepAlive&quot; &#x2F;&gt;5 &lt;&#x2F;keep-alive&gt;6 &lt;router-view v-if&#x3D;&quot;!$route.meta.keepAlive&quot; &#x2F;&gt;7 &lt;&#x2F;div&gt;8&lt;&#x2F;template&gt; 自定义router中meta字段条件缓存页面 1&#123;2 path: &quot;&#x2F;announcement&quot;,3 name: &quot;announcement&quot;,4 meta: &#123; keepAlive: true &#125;,5 component: () &#x3D;&gt; import(&quot;@&#x2F;views&#x2F;announcement&quot;)6&#125; 路由守卫 监听路由 进入/离开 1&#x2F;&#x2F; 给页面做缓存，动态初始化2&#x2F;&#x2F; 注意路由要写成function的形式, 否则无法获取this3beforeRouteLeave: function (to, from, next) &#123;4 if (to.name !&#x3D;&#x3D; &quot;announcementContent&quot;) &#123;5 &#x2F;&#x2F; 一些逻辑操作6 &#125;7 next();8&#125; 组件激活生命周期钩子 activated 使用keep-alive 之后页面被缓存 再次打开页面 触发activated 生命周期钩子函数","categories":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/categories/vue-2-0/"}],"tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/tags/vue-2-0/"}]},{"title":"Vue 小知识","slug":"vue/vue11","date":"2020-06-18T16:00:00.000Z","updated":"2023-10-20T04:22:28.459Z","comments":true,"path":"2020/06/19/vue/vue11/","link":"","permalink":"http://yoursite.com/2020/06/19/vue/vue11/","excerpt":"","text":"对象合并的方式 Object.assign(obj ,{}) 在vue中对象的合并 必须是 Object.assign({},obj,{}) 的方式,改变引用地址,从而使数据的视图更新 computed 计算属性 watch 监听属性 形式上是函数 实际上是变量 , 且computed 计算的属性不能在data中存在 Vue 模板中的this指向 window 模板中有且仅有一个顶层标签 所有的数据都是从外向内传递 component 的第一个参数组件名称 可以短横线 可以是驼峰 (不能使用关键字和标签名), 使用组件时 只能使用短横线的形式 给父组件下 子组件 绑定(原生)事件 使用事件修饰符 .native 就可以从父组件上直接监听到子组件 computed 默认get() 方法 手动修改数据 使用set(修改的值)方法 标签是一个虚拟的标签,包裹原生标签,将vue语法写在template,使原生标签与逻辑分离 Vue 中不要使用 function , 尽量使用箭头函数 避免 this 的指向发生问题 页面上是哪个路由组件 就显示哪个组件a.router-link-exact-active 在对应的路由页面 显示对应 router-link 样式 组件切换 1&lt;keep-alive include&#x3D;&quot;froms&quot;&gt;2 &lt;!-- component 站位符用来站位符 --&gt;3 &lt;!-- v-once组件缓存在内存中 --&gt;4 &lt;component :is&#x3D;&#39;temp&#39; v-once&gt;&lt;&#x2F;component&gt;5&lt;&#x2F;keep-alive&gt; Vue.nextTick(callback) 数据和视图更新完成后，触发回调函数 mounted阶段 可通过this.$el获取到元素节点，把其挂载到页面已存在的元素节点上（大多数用于弹出框的挂挂载到根节点上） 1mounted() &#123;2 document.body.appendChild(this.$el)3&#125;","categories":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/categories/vue-2-0/"}],"tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/tags/vue-2-0/"}]},{"title":"事件总线 bus","slug":"vue/vue09","date":"2020-06-18T16:00:00.000Z","updated":"2023-10-20T04:22:16.163Z","comments":true,"path":"2020/06/19/vue/vue09/","link":"","permalink":"http://yoursite.com/2020/06/19/vue/vue09/","excerpt":"","text":"main.js 创建实例化新的vue实例 作为bus 1&#x2F;&#x2F; 使用全局bus 跨组件传递数据2Vue.prototype.bus &#x3D; new Vue(); 数据之间传递 父组件通过 on 监听动作与接受数据 子组件通过 emit 传递动作与数据 注意: 数据传向由子组件传递出数据, 父组件接受数据 子组件emit出数据, 父组件立即响应到数据(不要试图把数据存在this中,打开页面使用) 案例全局loading创建loading组件 1&lt;template&gt;2 &lt;div class&#x3D;&quot;markbox&quot; v-show&#x3D;&quot;loading&quot;&gt;3 &lt;div class&#x3D;&quot;sun-loading&quot;&gt;&lt;&#x2F;div&gt;4 &lt;&#x2F;div&gt;5&lt;&#x2F;template&gt;6&lt;script&gt;7export default &#123;8 name: &quot;loading&quot;,9 data () &#123;10 return &#123;11 loading: false12 &#125;;13 &#125;,14 created () &#123;15 this.bus.$on(&quot;loading&quot;, data &#x3D;&gt; &#123; this.loading &#x3D; !!data; &#125;);16 &#125;17&#125;;18&lt;&#x2F;script&gt; 页面使用组件 1&#x2F;&#x2F; 开启loading2this.bus.$emit(&quot;loading&quot;, true);3&#x2F;&#x2F; 关闭loading4this.bus.$emit(&quot;loading&quot;, false);","categories":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/categories/vue-2-0/"}],"tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/tags/vue-2-0/"}]},{"title":"Vue 数据双向绑定底层实现","slug":"vue/vue10","date":"2020-06-18T16:00:00.000Z","updated":"2023-10-20T04:22:22.741Z","comments":true,"path":"2020/06/19/vue/vue10/","link":"","permalink":"http://yoursite.com/2020/06/19/vue/vue10/","excerpt":"","text":"Vue 2.0 主要通过 Object.defineProperty 实现 vm（改变数据更新视图） 1&lt;!DOCTYPE html&gt;2&lt;html lang&#x3D;&quot;en&quot;&gt;3&lt;head&gt;4 &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;5 &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;6 &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;7 &lt;title&gt;Document&lt;&#x2F;title&gt;8&lt;&#x2F;head&gt;9&lt;body&gt;10 &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;ipt&quot;&gt;11 &lt;span id&#x3D;&quot;text&quot;&gt;&lt;&#x2F;span&gt;12&lt;&#x2F;body&gt;13&lt;script&gt;14 &#x2F;&#x2F;先获取节点15 var ipt &#x3D; document.querySelector(&quot;#ipt&quot;);16 var text &#x3D; document.querySelector(&quot;#text&quot;);17 &#x2F;&#x2F;定义一个数据18 var data &#x3D; &#123;19 content: &quot;123456&quot;,20 &#125;21 &#x2F;&#x2F;实现能够更新数据的函数22 var fn &#x3D; &#123;23 content: [24 function (val) &#123;25 ipt.value &#x3D; val26 &#125;,27 function (val) &#123;28 text.innerHTML &#x3D; val29 &#125;30 ]31 &#125;32 for (let attr in data) &#123;33 &#x2F;&#x2F;得到 data里面的数据 content34 &#x2F;&#x2F;获取到data里原本的值35 var oldVal &#x3D; data[attr]36 &#x2F;&#x2F;通过监听模式来双向监听数据37 &#x2F;&#x2F; 目标对象 目标属性38 Object.defineProperty(data, attr, &#123;39 &#x2F;&#x2F;在读取属性时执行 get() 方法40 get() &#123;41 return oldVal;42 &#125;,43 &#x2F;&#x2F;在调用属性时执行 set() 方法44 set(newVal) &#123;45 if (newVal &#x3D;&#x3D; oldVal) &#123;46 return;47 &#125; else &#123;48 &#x2F;&#x2F;对页面上的两个节点的值进行替换49 fn[attr].forEach(e &#x3D;&gt; e(newVal));50 &#125;51 &#125;52 &#125;)53 &#x2F;&#x2F;初始化视图 , 节点添加数据54 for (let attr in data) &#123;55 fn.content.forEach(e &#x3D;&gt; e(data[attr]))56 &#125;57 &#x2F;&#x2F;改变属性值触发事件58 ipt.oninput &#x3D; function () &#123;59 data.content &#x3D; this.value60 &#125;61 &#125;62&lt;&#x2F;script&gt;63&lt;&#x2F;html&gt;","categories":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/categories/vue-2-0/"}],"tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/tags/vue-2-0/"}]},{"title":"Vue 路由跳转 router","slug":"vue/vue07","date":"2020-06-18T16:00:00.000Z","updated":"2023-10-20T04:21:39.222Z","comments":true,"path":"2020/06/19/vue/vue07/","link":"","permalink":"http://yoursite.com/2020/06/19/vue/vue07/","excerpt":"","text":"Vue 页面中实现跳转 this.$router.push() this.$router.push(‘路由路径’) this.$router.push({name:’组件名称’,path:’路由路径’}) push 方式跳转 导航到不同的 url，向 history 栈添加一个新的记录 this.$router.replace() this.$router.replace(‘路由路径’) this.$router.replace({name:’组件名称’,path:’路由路径’}) replace 方式跳转 导航到不同 url，替换 history 栈中当前记录 this.$router.go() router.go(n)：指定前进/回退的步数。n 为正数的时候是前进；负数的时候是后退；0的时候是刷新当前页面。（===window.history.go） router.back() 回退一步 router-link 1&lt;router-link to&#x3D;&#39;路由路径&#39;&gt; &lt;&#x2F;router-link&gt;2直接在样式中设置 .router-link-exact-active3a.router-link-exact-active &#123;4 color: #d7a51e;5&#125; 1&lt;router-link to&#x3D;&#39;&#123;name:&#39;组件名称&#39;&#125;&#39;&gt; &lt;&#x2F;router-link&gt; 页面的路由信息对象 this.$route Vue 页面中跳转（push/replace） 带参数 跳转传参 方式一 使用params 传递参数this.$router.push({path:’组件路径/‘,params:{变量名:值}})this.$router.push({name:’组件名称’,params:{变量名:值}}) 方式二 使用query 传递参数this.$router.push({path:’组件路径/‘,query:{变量名:值}})this.$router.push({name:’组件名称’,query:{变量名:值}}) 接受参数 this.$route.params.变量名 (一般在 mounted 中接受参数) 页面路由看不见 页面刷新参数消失 this.$route.query.变量名 (一般在 mounted 中接受参数) 页面路由显示 页面刷新参数不消失","categories":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/categories/vue-2-0/"}],"tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/tags/vue-2-0/"}]},{"title":"模块(组件)上的 v-model 实现","slug":"vue/vue02","date":"2020-06-18T16:00:00.000Z","updated":"2023-10-20T04:20:28.072Z","comments":true,"path":"2020/06/19/vue/vue02/","link":"","permalink":"http://yoursite.com/2020/06/19/vue/vue02/","excerpt":"","text":"实现理论 v-model 实际上是 @input + :value 的语法糖 vue 中的 model 允许自定义里面 prop(组件 v-mode 值) event(事件类型)1model: &#123;2 &#x2F;&#x2F; 自定义 v-model 的props 变量名3 prop: &#39;uname&#39;,4 &#x2F;&#x2F; 自定义 v-model $emit事件命名5 event: &#39;changeXXX&#39;6&#125; 两个方向数据双向绑定父向同过 v-model 向组件传值组件通过 this.$emit(“input”, value) 向父传值 注意事项 页面通过 自定义属性的方式组件传值 涉及到异步数据 要对数据进行监听!!! 常用两种实现方式 watch监听 和 过渡属性 immediate: true 1&lt;template&gt;2 &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;modelValue&quot; &gt;3&lt;&#x2F;template&gt;4&lt;script&gt;5export default &#123;6 props: &#123;7 value: &#123;8 type: String,9 default: &quot;&quot;10 &#125;11 &#125;,12 data () &#123;13 return &#123;14 modelValue: &quot;&quot;15 &#125;;16 &#125;,17 watch: &#123;18 value: &#123;19 immediate: true,20 handler (newVal) &#123;21 this.modelValue &#x3D; newVal;22 &#125;23 &#125;,24 modelValue (newVal) &#123;25 this.$emit(&quot;input&quot;, newVal);26 &#125;27 &#125;28&#125;;29&lt;&#x2F;script&gt; 计算属性 setter getter(建议使用) 1&lt;template&gt;2 &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;modelValue&quot; &gt;3&lt;&#x2F;template&gt;4&lt;script&gt;5export default &#123;6 props: &#123;7 value: &#123;8 type: String,9 default: &quot;&quot;10 &#125;11 &#125;,12 computed: &#123;13 modelValue: &#123;14 get () &#123;15 return this.value;16 &#125;,17 set (newVal) &#123;18 this.$emit(&quot;input&quot;, newVal);19 &#125;20 &#125;21 &#125;22&#125;;23&lt;&#x2F;script&gt;","categories":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/categories/vue-2-0/"}],"tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/tags/vue-2-0/"}]},{"title":"Vue 父子组件通讯","slug":"vue/vue06","date":"2020-06-18T16:00:00.000Z","updated":"2023-10-20T04:21:28.328Z","comments":true,"path":"2020/06/19/vue/vue06/","link":"","permalink":"http://yoursite.com/2020/06/19/vue/vue06/","excerpt":"","text":"子组件向父组件传递消息 使用 ref 的方式(1) 父组件下 子组件标签 上标识 ref=”” 标识(2) 父组件 通过 this.$refs.标识 === 子组件Vue实例 父组件通过 $children 的方式获取子组件消息(1) 父组件 通过 this.$children === [子组件Vue实例 ,…] 子组件Vue实例的数组 子组件使用 $emit 的方法 发布订阅向父组件 传递消息(1) 子组件 发布 this.$emit(“订阅事件” , “要传递给父元素的数据”)(2) 父组件下 子组件标签 上添加监听事件 @订阅事件 = callback(3) 要接受的参数 在callback 中实现传递 父组件向子组件传递消息 使用 props 方式(1) 父组件下 子组件标签 通过数据属性向子组件传递数据 :数据名=”数据”(2) 子组件 同过 props:[“数据名”] 的方式接受数据 使用 $parent 的方式获取父元素上的信息(1) 子组件 通过 this.$parent == 父组件Vue实例 (父组件唯一所以不是数组) 兄弟组件之间传递消息(非父子组件) 只有通过 Vue实例 实现通讯的一种方式(1) 创建一个 Vue实例 专门用于实现兄弟元素之间的通讯 var bus = new Vue()(2) 发送消息的兄弟 在 methods 中 使用 bus.$emit(“名称” , 数据)(3) 接受消息的兄弟 在 mounted (生命周期回调函数) 使用 bus.$on(“名称”,callback) 回调函数中接受消息","categories":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/categories/vue-2-0/"}],"tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/tags/vue-2-0/"}]},{"title":"Vue 指令事件样式","slug":"vue/vue13","date":"2020-06-18T16:00:00.000Z","updated":"2023-10-20T04:22:53.708Z","comments":true,"path":"2020/06/19/vue/vue13/","link":"","permalink":"http://yoursite.com/2020/06/19/vue/vue13/","excerpt":"","text":"1. 数据 变量 插值表达式放置 死值放置 变量可以支持运算符 &gt; &lt; ? : ( 三元运算符 ) + - :属性:属性= 后面都支持 运算符 &gt; &lt; ? : ( 三元运算符 ) + - * / data-xxx 自定义属性 1&lt;div @click=\"onGoToDetail\" :data-id=\"postId\"&gt;&lt;/div&gt; 1onGoToDetail(event) &#123;2 console.log(event.srcElement.dataset.id)3&#125; 通过data-形式自定义的属性可以在event.srcElement.dataset中获取到。1.自定义的属性在dataset中data-会被省略。例如 data-id =&gt; id2.当自定义属性中存在大写字母会被转换成小写。例如 data-postId =&gt; postid3.当自定义属性中存在多个-会被转换成驼峰。例如 data-post-id =&gt; postId :style 运算符写法:style=”{color:num == 3 ? ‘red’ :’green’}”:style=”[{color:num == 3 ? ‘red’ :’green’}]” :class 运算符写法:class=”[isShow(变量) ? ‘icon-quanxuan1’(选择器一) : ‘icon-quanxuan’(选择器二)]” 2. 修改数据更新视图 修改数组 对象中的值来改变页面的渲染(数组)通过数组变异方法(可以改变原数组的方法)操作的方法来操作 pop push shift unshift splice sort reserve(数组, 对象)通过改变引用值的方式 , 将整个数组或对象都替换掉(数组, 对象) Vue.set(对象/数组,属性/下标,值) 实例上也可以引用到 set 方法 , this.$set(对象/数组,属性/下标,值)(对象) 原生对象的的合并 Object.assign({},obj,obj) 一定要加{} 改变原来对象值的引用 3. Vue 样式的绑定 :style=”{}” json 格式的对象 :style=”[{},{}]” 数组的形式 :class=”{class 选择器:true}” :class=”[{class 选择器:true},obj,’calss 选择器’]” 4. 修饰符 事件修饰符stop 阻止事件的冒泡 相当于原生的 e.stopPropagation() e.cancelBubble=trueprevent 阻止默认事件 相当于原生的 return false e.returnValue=false e.preventDefault()captrue 事件的捕获self 只有点击时 target 为目标元素 事件才可以生效 v-model 数据修饰符number 自动把绑定的数据类型转化为 number 类型lazy 数据在双向绑定时 只会触发@change 函数 数据修改完成失去焦点时 页面才会重新渲染trim 修剪首尾空格 5. 列表渲染 通过 v-for:”item in/of list” 实现对数组 对象的循环渲染 key 的描述如果不加 key 或者 key 为 index vue 在更新视图的时候, 采用就地更新策略, 每个元素只是一个容器,不会改变现有元素的排列顺序, 只是依次改变容器的内容如果加了 key 并且 key 是唯一标识, vue 在更新列表的时候, 直接复用这些元素, 就会改变现有元素的排列顺序","categories":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/categories/vue-2-0/"}],"tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://yoursite.com/tags/vue-2-0/"}]}]}